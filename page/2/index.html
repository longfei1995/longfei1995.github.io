<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"longfei1995.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="记录生活，记录工作，记录学习">
<meta property="og:type" content="website">
<meta property="og:title" content="胡云浩的blog">
<meta property="og:url" content="https://longfei1995.github.io/page/2/index.html">
<meta property="og:site_name" content="胡云浩的blog">
<meta property="og:description" content="记录生活，记录工作，记录学习">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="胡云浩">
<meta property="article:tag" content="胡云浩, 博客, 笔记">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://longfei1995.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>胡云浩的blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">胡云浩的blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">日常笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://longfei1995.github.io/2024/01/01/other_tools/ubuntu%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡云浩">
      <meta itemprop="description" content="记录生活，记录工作，记录学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="胡云浩的blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/01/other_tools/ubuntu%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">ubuntu基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-01-01T00:00:00+08:00">2024-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-10 17:05:17" itemprop="dateModified" datetime="2025-04-10T17:05:17+08:00">2025-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ubuntu/" itemprop="url" rel="index"><span itemprop="name">ubuntu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1-ubuntu基础"><a href="#1-ubuntu基础" class="headerlink" title="1. ubuntu基础"></a>1. ubuntu基础</h4><h5 id="1-1-系统安装"><a href="#1-1-系统安装" class="headerlink" title="1.1 系统安装"></a>1.1 系统安装</h5><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/38797088">vmware虚拟机装ubuntu</a></p>
<h5 id="1-2-常见问题"><a href="#1-2-常见问题" class="headerlink" title="1.2 常见问题"></a>1.2 常见问题</h5><h6 id="1-2-1-ubuntu虚拟机无网络"><a href="#1-2-1-ubuntu虚拟机无网络" class="headerlink" title="1.2.1 ubuntu虚拟机无网络"></a>1.2.1 ubuntu虚拟机无网络</h6><p>问题描述：ubuntu虚拟机连不上网络，或者右上角没有网络图标。</p>
<p>解决方案：</p>
<p>1.确定宿主机的网络连接方式为NAT模式</p>
<p>2.确定ubuntu版本为20.04</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此操作可以连上网络 </span></span><br><span class="line"><span class="built_in">sudo</span> dhclient ens33</span><br><span class="line">ifconfig ens33</span><br><span class="line"><span class="comment"># 此操作，可以让右上角重现图标</span></span><br><span class="line"><span class="built_in">sudo</span> service NetworkManager stop</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> /var/lib/NetworkManager/NetworkManager.state</span><br><span class="line"><span class="built_in">sudo</span> service NetworkManager start</span><br></pre></td></tr></table></figure>

<h6 id="1-2-2-虚拟机和宿主机无法复制粘贴"><a href="#1-2-2-虚拟机和宿主机无法复制粘贴" class="headerlink" title="1.2.2 虚拟机和宿主机无法复制粘贴"></a>1.2.2 虚拟机和宿主机无法复制粘贴</h6><p>解决方案：安装<code>vmware-tools</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 确保软件包是最新的</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install open-vm-tools</span><br><span class="line"><span class="built_in">sudo</span> apt install open-vm-tools-desktop</span><br><span class="line"><span class="comment"># 查看是否有更新</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt upgrade</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>

<h6 id="1-2-3-设置共享文件夹"><a href="#1-2-3-设置共享文件夹" class="headerlink" title="1.2.3 设置共享文件夹"></a>1.2.3 设置共享文件夹</h6><p>问题描述：虚拟机设置好共享文件夹后，在虚拟机中可能不显示，此时经过如下命令即可显示</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vmhgfs-fuse .host:/ /mnt -o allow_other</span><br></pre></td></tr></table></figure>

<p>如果想要开机启动自动添加此命令，可以加到<code>ubuntu</code>虚拟机的启动脚本<code>/etc/rc.local</code>中。如果没有此文件，那么创建后，赋予权限<code>x</code>即可。<code>rc.local</code>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh -e</span></span><br><span class="line"><span class="built_in">sudo</span> vmhgfs-fuse .host:/ /mnt -o allow_other</span><br></pre></td></tr></table></figure>

<h6 id="1-2-4-启用ssh服务"><a href="#1-2-4-启用ssh服务" class="headerlink" title="1.2.4 启用ssh服务"></a>1.2.4 启用ssh服务</h6><p>作用：让别的电脑可以远程访问你的ubuntu</p>
<p>1.打开终端，安装openssh-server软件包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install openssh-server</span><br></pre></td></tr></table></figure>

<p>​	2.安装完成后，ssh服务默认启动，使用如下命令校验ssh运行状态</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl status ssh</span><br></pre></td></tr></table></figure>

<p>​	3.Ubuntu 默认使用 <a href="https://link.zhihu.com/?target=https://linux265.com/news/3793.html">ufw 防火墙</a>配置工具，如果你启用了防火墙，请确保防火墙打开了 SSH 端口，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw allow ssh</span><br></pre></td></tr></table></figure>

<p>至此，就可以通过SSH远程连接到你的Ubuntu系统了。</p>
<h6 id="1-2-5-ubuntu双屏显示问题"><a href="#1-2-5-ubuntu双屏显示问题" class="headerlink" title="1.2.5 ubuntu双屏显示问题"></a>1.2.5 ubuntu双屏显示问题</h6><p>有时候开机或者锁屏以后，ubuntu不再双屏显示</p>
<ol>
<li><p>首先，我们需要创建一个脚本来配置显示器<code>sudo nano /usr/local/bin/restore-displays.sh</code>在脚本里面添加如下内容，并且给脚本赋上x权限</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待几秒确保系统完全唤醒</span></span><br><span class="line"><span class="built_in">sleep</span> 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用xrandr获取连接的显示器</span></span><br><span class="line">DISPLAYS=$(xrandr | grep <span class="string">&quot; connected&quot;</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设有两个显示器，分别称为DP-0和HDMI-0</span></span><br><span class="line"><span class="comment"># 请使用 xrandr 命令查看您实际的显示器名称并相应修改下面的命令</span></span><br><span class="line">xrandr --output DP-0 --auto --primary</span><br><span class="line">xrandr --output HDMI-0 --auto --right-of DP-0</span><br></pre></td></tr></table></figure>
</li>
<li><p>其次，我们需要创建一个systemd服务来监听屏幕解锁这个事件<code>sudo nano /etc/systemd/system/restore-displays.service</code>，添加以下内容：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Restore display configuration after unlock</span><br><span class="line">After=sleep.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">Environment=DISPLAY=:0</span><br><span class="line">Environment=XAUTHORITY=/home/YOUR_USERNAME/.Xauthority</span><br><span class="line">ExecStart=/usr/local/bin/restore-displays.sh</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=sleep.target</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动上面的服务</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> restore-displays.service</span><br><span class="line"><span class="built_in">sudo</span> systemctl start restore-displays.service</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果使用的是GNOME桌面，还可以添加以下步骤来确保更好的兼容性。创建一个新的脚本：<code>sudo nano /usr/share/gdm/greeter/autostart/restore-displays.desktop</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Type=Application</span><br><span class="line">Name=Restore Displays</span><br><span class="line">Exec=/usr/local/bin/restore-displays.sh</span><br><span class="line">NoDisplay=true</span><br><span class="line">X-GNOME-AutoRestart=true</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="1-3-软件卸载"><a href="#1-3-软件卸载" class="headerlink" title="1.3 软件卸载"></a>1.3 软件卸载</h5><p>要彻底卸载Ubuntu 20.04上的某个软件，您可以按照以下步骤进行操作：</p>
<ol>
<li>卸载软件包<code>sudo apt remove &lt;package-name&gt;</code></li>
<li>卸载包相关的依赖<code>sudo apt autoremove</code></li>
<li>卸载软件包的配置<code>sudo apt purge &lt;package-name&gt;</code></li>
</ol>
<h4 id="2-linux基础"><a href="#2-linux基础" class="headerlink" title="2. linux基础"></a>2. linux基础</h4><img src="images/image-20230703112949624.png" alt="image-20230703112949624" style="zoom:50%;" />

<p>用户是无法直接控制计算机的硬件的，必须通过操作系统内核给出的系统API来控制相应的硬件行为。在<code>windows</code>中，我们可以使用图形界面或者命令行去操作系统。在<code>ubuntu</code>中同样有图形界面和<code>shell</code>。</p>
<p><code>shell</code>是终端程序的统称，是用户和操作系统内核之间的翻译官，<code>ubuntu</code>中使用的是一个常用的<code>shell</code>，名为<code>bash</code>。用<code>echo $SHELL</code>可以查看当前操作系统的默认<code>shell</code>类型。</p>
<h5 id="2-1-常用shell命令"><a href="#2-1-常用shell命令" class="headerlink" title="2.1 常用shell命令"></a>2.1 常用shell命令</h5><p>一个<code>shell</code>命令的一般格式为</p>
<blockquote>
<p>命令名称   [命令参数]   [命令对象]</p>
</blockquote>
<p>命令名称、命令参数与命令对象之间要用空格进行分隔，且字母严格区分大小写。命令参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），一般来说两者分别用“–”与“-”作为前缀。如<code>ls --all</code>或者<code>ls -a</code></p>
<h6 id="2-1-1-echo"><a href="#2-1-1-echo" class="headerlink" title="2.1.1 echo"></a>2.1.1 echo</h6><p>作用：在终端设备上打印字符串或变量提取后的值</p>
<p>语法格式：<code>echo [字符串/$变量]</code></p>
<p>示例：<code>echo hello</code> <code>echo $SHELL</code></p>
<h6 id="2-1-2-date"><a href="#2-1-2-date" class="headerlink" title="2.1.2 date"></a>2.1.2 date</h6><p>作用：显示、设置日期</p>
<p>语法格式：<code>date [+指定格式]</code></p>
<p>示例：</p>
<ul>
<li>显示日期<code>date</code></li>
<li>按照“年-月-日 小时:分钟:秒”的格式查看当前系统时间<code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code></li>
<li>设置系统时间<code>date -s &quot;20230703 13:42:00&quot;</code></li>
</ul>
<h6 id="2-1-3-ps"><a href="#2-1-3-ps" class="headerlink" title="2.1.3 ps"></a>2.1.3 ps</h6><p>作用：查看系统中的进程状态，全程”Process Status”</p>
<p>语法格式：<code>ps [参数]</code></p>
<p>参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-e 显示所有的进程</span><br><span class="line">-f 显示程序间的关系</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<ul>
<li>显示所有和apa相关的进程<code>ps -e | grep apa</code></li>
<li>显示所有和apa相关的进程，并且重定向到txt中<code>ps -e | grep apa &gt; test.txt</code></li>
</ul>
<h6 id="2-1-4-top"><a href="#2-1-4-top" class="headerlink" title="2.1.4 top"></a>2.1.4 top</h6><p>作用：动态地查看系统状态</p>
<p>语法格式：<code>top</code></p>
<p>参数意义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第1行：系统时间、运行时间、登录终端数、系统负载（3个数值分别为1分钟、5分钟、15分钟内的平均值，数值越小意味着负载越低）。</span><br><span class="line">第2行：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数。</span><br><span class="line">第3行：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比等。其中数据均为CPU数据并以百分比格式显示，例如“99.9 id”意味着有99.9%的CPU处理器资源处于空闲。</span><br><span class="line">第4行：物理内存总量、内存空闲量、内存使用量、作为内核缓存的内存量。</span><br><span class="line">第5行：虚拟内存总量、虚拟内存空闲量、虚拟内存使用量、已被提前加载的内存量。</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<ul>
<li>查看系统状态<code>top</code></li>
</ul>
<h6 id="2-1-5-pidof"><a href="#2-1-5-pidof" class="headerlink" title="2.1.5 pidof"></a>2.1.5 pidof</h6><p>作用：查看某个进程的pid号码 </p>
<p>示例：看bash的pid<code>pidof bash</code></p>
<h6 id="2-1-6-kill"><a href="#2-1-6-kill" class="headerlink" title="2.1.6 kill"></a>2.1.6 kill</h6><p>作用：终止某个指定PID进程</p>
<p>语法格式：<code>kill [参数] PID</code></p>
<p>示例：</p>
<ul>
<li>强制杀死进程<code>kill -9 Pid数值</code></li>
<li><code>slay [应用程序名]</code>也是同样的作用</li>
</ul>
<h6 id="2-1-7-history"><a href="#2-1-7-history" class="headerlink" title="2.1.7 history"></a>2.1.7 history</h6><p>作用：显示最近执行过的<code>1000</code>条命令。p.s.可以通过改<code>/etc/profile</code>文件中的变量<code>HISTSIZE</code>去修改容量。</p>
<p>示例：</p>
<ul>
<li><p>查看最近的命令，并且执行序号为10的命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">history</span></span><br><span class="line">    1  <span class="built_in">sudo</span> gedit /etc/apt/sources.list</span><br><span class="line">    2  <span class="built_in">sudo</span> apt update</span><br><span class="line">    3  <span class="built_in">sudo</span> apt upgrade</span><br><span class="line">    4  <span class="built_in">sudo</span> apt update</span><br><span class="line">    5  <span class="built_in">sudo</span> apt upgrade</span><br><span class="line">    6  clear</span><br><span class="line">    7  <span class="built_in">sudo</span> apt install open-vm-tools</span><br><span class="line">    8  <span class="built_in">sudo</span> apt install open-vm-tools-desktop </span><br><span class="line">    9  搜索“终端”，或仅使用键盘快捷键Ctrl + Alt + T。</span><br><span class="line">   10  cmake --version</span><br><span class="line">   11  tar -xvf cmake-3.25.3-linux-x86_64.tar.gz </span><br><span class="line">   12  <span class="built_in">ls</span></span><br><span class="line">   13  <span class="built_in">cd</span> cmake-3.25.3-linux-x86_64/</span><br><span class="line">   14  <span class="built_in">ls</span></span><br><span class="line">   15  <span class="built_in">cd</span> bin/</span><br><span class="line">   16  <span class="built_in">ls</span></span><br><span class="line">   17  <span class="built_in">cd</span> ..</span><br><span class="line">   18  <span class="built_in">ls</span></span><br><span class="line">$ !10</span><br><span class="line">	cmake --version</span><br><span class="line">	cmake version 3.25.3</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="2-1-8-find"><a href="#2-1-8-find" class="headerlink" title="2.1.8 find"></a>2.1.8 find</h6><p>作用：按指定条件查找文件的位置<br>语法：<code>find [查找范围] 查找条件</code></p>
<p>常用参数： p.s. <code>find</code>很特殊，后面虽然是长格式形式，但还是用<code>-</code>，而不是<code>--</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-name 匹配名称</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<ul>
<li><p>查找当前目录下，名字中带apa的文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 创建文件</span><br><span class="line">touch apa.txt apa1.txt apa2.txt</span><br><span class="line"># find</span><br><span class="line">find ./ -name &quot;apa*&quot;</span><br><span class="line"># outputs</span><br><span class="line">./apa2.txt</span><br><span class="line">./apa.txt</span><br><span class="line">./apa1.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找程序目录下，有没有<code>ls</code>程序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入</span></span><br><span class="line"><span class="built_in">sudo</span> find /usr/bin /usr/lib/ -name <span class="string">&quot;ls&quot;</span></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">/usr/bin/ls</span><br><span class="line">/usr/lib/klibc/bin/ls</span><br><span class="line"><span class="comment"># 用whereis命令也可以，whereis是专门用来查找二进制文件的命令</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>扩展：<code>whereis</code>和<code>which</code>也可用来搜索。区别在于：</p>
<ul>
<li><p><code>find</code>可以搜索everything</p>
</li>
<li><p><code>whereis</code>用来搜索二进制程序名+源代码+帮助文档</p>
<img src="images/image-20230706111835893.png" alt="image-20230706111835893" style="zoom: 67%;" />

<ul>
<li><code>which</code>仅仅用来搜索可执行程序，不适用于内置命令或者命令的别名(alias)。试图用<code>which</code>寻找内置命令如<code>cd</code>时，会没有响应或者报错。</li>
</ul>
</li>
</ul>
<img src="images/image-20230922144851146.png" alt="image-20230922144851146" style="zoom:67%;" />

<h6 id="2-1-9-cat"><a href="#2-1-9-cat" class="headerlink" title="2.1.9 cat"></a>2.1.9 cat</h6><p>作用：查看内容较少的文件的内容，英文全称<code>concatenate</code></p>
<p>示例：</p>
<ol>
<li>查看txt内容<code>cat test.txt</code></li>
<li>按行号查看<code>cat -n test.txt</code></li>
</ol>
<h6 id="2-1-10-touch"><a href="#2-1-10-touch" class="headerlink" title="2.1.10 touch"></a>2.1.10 touch</h6><p>作用：创建一个空白的文件或者重设一下文件的日期时间</p>
<p>语法：<code>touch [参数] filename</code></p>
<p>参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-a 仅仅修改读取时间(atime)</span><br><span class="line">-m 仅仅修改修改时间(mtime)</span><br><span class="line">-d 同时修改读取时间和mtime</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<img src="images/image-20230706170346015.png" alt="image-20230706170346015" style="zoom:67%;" />

<h6 id="2-1-11-mv"><a href="#2-1-11-mv" class="headerlink" title="2.1.11 mv"></a>2.1.11 mv</h6><p>作用：剪切或者重命名文件，p.s.如果在同一个目录中将某个文件剪切后还粘贴到当前目录下，其实也就是对该文件进行了重命名操作。</p>
<p>语法：<code>mv [参数] 源文件名字 目标文件名字</code></p>
<p>示例：</p>
<img src="images/image-20230706170712361.png" alt="image-20230706170712361" style="zoom: 67%;" />

<h6 id="2-1-12-tar"><a href="#2-1-12-tar" class="headerlink" title="2.1.12 tar"></a>2.1.12 tar</h6><p>作用：对文件进行压缩或者解压</p>
<p>语法：<code>tar [参数] 文件名称</code></p>
<p>参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-c 创建压缩文件</span><br><span class="line">-x 解压文件</span><br><span class="line">-z 用Gzip解压或者压缩文件</span><br><span class="line">-v 显示压缩或者解压的过程</span><br><span class="line">-f 指定目标文件名</span><br><span class="line">-C 解压到指定目录</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<ul>
<li>压缩文件<code>tar -czvf test.tar.gz ./test</code></li>
<li>解压文件<code>tar -xzvf test.tar.gz -C /home</code></li>
</ul>
<h6 id="2-1-13-tee"><a href="#2-1-13-tee" class="headerlink" title="2.1.13 tee"></a>2.1.13 tee</h6><p>作用：打屏的同时把屏幕输出存到文件中</p>
<p>参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-a	追加写入文件，而非覆盖写入</span><br><span class="line">-i	忽略中断信号</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<ol>
<li><code>ls -l | tee output.txt</code></li>
<li><code>ps -e | grep apa | tee output.txt</code></li>
</ol>
<h6 id="2-1-14-scp"><a href="#2-1-14-scp" class="headerlink" title="2.1.14 scp"></a>2.1.14 scp</h6><p>作用：基于ssh登录的安全远程文件拷贝命令</p>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从本地复制文件到远端</span></span><br><span class="line">scp [选项] local_file remote_username@remote_ip:remote_folder </span><br><span class="line"><span class="comment"># 从远端复制文件到本地</span></span><br><span class="line">scp [选项] remote_username@remote_ip:remote_file local_folder</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-r	递归复制整个目录</span><br><span class="line">-P 	注意是大写的P, 指定数据传输用到的端口号</span><br></pre></td></tr></table></figure>

<h6 id="2-1-15-ln"><a href="#2-1-15-ln" class="headerlink" title="2.1.15 ln"></a>2.1.15 ln</h6><p>作用：创建连接</p>
<p>语法：<code>ln [参数] item link</code></p>
<p>说明：</p>
<ul>
<li>硬链接已经不建议使用了，现在建议使用软连接（符号链接）</li>
<li>删除符号链接时，文件本身并没有被删除</li>
<li>将内容写入符号链接时，那么这些内容也被写入到了文件本身</li>
<li>创建符号链接时，如果item使用相对路径，那么item和链接一起被移动的时候，也不会破坏链接。更加可取</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># example 在桌面创建某个文件夹的快捷方式</span></span><br><span class="line"><span class="built_in">ln</span> -s /home/hyh/coder/cpp/notes/ ~/Desktop/</span><br></pre></td></tr></table></figure>

<h6 id="2-1-16-cd"><a href="#2-1-16-cd" class="headerlink" title="2.1.16 cd"></a>2.1.16 cd</h6><p>作用：改变当前工作目录</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">cd</td>
<td align="center">进入主工作目录</td>
</tr>
<tr>
<td align="center">cd -</td>
<td align="center">将工作目录改成先前的工作目录</td>
</tr>
</tbody></table>
<h6 id="2-1-17-file"><a href="#2-1-17-file" class="headerlink" title="2.1.17 file"></a>2.1.17 file</h6><p>作用：在linux中，一切皆文件。<code>file</code>用来确定文件的类型</p>
<p>用法：<code>file &lt;filename&gt;</code></p>
<h6 id="2-1-18-less"><a href="#2-1-18-less" class="headerlink" title="2.1.18 less"></a>2.1.18 less</h6><p>作用：用来查看文本程序的内容</p>
<p>用法：<code>less &lt;filename&gt;</code>	用键盘方向键可以翻页，用鼠标滚轮也可以，按<code>q</code>退出</p>
<h6 id="2-1-19-type"><a href="#2-1-19-type" class="headerlink" title="2.1.19 type"></a>2.1.19 type</h6><p>作用：用来显示命令的类型</p>
<p>用法：<code>type &lt;命令&gt;</code></p>
<p>小知识：linux的命令可以分为以下四种类型</p>
<ol>
<li>可执行程序，用户自己写的或者下载的可执行程序</li>
<li>shell的内置命令，比如<code>cd</code>等</li>
<li>shell函数</li>
<li><code>alias</code>命令，可以在其他命令的基础上定义自己的命令</li>
</ol>
<h6 id="2-1-20-alias"><a href="#2-1-20-alias" class="headerlink" title="2.1.20 alias"></a>2.1.20 alias</h6><p>作用：给命令取别名</p>
<p>用法：<code>alias name=&quot;string&quot;</code></p>
<h6 id="2-1-21-perf"><a href="#2-1-21-perf" class="headerlink" title="2.1.21 perf"></a>2.1.21 perf</h6><p>作用：perf是Linux内核提供的一个强大的性能分析工具，用于采集各种类型的性能数据</p>
<p>用法：</p>
<ol>
<li>安装perf工具</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install linux-tools-common linux-tools-generic linux-tools-`<span class="built_in">uname</span> -r`</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>启动我们要测试的程序，并且记录下程序的pid</p>
</li>
<li><p>使用perf记录cpu信息</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> perf record -p &lt;程序PID&gt; -e cpu-clock -g</span><br><span class="line"><span class="comment"># record: record子命令用于记录程序运行过程中的性能事件。</span></span><br><span class="line"><span class="comment"># -p: 指定程序的pid</span></span><br><span class="line"><span class="comment"># -e event，一般使用cpu-cycles参数，但是在虚拟机中，这个参数是无效的，得使用cpu-clock参数。详见</span></span><br><span class="line">https://stackoverflow.com/questions/21155354/perf-data-file-has-no-samples</span><br><span class="line"><span class="comment"># -g: 记录调用栈，这对于后续生成火焰图是必要的，因为火焰图需要栈信息来构建。</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>运行完成后，将<code>perf.data</code>转换为<code>out.perf</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> perf script &gt; out.perf</span><br><span class="line"><span class="comment"># script: script 是 perf 的一个子命令，用于将之前通过 perf record 命令收集的原始二进制性能数据转换为可读的文本格式。</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>将<code>out.perf</code>拖到<a target="_blank" rel="noopener" href="https://profiler.firefox.com/%E5%8D%B3%E5%8F%AF%E6%9F%A5%E7%9C%8B%E7%81%AB%E7%84%B0%E5%9B%BE">https://profiler.firefox.com/即可查看火焰图</a></li>
</ol>
<p><img src="/images/1-1713497090622-1.png" alt="1"></p>
<h5 id="2-2-实用调试"><a href="#2-2-实用调试" class="headerlink" title="2.2 实用调试"></a>2.2 实用调试</h5><h6 id="2-2-1-输出重定向"><a href="#2-2-1-输出重定向" class="headerlink" title="2.2.1 输出重定向"></a>2.2.1 输出重定向</h6><p>作用：输出重定向指的是把原本要打印在屏幕上的东西存到指定文件中</p>
<p>语法: <code>&gt;</code>覆写， <code>&gt;&gt;</code>追加</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">命令 &gt; 文件	 	<span class="comment">#只将标准输出重定向到一个文件中（清空原有文件的数据）</span></span><br><span class="line">命令 2&gt; 文件	<span class="comment">#只将错误输出重定向到一个文件中（清空原有文件的数据）</span></span><br><span class="line">命令 &amp;&gt; 文件    <span class="comment">#将标准输出与错误输出共同写入到文件中（清空原有文件的数据）</span></span><br></pre></td></tr></table></figure>

<p>参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">标准输出重定向（STDOUT，文件描述符为1）文件描述符1可以省略不写，是默认的</span><br><span class="line">错误输出重定向（STDERR，文件描述符为2）</span><br></pre></td></tr></table></figure>

<p>特殊文件：<code>/dev/null</code></p>
<p>这个特殊文件，接收输入却不对输入做任何的处理。我们可以借助这个文件，来屏蔽命令的打屏。</p>
<p>例如有如下的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;normal msg&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;error msg&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别重定向正常输出、错误输出、正常&amp;错误输出，测试打印如下：</p>
<p><img src="/images/image-20230925101839302.png" alt="image-20230925101839302"></p>
<h6 id="2-2-2-管道符"><a href="#2-2-2-管道符" class="headerlink" title="2.2.2 管道符"></a>2.2.2 管道符</h6><p>作用：把前一个命令原本要输出到屏幕的信息当作后一个命令的标准输入</p>
<p>语法：<code>命令A | 命令B</code></p>
<h6 id="2-2-3-命令通配符"><a href="#2-2-3-命令通配符" class="headerlink" title="2.2.3 命令通配符"></a>2.2.3 命令通配符</h6><p>作用：用来匹配通用信息的符号</p>
<p>参数表：<code>[]</code>用来找文件，<code>&#123;&#125;</code>用来生成文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">通配符					  含义</span><br><span class="line">*						任意字符</span><br><span class="line">?						单个任意字符</span><br><span class="line">[abcd]					匹配abcd中任意一个字符</span><br><span class="line">[a-z]					a-z范围内的字符</span><br><span class="line">&#123;...&#125;					表示生成序列，以逗号分隔，且不能有空格</span><br><span class="line">&#123;a..z&#125;					生成a-z</span><br><span class="line">[!abcd]					不匹配abcd中的任意字符</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<img src="images/image-20230712162309340.png" alt="image-20230712162309340" style="zoom:67%;" />

<h6 id="2-2-4-转义字符"><a href="#2-2-4-转义字符" class="headerlink" title="2.2.4 转义字符"></a>2.2.4 转义字符</h6><p>作用：linux中有很多符号都是有特殊含义的，如果期望将这个字符当成普通字符来处理，需要经过<code>\</code>转义</p>
<p>参数表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">反斜杠\			使反斜杠后面的字符变为单纯的字符。</span><br><span class="line">单引号&#x27;&#x27;			单引号里面的变量都是普通字符串</span><br><span class="line">双引号&quot;&quot;			双引号里面的变量保持了变量原有的属性</span><br><span class="line">反引号``			把其中的命令执行后返回结果</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<img src="images/image-20230712164254284.png" alt="image-20230712164254284" style="zoom:67%;" />

<h6 id="2-2-5-常用变量"><a href="#2-2-5-常用变量" class="headerlink" title="2.2.5 常用变量"></a>2.2.5 常用变量</h6><p>在Linux系统中，变量名称一般都是大写的，命令则都是小写的，这是一种约定俗成的规范。</p>
<p>常用变量表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">变量名称						 作用</span><br><span class="line">HOME						   	用户的主目录（即家目录）</span><br><span class="line">SHELL							用户在使用的Shell解释器名称</span><br><span class="line">LANG							系统语言、语系名称</span><br><span class="line">PATH							定义解释器搜索用户执行命令的路径</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<img src="images/image-20230712165210295.png" alt="image-20230712165210295" style="zoom:67%;" />

<p>tips:</p>
<ul>
<li><p>如果工作需要，可以使用<code>export</code>命令将变量提升为全局变量，这样其他用户也就可以使用它了</p>
</li>
<li><p>直接在终端设置的变量能够立即生效，但在重启终端后就会失效，因此我们需要将变量和变量值写入到.bashrc或者.bash_profile文件中，以确保永久能使用它们。</p>
</li>
</ul>
<h6 id="2-2-6-使用TDA4的GDB"><a href="#2-2-6-使用TDA4的GDB" class="headerlink" title="2.2.6 使用TDA4的GDB"></a>2.2.6 使用TDA4的GDB</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># source环境</span></span><br><span class="line"><span class="built_in">source</span> /usr/local/sdk/pps/qnx710/qnxsdp-env.sh</span><br><span class="line"><span class="comment"># 使用gdb</span></span><br><span class="line">/usr/local/sdk/pps/qnx710/host/linux/x86_64/usr/bin/ntoaarch64-gdb apa_plan apa_plan.core</span><br></pre></td></tr></table></figure>

<h5 id="2-3-常见问题"><a href="#2-3-常见问题" class="headerlink" title="2.3 常见问题"></a>2.3 常见问题</h5><h6 id="2-3-1-重定向权限不够"><a href="#2-3-1-重定向权限不够" class="headerlink" title="2.3.1 重定向权限不够"></a>2.3.1 重定向权限不够</h6><p>问题背景：想要把echo打印重定向到<code>/usr/local</code>的某个文件中，即使加了<code>sudo</code>，也提示权限不够。</p>
<p><img src="/images/image-20230815102941280.png" alt="image-20230815102941280"></p>
<p>问题解析：</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/82256/how-do-i-use-sudo-to-redirect-output-to-a-location-i-dont-have-permission-to-wr">linux - How do I use sudo to redirect output to a location I don’t have permission to write to? - Stack Overflow</a></p>
<p>这是因为<code>sudo</code>只是给了当前shell执行<code>echo</code>的管理员权限，并没有给当前shell执行重定向<code>&gt;</code>的权限。</p>
<p>问题解决：</p>
<p>使用<code>bash -c</code>让<code>bash</code>作为解释器执行整条命令</p>
<p><img src="/images/image-20230815103740385.png" alt="image-20230815103740385"></p>
<h4 id="3-shell脚本"><a href="#3-shell脚本" class="headerlink" title="3. shell脚本"></a>3. shell脚本</h4><h5 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h5><h6 id="3-1-1-注释"><a href="#3-1-1-注释" class="headerlink" title="3.1.1 注释"></a>3.1.1 注释</h6><p><code>#</code>是shell脚本的注释符</p>
<h6 id="3-1-2-指定解释器"><a href="#3-1-2-指定解释器" class="headerlink" title="3.1.2 指定解释器"></a>3.1.2 指定解释器</h6><p>如果脚本首行不指定解释器，那么脚本会以系统的默认解释器<code>echo $SHELL</code>运行。可以通过<code>#!</code>指定脚本的解释器，如<code>#!/bin/bash</code>。</p>
<p><code>tips:</code>可以通过<code>cat /etc/shells</code>查看系统中已安装的解释器</p>
<h6 id="3-1-3-变量"><a href="#3-1-3-变量" class="headerlink" title="3.1.3 变量"></a>3.1.3 变量</h6><p>指向内存中的一块区域，<code>shell</code>脚本中的变量无需指定数据类型。要使用变量，必须在变量前加入<code>$</code>符号。</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TEST=<span class="string">&quot;hello&quot;</span> 	<span class="comment"># 等号两边不能有空格</span></span><br><span class="line">TEST_2=$(<span class="built_in">pwd</span>)	<span class="comment"># 可以将命令执行以后的结果赋值给一个变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$TEST</span></span><br></pre></td></tr></table></figure>

<p>示例2：将用户的输入读取到变量中</p>
<p><code>read</code>命令用于接收键盘的输入，用法为<code>read -p &quot;PROMPT MESSAGE&quot; VARIABLE</code>。其中<code>PROMPT MESSAGE</code>为提示用户的信息，变量<code>VARIABLE</code>可以保存用户的输入，可以在程序中使用该变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请按下对应数字，执行相应的功能。运行apa_plan(1), 运行ralog(2), 运行apa_plan&amp;&amp;ralog(3), 记录所有的log(4)&quot;</span> CHOOSE_NUM</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;用户选择了<span class="variable">$CHOOSE_NUM</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>tips:</code>如果<code>shell</code>脚本中添加了变量，必须使用<code>source</code>或<code>.</code>方法去执行脚本</p>
<p>比如<code>shell</code>脚本中添加了环境变量<code>export PATH=/usr/local/mdc_sdk/dp_gea/mdc_cross_compiler/bin:$PATH</code>。那么在执行<code>shell</code>脚本时，不能直接.&#x2F;xx.sh，因为通过这种方式执行一个脚本其实是在子shell中运行的，执行的结果只对子shell有效，并不会在父shell中生效。正确的方式是：<strong>source xx.sh</strong>。source命令的作用是在当前bash终端下读取并执行shell文件中的命令。</p>
<h6 id="3-1-4-条件测试语句"><a href="#3-1-4-条件测试语句" class="headerlink" title="3.1.4 条件测试语句"></a>3.1.4 条件测试语句</h6><p>主要用于条件判断，语法为<code>[ 条件表达式 ]</code></p>
<p>注意： 1. <code>[]</code>的前后必须有空格。如<code>[ -e /etc/passwd ]</code>。<code>[-e /etc/passwd]</code>是错误的写法。</p>
<p>​			 2. 如果<code>[]</code>中的表达式成立，那么返回数字0。不成立返回其它非零值。</p>
<p>针对第二点，可能与<code>C++</code>语言有点反差，可以通过以下语句测试。<code>$?</code>可以显示上次命令执行后的返回值</p>
<img src="images/image-20230713151354755.png" alt="image-20230713151354755" style="zoom:67%;" />

<p>判断文件情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-d FILE_NAME  <span class="comment"># True if FILE_NAME is a directory</span></span><br><span class="line">-e FILE_NAME  <span class="comment"># True if FILE_NAME exists</span></span><br><span class="line">-f FILE_NAME  <span class="comment"># True if FILE_NAME exists and is a regular file</span></span><br><span class="line">-r FILE_NAME  <span class="comment"># True if FILE_NAME is readable</span></span><br><span class="line">-s FILE_NAME  <span class="comment"># True if FILE_NAME exists and is not empty</span></span><br><span class="line">-w FILE_NAME  <span class="comment"># True if FILE_NAME has write permission</span></span><br><span class="line">-x FILE_NAME  <span class="comment"># True if FILE_NAME is executable</span></span><br></pre></td></tr></table></figure>

<p>判断字符串</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-z STRING  			<span class="comment"># True if STRING is empty</span></span><br><span class="line">-n STRING  			<span class="comment"># True if STRING is not empty</span></span><br><span class="line">STRING1 == STRIN2 	<span class="comment"># True if strings are equal</span></span><br><span class="line">STRING1 != STRIN2 	<span class="comment"># True if strings are not equal</span></span><br></pre></td></tr></table></figure>

<p>判断数字</p>
<p>为什么<code>linux</code>不使用<code>&lt;</code>,<code>&gt;</code>等符号，因为这个和重定向符冲突</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var1 -eq var2  <span class="comment"># True if var1 is equal to var2</span></span><br><span class="line">var1 -ne var2  <span class="comment"># True if var1 not equal to var2</span></span><br><span class="line">var1 -lt var2  <span class="comment"># True if var1 is less than var2</span></span><br><span class="line">var1 -gt var2  <span class="comment"># True if var1 is greater than var2</span></span><br><span class="line">var1 -le var2  <span class="comment"># True if var1 is less than or equal to var2</span></span><br><span class="line">var1 -ge var2  <span class="comment"># True if var1 is greater than or equal to var2</span></span><br></pre></td></tr></table></figure>

<h6 id="3-1-5-条件语句"><a href="#3-1-5-条件语句" class="headerlink" title="3.1.5 条件语句"></a>3.1.5 条件语句</h6><p>1.<code>if</code>语句</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition-is-true ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">command</span> 1</span><br><span class="line">  <span class="built_in">command</span> 2</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">  <span class="built_in">command</span> N</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<img src="images/image-20230713152826213.png" alt="image-20230713152826213" style="zoom:67%;" />

<p><code>if-else</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition-is-true ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">command</span> 1</span><br><span class="line"><span class="keyword">elif</span> [ condition-is-true ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">command</span> 2</span><br><span class="line"><span class="keyword">elif</span> [ condition-is-true ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">command</span> 3</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">command</span> 4</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>2.<code>case</code>语句</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$VAR</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">  pattern_1)</span><br><span class="line">    <span class="comment"># commands when $VAR matches pattern 1</span></span><br><span class="line">    ;;</span><br><span class="line">  pattern_2)</span><br><span class="line">    <span class="comment"># commands when $VAR matches pattern 2</span></span><br><span class="line">    ;;</span><br><span class="line">  *)</span><br><span class="line">    <span class="comment"># This will run if $VAR doesnt match any of the given patterns</span></span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Enter the answer in Y/N: &quot;</span> ANSWER</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$ANSWER</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">[yY] | [yY][eE][sS])</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;The answer is Yes. &quot;</span></span><br><span class="line">  ;;</span><br><span class="line">[nN] | [nN][oO])</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;The answer is NO. &quot;</span></span><br><span class="line">  ;;</span><br><span class="line">*)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Invalid Answer .&quot;</span></span><br><span class="line">  ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<h6 id="3-1-6-循环语句"><a href="#3-1-6-循环语句" class="headerlink" title="3.1.6 循环语句"></a>3.1.6 循环语句</h6><p>1.<code>for</code>循环</p>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> VARIABLE_NAME <span class="keyword">in</span> ITEM_1 ITEM_N</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">command</span> 1</span><br><span class="line">  <span class="built_in">command</span> 2</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">  <span class="built_in">command</span> N</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>示例1：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">COLORS=<span class="string">&quot;red green blue&quot;</span></span><br><span class="line">COLORS2=<span class="string">&quot;yellow black&quot;</span></span><br><span class="line"><span class="keyword">for</span> COLOR <span class="keyword">in</span> <span class="variable">$COLORS</span> <span class="variable">$COLORS2</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;The color is <span class="variable">$COLOR</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>示例2：C式<code>for</code>循环</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">N=10</span><br><span class="line"><span class="keyword">for</span> ((I=<span class="number">0</span>;I&lt;N;I++)) </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;now I = <span class="variable">$I</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>2.<code>while</code>循环</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ CONNDITION_IS_TRUE ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="comment"># Commands will change he entry condition</span></span><br><span class="line">  <span class="built_in">command</span> 1</span><br><span class="line">  <span class="built_in">command</span> 2</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">  <span class="built_in">command</span> N</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h6 id="3-1-7-参数传递"><a href="#3-1-7-参数传递" class="headerlink" title="3.1.7 参数传递"></a>3.1.7 参数传递</h6><p>作用：运行脚本时，可以传递参数给脚本内部使用</p>
<p>参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">参数			   含义</span><br><span class="line">$0				取出脚本的名字</span><br><span class="line">$n				取出第n个参数的名字</span><br><span class="line">$#				统计总共有几个参数</span><br><span class="line">$*				获取所有位置的参数</span><br></pre></td></tr></table></figure>

<img src="images/image-20230713144320757.png" alt="image-20230713144320757" style="zoom:50%;" />

<p>例子：</p>
<img src="images/image-20230713144655911.png" alt="image-20230713144655911" style="zoom:67%;" />

<h5 id="3-2-shell脚本示例"><a href="#3-2-shell脚本示例" class="headerlink" title="3.2 shell脚本示例"></a>3.2 shell脚本示例</h5><h6 id="3-2-1-j5平台的启动脚本"><a href="#3-2-1-j5平台的启动脚本" class="headerlink" title="3.2.1 j5平台的启动脚本"></a>3.2.1 j5平台的启动脚本</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">function source_x86 &#123;</span><br><span class="line">    cd platform_sdk/x86/ || exit</span><br><span class="line">    source export_env.sh</span><br><span class="line">    cd - || exit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function source_j5 &#123;</span><br><span class="line">    cd platform_sdk/J5/ || exit</span><br><span class="line">    source export_env.sh</span><br><span class="line">    cd - || exit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function source_x9u &#123;</span><br><span class="line">    route add -net 224.0.0.0 netmask 255.255.255.0 eth0</span><br><span class="line">    cd platform_sdk/x9u/ || exit</span><br><span class="line">    source export_env.sh</span><br><span class="line">    cd - || exit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function run_exe() &#123;</span><br><span class="line">    cd build/&quot;$1&quot;/ || exit</span><br><span class="line">    ./&quot;$1&quot;</span><br><span class="line">    cd - || exit</span><br><span class="line">&#125;</span><br><span class="line">if [ &quot;$1&quot; == &quot;x86&quot; ]; then</span><br><span class="line">  echo &quot;run $2 in x86 platform&quot;</span><br><span class="line">  source_x86</span><br><span class="line">  run_exe &quot;$2&quot;</span><br><span class="line">elif [ &quot;$1&quot; == &quot;j5&quot; ]; then</span><br><span class="line">  echo &quot;run $2 in j5 platform&quot;</span><br><span class="line">  source_j5</span><br><span class="line">  run_exe &quot;$2&quot;</span><br><span class="line">elif [ &quot;$1&quot; == &quot;x9u&quot; ]; then</span><br><span class="line">  echo &quot;run $2 in x86 platform&quot;</span><br><span class="line">  source_x9u</span><br><span class="line">  run_exe &quot;$2&quot;</span><br><span class="line">else</span><br><span class="line">  echo &quot;Invalid input. Please provide valid input such as:&quot;</span><br><span class="line">  echo &quot;./run.sh x86 apa_plan&quot;</span><br><span class="line">  echo &quot;./run.sh j5 apa_plan&quot;</span><br><span class="line">  echo &quot;./run.sh x9u apa_plan&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h4 id="4-docker"><a href="#4-docker" class="headerlink" title="4 docker"></a>4 docker</h4><h5 id="4-1-安装"><a href="#4-1-安装" class="headerlink" title="4.1 安装"></a>4.1 安装</h5><h6 id="4-1-1-docker的安装"><a href="#4-1-1-docker的安装" class="headerlink" title="4.1.1 docker的安装"></a>4.1.1 docker的安装</h6><p><code>sudo apt install docker.io</code></p>
<h6 id="4-1-2-安装后的实用操作"><a href="#4-1-2-安装后的实用操作" class="headerlink" title="4.1.2 安装后的实用操作"></a>4.1.2 安装后的实用操作</h6><p><strong>1.如何避免每次使用sudo</strong></p>
<blockquote>
<p>问题描述：创建非root用户访问后，就不需要每次在docker命令前加sudo</p>
</blockquote>
<p>解决方法：<br>(1)首先创建docker用户组，如果docker用户组存在可以忽略</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker</span><br></pre></td></tr></table></figure>

<p>(2)把用户添加进docker组中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gpasswd -a $&#123;USER&#125; docker</span><br></pre></td></tr></table></figure>

<p>(3)重启docker（最好logout一次）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service docker restart</span><br></pre></td></tr></table></figure>

<p>(4)如果普通用户执行docker命令，如果提示get …… dial unix &#x2F;var&#x2F;run&#x2F;docker.sock权限不够，则修改&#x2F;var&#x2F;run&#x2F;docker.sock权限使用root用户执行如下命令，即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod a+rw /var/run/docker.sock</span><br></pre></td></tr></table></figure>

<p><strong>2.修改docker的默认储存路径</strong></p>
<blockquote>
<p> 问题描述：docker默认会使用&#x2F;var&#x2F;lib&#x2F;docker&#x2F;目录作为存储目录，用以存放拉取的镜像和创建的容器等。不过由于此目录一般都位于系统盘，遇到系统盘比较小，而镜像和容器多了后就容易尴尬</p>
</blockquote>
<p>解决方法：</p>
<p>(1)在命令行输入docker info查看docker的相关配置信息，其中Docker Root Dir条目就是储存目录</p>
<p>(2)官方文档的修改办法是编辑 &#x2F;etc&#x2F;docker&#x2F;daemon.json 文件，p.s.这个文件默认是没有的，需要创建一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>

<p>(3)写入以下内容，p.s.第一行是docker默认源的设定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://docker.m.daocloud.io&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(4)保存并退出daemon.json，然后重启 docker 服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>(5)再次查看docker info，可以看到默认储存路径已经修改</p>
<p><strong>3.docker容器中<code>TAB</code>无法补全</strong></p>
<p>(1)解决bash中命令无法补全的问题：</p>
<ol>
<li><p>安装bash-complete</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install -y bash-completion</span><br></pre></td></tr></table></figure>


</li>
<li><p>确认容器中使用的终端是否是bash，如果不是，则要改成bash。如果返回的是bash，则直接跳到第3步</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l /bin/sh 			<span class="comment"># 如果返回/bin/sh-&gt;dash，那么说明需要将其改成bash。</span></span><br><span class="line">dpkg-reconfigure dash 	<span class="comment"># 选择no</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使bash_completion生效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /usr/share/bash-completion/bash_completion <span class="comment"># 如果提示没有权限，使用chmod修改一下即可</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>去除<code>/etc/bash.bashrc</code>中的注释</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vi /etc/bash.bashrc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># enable bash completion in interactive shells</span></span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">shopt</span> -oq posix; <span class="keyword">then</span></span><br><span class="line"> <span class="keyword">if</span> [ -f /usr/share/bash-completion/bash_completion ]; <span class="keyword">then</span></span><br><span class="line">   . /usr/share/bash-completion/bash_completion</span><br><span class="line"> <span class="keyword">elif</span> [ -f /etc/bash_completion ]; <span class="keyword">then</span></span><br><span class="line">   . /etc/bash_completion</span><br><span class="line"> <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重启docker容器即可</p>
</li>
</ol>
<p>(2)解决<code>apt install &lt;包名&gt;</code>时，包名无法补全的问题</p>
<p>docker容器中有个<code>docker-clean</code>负责清除apt缓存以减小docker容器的容积，正因为此，包名才无法补全</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> /etc/apt/apt.conf.d/docker-clean</span><br><span class="line">apt update</span><br></pre></td></tr></table></figure>

<h5 id="4-2-docker的常用操作"><a href="#4-2-docker的常用操作" class="headerlink" title="4.2 docker的常用操作"></a>4.2 docker的常用操作</h5><h6 id="4-2-1-查看镜像、容器、数据卷所占用的空间"><a href="#4-2-1-查看镜像、容器、数据卷所占用的空间" class="headerlink" title="4.2.1 查看镜像、容器、数据卷所占用的空间"></a>4.2.1 查看镜像、容器、数据卷所占用的空间</h6><p><code>docker system df</code></p>
<h6 id="4-2-2-复制主机文件夹到docker容器"><a href="#4-2-2-复制主机文件夹到docker容器" class="headerlink" title="4.2.2 复制主机文件夹到docker容器"></a>4.2.2 复制主机文件夹到docker容器</h6><p>使用<code>docker cp</code>命令</p>
<p>语法：<code>docker cp &lt;本地文件夹路径&gt; &lt;容器名称或ID&gt;:&lt;容器目标路径&gt;</code></p>
<h5 id="4-3-镜像相关"><a href="#4-3-镜像相关" class="headerlink" title="4.3 镜像相关"></a>4.3 镜像相关</h5><h6 id="4-3-1-列出镜像"><a href="#4-3-1-列出镜像" class="headerlink" title="4.3.1 列出镜像"></a>4.3.1 列出镜像</h6><p><code>docker image ls -a</code>列出所有镜像</p>
<h6 id="4-3-2-加载本地镜像"><a href="#4-3-2-加载本地镜像" class="headerlink" title="4.3.2 加载本地镜像"></a>4.3.2 加载本地镜像</h6><p><code>docker load -i &quot;镜像名称&quot;</code></p>
<p><code>docker import &lt;镜像名称&gt; &lt;REPOSITORY:TAG&gt;</code>推荐</p>
<p><img src="/images/image-20230816154758363.png" alt="image-20230816154758363"></p>
<p><em>用户既可以使用 <code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</em></p>
<h6 id="4-3-3-删除镜像"><a href="#4-3-3-删除镜像" class="headerlink" title="4.3.3 删除镜像"></a>4.3.3 删除镜像</h6><p><code>docker image rm &lt;镜像id&gt;</code></p>
<p>p.s. 如果遇到镜像有子镜像<code>image has dependent child images</code>。</p>
<ol>
<li>先用<code>docker image inspect --format=&#39;&#123;&#123;.RepoTags&#125;&#125; &#123;&#123;.Id&#125;&#125; &#123;&#123;.Parent&#125;&#125;&#39; $(docker image ls -q --filter since=镜像Id)</code>查询镜像的依赖</li>
<li>然后逐层删除即可</li>
</ol>
<h5 id="4-4-容器相关"><a href="#4-4-容器相关" class="headerlink" title="4.4 容器相关"></a>4.4 容器相关</h5><h6 id="4-4-1-创建容器"><a href="#4-4-1-创建容器" class="headerlink" title="4.4.1 创建容器"></a>4.4.1 创建容器</h6><p>使用<code>docker run</code>来创建一个新容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name <span class="string">&quot;x9u_a&quot;</span> --network=host --privileged -w /home/hyh -v /home/hyh:/home/hyh -v /mnt:/mnt &lt;镜像ID&gt; /bin/bash</span><br><span class="line"><span class="comment"># 名词解释</span></span><br><span class="line">--name  			给容器取的名字</span><br><span class="line">-w 					&lt;path&gt; 容器启动后的工作路径</span><br><span class="line">-v 					主机路径:容器路径 将主机的路径挂载（共享）到容器的路径</span><br><span class="line">--privileged 		给容器赋予真正的root权限</span><br><span class="line">--network=host      容器内联网</span><br></pre></td></tr></table></figure>

<p><strong>补充知识：</strong></p>
<p>如果在x86架构下无法创建arm架构的容器的话，可以用QEMU来跨平台运行</p>
<p>①在 <a target="_blank" rel="noopener" href="https://github.com/multiarch/qemu-user-static/releases">https://github.com/multiarch/qemu-user-static/releases</a> 下载qemu-xxx-static文件，注意要根据自己平台选择，如arm64是qemu-aarch64-static，arm32是qemu-arm-static，选错文件后面的步骤会失败。</p>
<p>②拷贝文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> qemu-aarch64-static /usr/bin/</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> +x /usr/bin/qemu-aarch64-static</span><br></pre></td></tr></table></figure>

<p>③运行QEMU</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> --privileged multiarch/qemu-user-static:register</span><br></pre></td></tr></table></figure>

<p>④然后就可以用docker run&#x2F;restart来创建&#x2F;重启容器</p>
<h6 id="4-4-2-运行容器"><a href="#4-4-2-运行容器" class="headerlink" title="4.4.2 运行容器"></a>4.4.2 运行容器</h6><p>(1)查找容器的id</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ls -a</span><br></pre></td></tr></table></figure>

<p>(2)重启并运行容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker container restart &lt;容器id&gt;</span><br><span class="line">docker exec -it --user=root &quot;容器别名&quot; /bin/bash</span><br></pre></td></tr></table></figure>

<h6 id="4-4-3-容器导出容器快照"><a href="#4-4-3-容器导出容器快照" class="headerlink" title="4.4.3 容器导出容器快照"></a>4.4.3 容器导出容器快照</h6><p><code>docker container export &lt;容器id&gt; &gt; xxx.tar</code></p>
<h6 id="4-4-4-删除容器"><a href="#4-4-4-删除容器" class="headerlink" title="4.4.4 删除容器"></a>4.4.4 删除容器</h6><p><code>docker container rm &lt;容器id&gt;</code></p>
<h6 id="4-4-5-将容器保存为镜像"><a href="#4-4-5-将容器保存为镜像" class="headerlink" title="4.4.5 将容器保存为镜像"></a>4.4.5 将容器保存为镜像</h6><p>使用<code>docker commit</code>命令可以将容器的储存层+原有镜像保存为新的镜像，这个新镜像拥有原容器最后的文件的变化。</p>
<p>语法为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker commit --author &quot;HuYunhao&quot; --message &quot;J5 x9u a build image&quot; b36f55 x9u:a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--author 指定作者</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--message 记录本次修改的内容</span></span><br></pre></td></tr></table></figure>

<h5 id="4-5-Harbor云"><a href="#4-5-Harbor云" class="headerlink" title="4.5 Harbor云"></a>4.5 Harbor云</h5><h6 id="4-5-1-添加本地配置"><a href="#4-5-1-添加本地配置" class="headerlink" title="4.5.1 添加本地配置"></a>4.5.1 添加本地配置</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/docker/daemon.json        # 编辑docker配置文件</span><br></pre></td></tr></table></figure>

<p>在daemon.json文件中添加如下内容：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;insecure-registries&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;52.130.154.126:8098&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>保存后重启<code>docker</code>服务后生效</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker           # 重启docker服务</span><br></pre></td></tr></table></figure>

<h5 id="4-6-DockerFile"><a href="#4-6-DockerFile" class="headerlink" title="4.6 DockerFile"></a>4.6 DockerFile</h5><h6 id="4-6-1-运行DockerFile命令"><a href="#4-6-1-运行DockerFile命令" class="headerlink" title="4.6.1 运行DockerFile命令"></a>4.6.1 运行DockerFile命令</h6><p><code>docker build --network=host -t v140:v1 .</code></p>
<h4 id="5-vi"><a href="#5-vi" class="headerlink" title="5 vi"></a>5 vi</h4><h5 id="5-1-vi的三种模式"><a href="#5-1-vi的三种模式" class="headerlink" title="5.1 vi的三种模式"></a>5.1 vi的三种模式</h5><img src="images/image-20230925141712412.png" alt="image-20230925141712412" style="zoom:67%;" />

<h5 id="5-2-命令模式"><a href="#5-2-命令模式" class="headerlink" title="5.2 命令模式"></a>5.2 命令模式</h5><p>任何时候，不管用户处于何种模式，按下Esc键即可进入命令模式。按下<code>u</code>去撤销操作。</p>
<h6 id="5-2-1-光标移动"><a href="#5-2-1-光标移动" class="headerlink" title="5.2.1 光标移动"></a>5.2.1 光标移动</h6><p>上下左右移动：<code>方向键</code>。还可以先按下数字，再按方向键。比如<code>2</code>+<code>方向上</code>-&gt;向上移动两行</p>
<p>翻页：<code>Page Up</code>和<code>Page Down</code></p>
<p>移动至指定行：先输入行号如<code>234</code>，再按<code>shift</code>+<code>G</code></p>
<p>移动到本行行首：输入数字<code>0</code></p>
<p>移动到本行行末：<code>shift</code>+<code>4</code></p>
<p>移动到文件的最后一行：<code>shift</code>+<code>G</code></p>
<h6 id="5-2-2-插入行"><a href="#5-2-2-插入行" class="headerlink" title="5.2.2 插入行"></a>5.2.2 插入行</h6><p>向当前行上面插入一行：大写<code>O</code></p>
<p>向当前行下面插入一行：小写<code>o</code></p>
<p>同样的，可以先按数字，再按字母，插入多行。</p>
<h6 id="5-2-3-删除文本"><a href="#5-2-3-删除文本" class="headerlink" title="5.2.3 删除文本"></a>5.2.3 删除文本</h6><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">删除内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center">x</td>
<td align="center">当前字符</td>
</tr>
<tr>
<td align="center">3x</td>
<td align="center">当前字符和之后的两个字符</td>
</tr>
<tr>
<td align="center">dd</td>
<td align="center">当前行</td>
</tr>
<tr>
<td align="center">5dd</td>
<td align="center">当前行和之后的4行</td>
</tr>
<tr>
<td align="center">d$</td>
<td align="center">当前字符到当前行末尾</td>
</tr>
<tr>
<td align="center">d0</td>
<td align="center">当前字符到当前行开始</td>
</tr>
<tr>
<td align="center">dG</td>
<td align="center">当前行到文件末尾</td>
</tr>
<tr>
<td align="center">d20G</td>
<td align="center">当前行到文件第20行之间的行</td>
</tr>
</tbody></table>
<h6 id="5-2-4-剪切，复制，粘贴"><a href="#5-2-4-剪切，复制，粘贴" class="headerlink" title="5.2.4 剪切，复制，粘贴"></a>5.2.4 剪切，复制，粘贴</h6><p>剪切：其实d相关的命令不是删除文本，而是在“剪切”文本。</p>
<p>粘贴：使用<code>P</code>将内容复制到光标前，使用<code>p</code>将内容复制到光标后。</p>
<p>复制：字母<code>y</code>是来复制文本的，用法和d一致</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">复制内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center">yy</td>
<td align="center">当前行</td>
</tr>
<tr>
<td align="center">5yy</td>
<td align="center">当前行以及接下来的4行</td>
</tr>
<tr>
<td align="center">y$</td>
<td align="center">当前字符直到当前行末尾</td>
</tr>
<tr>
<td align="center">y0</td>
<td align="center">当前字符直到当前行开头</td>
</tr>
<tr>
<td align="center">yG</td>
<td align="center">当前行到文件末尾</td>
</tr>
<tr>
<td align="center">y20G</td>
<td align="center">当前行和文件第20行之间的内容</td>
</tr>
</tbody></table>
<h6 id="5-2-5-合并行"><a href="#5-2-5-合并行" class="headerlink" title="5.2.5 合并行"></a>5.2.5 合并行</h6><p>使用大写<code>J</code>来将此行和下一行合并。</p>
<h5 id="5-3-编辑模式"><a href="#5-3-编辑模式" class="headerlink" title="5.3 编辑模式"></a>5.3 编辑模式</h5><p>在命令模式下输入插入命令<code>i</code>、附加命令<code>a</code>等，即可进入编辑模式。</p>
<h5 id="5-4-末行模式"><a href="#5-4-末行模式" class="headerlink" title="5.4 末行模式"></a>5.4 末行模式</h5><p>在命令模式下输入<code>:</code>即可进入末行模式，然后输入相应指令即可。</p>
<p>显示行号：输入<code>set nu</code></p>
<h6 id="5-4-1-查找和替换"><a href="#5-4-1-查找和替换" class="headerlink" title="5.4.1 查找和替换"></a>5.4.1 查找和替换</h6><p>查找：在命令行模式下，使用<code>/</code>进入查找，输入需要查找的字符后，按<code>Enter</code>进入第一个匹配处，此时按下<code>n</code>可以查找后续的匹配字符。</p>
<p>替换：</p>
<p>文件的内容如下</p>
<p><img src="/images/image-20230925154348140.png" alt="image-20230925154348140"></p>
<p>想要替换3-5行的<code>Apple</code>为<code>apple</code>，输入命令<code>3,5s/Apple/apple/g</code>即可。</p>
<img src="images/image-20230925154523626.png" alt="image-20230925154523626" style="zoom: 80%;" />

<p>命令解析：</p>
<table>
<thead>
<tr>
<th align="center">组成</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">:</td>
<td align="center">末行模式开启</td>
</tr>
<tr>
<td align="center">3，5</td>
<td align="center">替换3-5行的内容。还可以用%，%意味着替换整个文本</td>
</tr>
<tr>
<td align="center">s</td>
<td align="center">代表的本次的操作是搜索并且替换</td>
</tr>
<tr>
<td align="center">&#x2F;Apple&#x2F;apple</td>
<td align="center">搜索的文本&#x2F;替换的文本</td>
</tr>
<tr>
<td align="center">g</td>
<td align="center">代指global，如果不加上g的话，那么只替换每一行中第一个符合要求的字符串</td>
</tr>
</tbody></table>
<h5 id="5-5-常见问题"><a href="#5-5-常见问题" class="headerlink" title="5.5 常见问题"></a>5.5 常见问题</h5><h6 id="5-5-1-vi编辑器卡死"><a href="#5-5-1-vi编辑器卡死" class="headerlink" title="5.5.1 vi编辑器卡死"></a>5.5.1 vi编辑器卡死</h6><p>我们在使用vi编辑器时，有时可能出现编辑器卡死的状态，不能输入，不能退出。其实这不是vi编辑器卡死，而是不小心把vi编辑器锁定了，编辑器处于假死状态，这时vi只是停止向终端输出而已。<br>原因是在windows下，总是会习惯性的按<code>Ctrl</code>+<code>S</code>来保存文件，但在用vi时，一按<code>ctrl</code>+<code>S</code>就会“卡死”，什么都动不了。要想退出这种状态，只需按<code>Ctrl</code>+ <code>Q</code> 即可恢复正常。</p>
<h5 id="6-Perf-火焰图"><a href="#6-Perf-火焰图" class="headerlink" title="6 Perf 火焰图"></a>6 Perf 火焰图</h5>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://longfei1995.github.io/2024/01/01/other_tools/wsl2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡云浩">
      <meta itemprop="description" content="记录生活，记录工作，记录学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="胡云浩的blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/01/other_tools/wsl2/" class="post-title-link" itemprop="url">WSL2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-01-01T00:00:00+08:00">2024-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-10 17:05:29" itemprop="dateModified" datetime="2025-04-10T17:05:29+08:00">2025-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WSL2/" itemprop="url" rel="index"><span itemprop="name">WSL2</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h4><h4 id="2-文件传输"><a href="#2-文件传输" class="headerlink" title="2. 文件传输"></a>2. 文件传输</h4><h5 id="2-1-windows如何访问wsl"><a href="#2-1-windows如何访问wsl" class="headerlink" title="2.1 windows如何访问wsl"></a>2.1 windows如何访问wsl</h5><p>方法1：直接在文件资源管理器里输入<code>\\wsl$</code>即可访问</p>
<p>方法2：通过vscode WSL插件访问</p>
<h5 id="2-2-wsl如何访问windows"><a href="#2-2-wsl如何访问windows" class="headerlink" title="2.2 wsl如何访问windows"></a>2.2 wsl如何访问windows</h5><p>windows下的各个盘都挂载在<code>/mnt</code>下，可以直接访问</p>
<h4 id="3-使用windows代理"><a href="#3-使用windows代理" class="headerlink" title="3. 使用windows代理"></a>3. 使用windows代理</h4><p>查看某个端口是否被占用：<code>netstat -ano | findstr :10888</code></p>
<p>使用端口转发：</p>
<ol>
<li>在 Windows PowerShell（管理员）中运行：</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface portproxy add v4tov4 listenaddress=<span class="number">0.0</span>.<span class="number">0.0</span> listenport=<span class="number">10888</span> connectaddress=<span class="number">127.0</span>.<span class="number">0.1</span> connectport=<span class="number">10808</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>修改wsl里面的<code>.bashrc</code>，记得运行一下程序proxy_on</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取 Windows 主机的 IP</span></span><br><span class="line">export WINDOWS_HOST=$(cat /etc/resolv.conf | grep nameserver | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">代理设置函数</span></span><br><span class="line">proxy_on() &#123;</span><br><span class="line">    export http_proxy=&quot;http://$&#123;WINDOWS_HOST&#125;:10888&quot;</span><br><span class="line">    export https_proxy=&quot;http://$&#123;WINDOWS_HOST&#125;:10888&quot;</span><br><span class="line">    export all_proxy=&quot;socks5://$&#123;WINDOWS_HOST&#125;:10888&quot;</span><br><span class="line">    echo &quot;代理已开启，Windows IP: $&#123;WINDOWS_HOST&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">proxy_off() &#123;</span><br><span class="line">    unset http_proxy</span><br><span class="line">    unset https_proxy</span><br><span class="line">    unset all_proxy</span><br><span class="line">    echo &quot;代理已关闭&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="4-常用命令"><a href="#4-常用命令" class="headerlink" title="4. 常用命令"></a>4. 常用命令</h4><h5 id="4-1-基本命令"><a href="#4-1-基本命令" class="headerlink" title="4.1 基本命令"></a>4.1 基本命令</h5><ul>
<li>在 PowerShell 中输入 <code>wsl</code> 直接进入默认的 Linux 发行版</li>
<li>查看wsl里所有已经安装的发行版 <code>wsl --list</code>或者<code>wsl -l</code></li>
<li>查看更详细的信息<code>wsl --list --verbose</code>或者<code>wsl -l -v</code></li>
<li>关闭wsl所有实例<code>wsl --shutdown</code></li>
<li>重启特定的实例<code>wsl -t Ubuntu</code></li>
</ul>
<h5 id="4-2-管理相关"><a href="#4-2-管理相关" class="headerlink" title="4.2 管理相关"></a>4.2 管理相关</h5><ul>
<li>设置默认的wsl的版本<code>wsl --set-default-version 2</code></li>
<li>设置默认的发行版<code>wsl --set-default Ubuntu</code></li>
<li>更新wsl<code>wsl --update</code></li>
<li>卸载发行版<code>wsl --unregister Ubuntu</code></li>
<li>查看<code>wsl</code>状态<code>wsl --status</code></li>
</ul>
<h5 id="4-3-导入导出发行版"><a href="#4-3-导入导出发行版" class="headerlink" title="4.3 导入导出发行版"></a>4.3 导入导出发行版</h5><ul>
<li>导出发行版为tar文件<code>wsl --export Ubuntu D:\backup\ubuntu.tar</code></li>
<li>导入<code>wsl --import Ubuntu D:\wsl D:\backup\ubuntu.tar</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://longfei1995.github.io/2024/01/01/other_tools/windows/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡云浩">
      <meta itemprop="description" content="记录生活，记录工作，记录学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="胡云浩的blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/01/other_tools/windows/" class="post-title-link" itemprop="url">Windows</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-01-01T00:00:00+08:00">2024-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-10 17:05:23" itemprop="dateModified" datetime="2025-04-10T17:05:23+08:00">2025-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Windows/" itemprop="url" rel="index"><span itemprop="name">Windows</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1-PowerShell常用命令"><a href="#1-PowerShell常用命令" class="headerlink" title="1. PowerShell常用命令"></a>1. PowerShell常用命令</h4><h5 id="1-执行-exe程序"><a href="#1-执行-exe程序" class="headerlink" title="1 执行.exe程序"></a>1 执行.exe程序</h5><p>在路径前要加一个<code>&amp;</code>符号</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="string">&quot;D:\Qt\Qt5.12.12\5.12.12\mingw73_64\bin\windeployqt.exe&quot;</span> TCP_server.exe</span><br></pre></td></tr></table></figure>

<h5 id="2-添加环境变量到PATH"><a href="#2-添加环境变量到PATH" class="headerlink" title="2 添加环境变量到PATH"></a>2 添加环境变量到PATH</h5><p>查看环境变量</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$Env:Path</span></span><br></pre></td></tr></table></figure>

<p>临时在powershell中添加环境变量</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$Env:PATH</span>=<span class="string">&quot;C:\msys64\mingw64\bin;D:\Qt\Qt5.12.12\5.12.12\mingw73_64\bin;<span class="variable">$Env:PATH</span>&quot;</span> </span><br></pre></td></tr></table></figure>

<h4 id="2-将msys2添加到右键打开终端"><a href="#2-将msys2添加到右键打开终端" class="headerlink" title="2. 将msys2添加到右键打开终端"></a>2. 将msys2添加到右键打开终端</h4><p>为了在Windows 10中添加MSYS2 MingW64到右键菜单，从而在任意目录下打开MSYS2 MingW64终端，你可以按照以下步骤操作：</p>
<ol>
<li><p>打开Windows的注册表编辑器（regedit.exe）。</p>
</li>
<li><p>导航到 <code>HKEY_CLASSES_ROOT\Directory\Background\shell</code>。</p>
</li>
<li><p>在 ‘shell’ 上右键选择新建 -&gt; 项（K）。</p>
</li>
<li><p>命名新建的项，比如“msys2”，并且把右侧的数据改名一下，注意，这个名字就是右键时显示的名字。</p>
<p>同时可以在新建项上新建字符串，添加一个图标<br><img src="/images/image-20240327110007423.png" alt="image-20240327110007423"></p>
</li>
<li><p>在刚新建的项上再建一个名为<code>Command的项</code>，如上图所示</p>
</li>
<li><p>修改<code>Command</code>项里的数据为<code>C:\msys64\msys2_shell.cmd -mingw64 -here</code><br><img src="/images/image-20240327105359708.png" alt="image-20240327105359708"></p>
<ul>
<li><p>-mingw64 代表着打开mingw64的终端。p.s. 其他值可以去它这个脚本里面看</p>
</li>
<li><p>-here 代表在当前目录打开终端r</p>
</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://longfei1995.github.io/2024/01/01/work_plan/daily_work/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡云浩">
      <meta itemprop="description" content="记录生活，记录工作，记录学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="胡云浩的blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/01/work_plan/daily_work/" class="post-title-link" itemprop="url">工作计划</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-01-01T00:00:00+08:00">2024-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-10 17:06:23" itemprop="dateModified" datetime="2025-04-10T17:06:23+08:00">2025-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E4%BD%9C%E8%AE%A1%E5%88%92/" itemprop="url" rel="index"><span itemprop="name">工作计划</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="工作计划"><a href="#工作计划" class="headerlink" title="工作计划"></a>工作计划</h3><h4 id="2023年"><a href="#2023年" class="headerlink" title="2023年"></a>2023年</h4><h5 id="202309"><a href="#202309" class="headerlink" title="202309"></a>202309</h5><p><em>20230912-周二</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 查看仿真平台的软件为什么不能plan complete，为什么规划出路径虚拟车辆没有走</li>
<li><input disabled="" type="checkbox"> 查看apa planning代码的A*部分</li>
<li><input checked="" disabled="" type="checkbox"> 完成与专利局交流的apa规划算法的ppt</li>
</ul>
<p><em>20230913-周三</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 查看apa planning算法</li>
<li><input disabled="" type="checkbox"> 查看apa planning算法的文档</li>
<li><input checked="" disabled="" type="checkbox"> 与决策、状态机一起实车初次联调</li>
</ul>
<p><em>20230914-周四</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 与握手、控制一起实车联调，打通下游链路</li>
</ul>
<p><em>20230918-周一</em></p>
<ul>
<li><input disabled="" type="checkbox"> 障碍物干涉之后往外推的逻辑</li>
<li><input checked="" disabled="" type="checkbox"> 联调解决实车时决策给的DRreset有问题、slot_origin_in_map、定位跳变的问题</li>
</ul>
<p><em>20230919-周二</em></p>
<ul>
<li><input disabled="" type="checkbox"> 障碍物干涉往外推的逻辑</li>
<li><input checked="" disabled="" type="checkbox"> 查看copy-assignment constructor的写法</li>
<li><input checked="" disabled="" type="checkbox"> 重新看三五原则</li>
<li><input checked="" disabled="" type="checkbox"> x9u实车调通的版本发版</li>
</ul>
<p><em>20230920-周三</em></p>
<ul>
<li><input disabled="" type="checkbox"> 障碍物干涉清空地图，并且重新前向，后向扫描</li>
<li><input disabled="" type="checkbox"> 02 module看完</li>
</ul>
<p><em>20230921-周四</em></p>
<ul>
<li><input disabled="" type="checkbox"> 搭建公司电脑的环境</li>
<li><input checked="" disabled="" type="checkbox"> adigo-builder会议</li>
</ul>
<p><em>20230922-周五</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 排查状态机与规划之间的通信问题</li>
<li><input checked="" disabled="" type="checkbox"> 和仿真平台交流，为什么他们斜列车位停得有问题，应该给怎样的数据</li>
</ul>
<h5 id="202310"><a href="#202310" class="headerlink" title="202310"></a>202310</h5><p><em>20231011-周三</em></p>
<ul>
<li><p><input checked="" disabled="" type="checkbox"> 
和决策室王垚查看规划过程中，控制没有跟上，撞障碍物点的问题</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
* 修改x9u run脚本，添加Log文件的时间戳<br>* 合并BUILD_IN_QNX BUILD_LINUX_SIZE_T等功能一致的宏<br>* base.cpp中#includecollision_detection.h，防止类定义缺失</p>
</li>
</ul>
<p><em>20231012-周四</em></p>
<ul>
<li><p><input disabled="" type="checkbox"> 
1012发版前的测试，验证</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
解决仿真室遇到的问题：</p>
<p>1.算法一直运行<br>2.当第一个场景运行完后，执行第二个场景时apa算法调不起来<br>3.原因是：第一个场景运行完后，算法一直在发Kover信号</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
回答专利科的提问</p>
</li>
</ul>
<p><em>20231013-周五</em></p>
<ul>
<li><p><input checked="" disabled="" type="checkbox"> 
计算规划发送给A02泊车显示界面的参数：挡位、规划总距离、剩余总距离、单次泊车行驶剩余距离</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
根据泊车界面的要求，重算给决策的当前步数，总步数</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
规划发给决策的路点由当前控制跟踪的那条路 -&gt; 发送整个plan_path给决策</p>
</li>
</ul>
<p><em>20231016-周一</em></p>
<ul>
<li><input disabled="" type="checkbox"> 看规划的代码</li>
<li><input checked="" disabled="" type="checkbox"> 看规划的文档</li>
</ul>
<p><em>20231017-周二</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> * 增加发送给决策的泊车界面显示的量<br>* 发送给控制的path_attribute名称的改变<br>* 订阅dr的topic name的改变</li>
<li><input checked="" disabled="" type="checkbox"> 处理JIRA 1个</li>
<li><input checked="" disabled="" type="checkbox"> 添加台架读取plan.yaml的仿真程序</li>
</ul>
<p><em>20231019-周四</em></p>
<ul>
<li><input disabled="" type="checkbox"> 查看3篇c++ 11的文章</li>
<li><input disabled="" type="checkbox"> 查看规划相关的代码&amp;文档</li>
<li><input checked="" disabled="" type="checkbox"> 配置Gerrit commit模板</li>
<li><input checked="" disabled="" type="checkbox"> x9u固定发路径的台架测试版本释放</li>
<li><input checked="" disabled="" type="checkbox"> 平行车位规划路径问题的排查</li>
</ul>
<p><em>20231020-周五</em></p>
<ul>
<li><input disabled="" type="checkbox"> 开发读取车型配置文件的yaml</li>
</ul>
<p><em>20231021-周六</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 排查014车规划和控制中间件周期的问题</li>
<li><input checked="" disabled="" type="checkbox"> 部署016车idl1.4.3,发现执行件不能控车</li>
</ul>
<p><em>20231023-周一</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> CICD仿真测试链路：提供Harbor镜像+Gerrit</li>
<li><input checked="" disabled="" type="checkbox"> JFrog集成发布artifact</li>
</ul>
<p><em>20231024-周二</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 修改base.h里面的车型参数，将其改为#define + 函数类型</li>
<li><input disabled="" type="checkbox"> 实车排查plan over不能成功置位，定位到dr 的veh_dir</li>
</ul>
<p><em>20231025-周三</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 修复replay.yaml都记录在同一个文件的bug</li>
<li><input checked="" disabled="" type="checkbox"> 修复发给decision num不自增的bug</li>
</ul>
<p><em>20231026-周四</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 查看vs code windows下不能build的原因，并且解决</li>
<li><input disabled="" type="checkbox"> 查看如何将shell脚本的变量传递给cmakelist.txt</li>
<li><input disabled="" type="checkbox"> 解决编译平台的问题</li>
</ul>
<p><em>20231027-周五</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 解决adigo_build编译平台的问题</li>
</ul>
<p><em>20231030-周一</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 试用codegeex和华为的代码ai</li>
<li><input checked="" disabled="" type="checkbox"> 下载最新的clion，因为有license</li>
</ul>
<p><em>20231031-周二</em></p>
<ul>
<li><input disabled="" type="checkbox"> 确定车辆脱困的开发流程，修改完已经有的地图。</li>
<li><input disabled="" type="checkbox"> deleteObs()前确定是否更新map</li>
</ul>
<h5 id="202311"><a href="#202311" class="headerlink" title="202311"></a>202311</h5><p><em>20231101-周三</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 修改stop_dist，rm_path_len等的单位为cm</li>
</ul>
<p><em>20231107-周二</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> printDebug切换成GACLOG</li>
<li><input disabled="" type="checkbox"> 完成仿真平台调研.md</li>
</ul>
<p><em>20231108-周三</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 解决名下的4个jira</li>
<li><input disabled="" type="checkbox"> 汇总A02的所有和规划相关的JIRA问题</li>
</ul>
<p><em>20231109-周四</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 完成仿真平台的安装、试用、试用报告</li>
<li><input disabled="" type="checkbox"> 开发避撞脱困的算法</li>
</ul>
<p><em>20231110-周五</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 脱困算法前期准备</li>
</ul>
<p><em>20231113-周一</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 完成各个轮廓圆与栅格点是否碰撞的template函数</li>
<li><input checked="" disabled="" type="checkbox"> 完成各个轮廓圆与障碍物线段是否碰撞的template函数</li>
</ul>
<p><em>20231114-周二</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 完成圆内障碍物的清除</li>
<li><input disabled="" type="checkbox"> 将障碍物外推至高障碍物线段</li>
<li><input checked="" disabled="" type="checkbox"> 和系统科讨论apa_plan单模块性能的提升方案，和仿真场景库，评价指标等</li>
</ul>
<p><em>20231115-周三</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 将障碍物外推至高障碍物线段</li>
<li><input checked="" disabled="" type="checkbox"> 完成JIRA问题的测试</li>
</ul>
<p><em>20231116-周四</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 查看为什么deleteObs()没有成功，并且解决此问题，完成交付</li>
<li><input disabled="" type="checkbox"> 通过此次开发，深入查看代码的结构</li>
</ul>
<p><em>20231117-周五</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 添加新的成员，real_grid_map和real_tiny_grid_map</li>
<li><input checked="" disabled="" type="checkbox"> 添加新的成员，real_high_obs_segs</li>
<li><input checked="" disabled="" type="checkbox"> 原有的replay.yaml里面，仍然只记录之前的内容</li>
</ul>
<p><em>20231120-周一</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 查看两篇C++的特性</li>
<li><input disabled="" type="checkbox"> 用gdb查看规划的整个流程</li>
<li><input checked="" disabled="" type="checkbox"> 开调度平台的会议</li>
</ul>
<p><em>20231121-周二</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 添加按”R”键，将当前的plan.yaml的车位，地图等反转。并记录到plan_reflect.yaml里</li>
<li><input checked="" disabled="" type="checkbox"> 适配idl1.5</li>
</ul>
<p><em>20231122-周三</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 添加is future bump未来三米的逻辑</li>
<li><input checked="" disabled="" type="checkbox"> apa规划质量仿真会启动会</li>
</ul>
<p><em>20231127-周一</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 验证is future bump未来三米的逻辑</li>
</ul>
<p><em>20231128-周二</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 验证is future bump未来三米的逻辑</li>
<li><input checked="" disabled="" type="checkbox"> 修改path_index之类的无果</li>
</ul>
<p><em>20231129-周三</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 在updateMaps里面，将grid map赋值给real grid map后生效，因为碰撞检测用的是real grid map</li>
<li><input checked="" disabled="" type="checkbox"> 有一个新问题，栅格点不准，导致还是会撞水马，考虑多裁剪一点路径</li>
</ul>
<p><em>20231130-周四</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 根据平台的要求，添加version.sh </li>
<li><input checked="" disabled="" type="checkbox"> 根据项目组的要求，订阅process state信号，pub 诊断信号和心跳信号</li>
<li><input checked="" disabled="" type="checkbox"> 修改gaclog最大储存文件数为10，储存大小为10mb</li>
<li><input disabled="" type="checkbox"> 验证裁剪之后的路径，是不是还是碰撞</li>
</ul>
<h5 id="202312"><a href="#202312" class="headerlink" title="202312"></a>202312</h5><p><em>20231205-周二</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 将探测长度和裁剪长度写成配置文件，便于调试</li>
<li><input disabled="" type="checkbox"> 查看3个JIRA路径失效 &amp;&amp; plan fail的原因</li>
</ul>
<p><em>20231206-周三</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 开发避撞函数，查询某个点的最近障碍物的距离</li>
<li><input disabled="" type="checkbox"> 修复is future bump中的检测方法，只检测当前的路径</li>
</ul>
<p><em>20231207-周四</em></p>
<ul>
<li><input disabled="" type="checkbox"> 试一下adigo-bag怎么使用</li>
<li><input checked="" disabled="" type="checkbox"> 动态避撞现在只判断当前跟踪的路径</li>
<li><input checked="" disabled="" type="checkbox"> 动态避撞的探测范围（3.0m）和截断距离（0.2m）仍可从config&#x2F;setting.yaml中修改</li>
<li><input checked="" disabled="" type="checkbox"> 动态避撞在截短路径后，还是会持续检测截短后的路径，如有必要，会继续截短路径</li>
<li><input checked="" disabled="" type="checkbox"> 给仿真发送新的实车场景</li>
</ul>
<p><em>20231208-周五</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 查看仿真张隆给的仿真测试报告</li>
<li><input checked="" disabled="" type="checkbox"> 去掉ctrl error replan的条件中，veh_dir &#x3D;&#x3D; 0的条件</li>
<li><input disabled="" type="checkbox"> 修改避撞重规划的条件，不再去判断ctrl_end_ok</li>
</ul>
<p><em>20231211-周一</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 填写年度绩效</li>
<li><input checked="" disabled="" type="checkbox"> 修改ctrl error replan中的横纵向误差的计算方式</li>
<li><input checked="" disabled="" type="checkbox"> 解决jira问题+1</li>
</ul>
<p><em>20231212-周二</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 修改休眠方式为真休眠</li>
<li><input checked="" disabled="" type="checkbox"> 查看调度框架的使用</li>
<li><input checked="" disabled="" type="checkbox"> 查看printDebug的打印为何如此频繁</li>
<li><input checked="" disabled="" type="checkbox"> 修改version.sh -&gt; ChangeLog.txt</li>
</ul>
<p><em>20231213-周三</em></p>
<ul>
<li><input disabled="" type="checkbox"> 适配调度框架</li>
<li><input checked="" disabled="" type="checkbox"> 解决APILOT-1953 APILOT-1960 APILOT-1957 APILOT-1950 APILOT-1949</li>
<li><input checked="" disabled="" type="checkbox"> 查看printDebug为啥时间错乱，查看规划周期是否稳定</li>
<li><input checked="" disabled="" type="checkbox"> 解决isFutureBump() core dump的问题</li>
</ul>
<p><em>20231214-周四</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 修改communication的通信协议PROTOCOL_ZMQ_TCP-&gt;PROTOCOL_HYBRID</li>
</ul>
<p><em>20231215-周五</em></p>
<ul>
<li><input disabled="" type="checkbox"> 适配调度框架</li>
<li><input checked="" disabled="" type="checkbox"> 解决JIRA 3个问题</li>
</ul>
<p><em>20231218-周一</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 分离调度框架和communication的逻辑</li>
<li><input checked="" disabled="" type="checkbox"> 修改config.yaml，以便CI编译可以通过</li>
</ul>
<p><em>20231219-周二</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> docker容器中加入调度框架的sdk，并且制成镜像</li>
<li><input disabled="" type="checkbox"> 思考如何将现有逻辑加入调度框架</li>
<li><input checked="" disabled="" type="checkbox"> 排查车辆跑飞的问题，查到是因为规划给控制的plan_path_id有误</li>
</ul>
<p><em>20231220-周三</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 基于数据集的APA仿真开发的指标评价方案，场景搭建方案评审</li>
<li><input checked="" disabled="" type="checkbox"> 解决动态规划失败后，车辆卡住的问题，是因为此时plan_path_id发给控制的值是0</li>
<li><input checked="" disabled="" type="checkbox"> 发版前的build.yaml，config.yaml的修改</li>
</ul>
<p><em>20231221-周四</em></p>
<ul>
<li><input disabled="" type="checkbox"> 调度框架初版发布</li>
<li><input checked="" disabled="" type="checkbox"> 查看调度框架自动代码生成表格的填写规范</li>
<li><input checked="" disabled="" type="checkbox"> 走通由调度框架excel-&gt;代码</li>
<li><input checked="" disabled="" type="checkbox"> 修改windows端的为clash机场</li>
</ul>
<p><em>20231225-周一</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 使用GDB查看规划主流程</li>
<li><input checked="" disabled="" type="checkbox"> 查看规划相关的文档</li>
</ul>
<p><em>20231226-周二</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 适配平台最新的sdkv1.2.0，制作docker镜像</li>
<li><input checked="" disabled="" type="checkbox"> 解决JIRA 5个</li>
</ul>
<p><em>20231227-周三</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 重新修改excel的结构，重新生成调度框架的代码架构</li>
<li><input checked="" disabled="" type="checkbox"> 下午和梓龙一起测试动态避撞相关的内容</li>
</ul>
<p><em>20231228-周四</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 修改dynamic_bump中detect_path等的命名，同步更改config&#x2F;setting.yaml中的命名</li>
<li><input checked="" disabled="" type="checkbox"> 更新x9u和x86的gaclog的头文件</li>
<li><input checked="" disabled="" type="checkbox"> 排查决策AVM不显示的问题，因为std::vector<uint_8>长度越界的问题</li>
</ul>
<h4 id="2024年"><a href="#2024年" class="headerlink" title="2024年"></a>2024年</h4><h5 id="202401"><a href="#202401" class="headerlink" title="202401"></a>202401</h5><p><em>20240102-周二</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> chatgpt和仿真的年终总结填写</li>
<li><input checked="" disabled="" type="checkbox"> 解决挂名下的JIRA</li>
<li><input disabled="" type="checkbox"> 排查程序奔溃的问题</li>
</ul>
<p><em>20240103-周三</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 基于数据集的APA仿真</li>
<li><input checked="" disabled="" type="checkbox"> 基于VS code修改调度框架的工程</li>
</ul>
<p><em>20240104-周四</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 完成调度框架的开发</li>
<li><input checked="" disabled="" type="checkbox"> 解决仿真的JIRA问题 &amp;&amp; 和仿真的人讨论他们的碰撞检测是如何做的</li>
<li><input checked="" disabled="" type="checkbox"> 告诉仿真该如何发车位角度</li>
</ul>
<p><em>20240105-周五</em></p>
<ul>
<li><p><input checked="" disabled="" type="checkbox"> 
开发限速模块：</p>
</li>
<li><p>将enum DirType挪到bash.h</p>
</li>
<li><p>完善doc&#x2F;collision*.md，在图上添加圆的索引</p>
</li>
<li><p>增加：getNearObsDisForSpdLimit(const Pose3f&amp; veh_pos, const DirType&amp; dir_type)查询指定车辆行驶方向的圆</p>
</li>
<li><p>增加：getNearObsDis(const Pose3f&amp; veh_pos, const std::vector<Circle4f>&amp; circles) 查询特定区域的圆</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
修改轮廓圆和障碍物地图，障碍物地图在前后项扫描的时候就输出距离，轮廓圆与safe_dist解耦</p>
</li>
<li><p>先修改障碍物距离地图，包括相关的注释</p>
</li>
<li><p>修改轮廓圆和safe dist耦合的部分</p>
</li>
</ul>
<p><em>20240106-周六</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 处理吴院试驾的版本，被动挡轮杆的问题</li>
</ul>
<p><em>20240108-周一</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 开发QPlaner删除障碍物的功能</li>
<li><input checked="" disabled="" type="checkbox"> 处理JIRA问题</li>
<li><input checked="" disabled="" type="checkbox"> 出现多个提前plan over的问题，排查是终点更新提前 || DR给的位置已经到终点</li>
<li><input checked="" disabled="" type="checkbox"> 完成泊车组工作周报的填写</li>
</ul>
<p><em>20240109-周二</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 修改drawGrid()函数</li>
<li><input checked="" disabled="" type="checkbox"> 开发QPlanPlayer的tools工具箱</li>
</ul>
<p><em>20240110-周三</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 限速模块的测试</li>
<li><input checked="" disabled="" type="checkbox"> 修改real_time_plan.cpp中isBump() &#x3D;&#x3D; true的bug</li>
<li><input checked="" disabled="" type="checkbox"> 去除idl_node.cpp中的避撞等待控制换挡的功能</li>
<li><input checked="" disabled="" type="checkbox"> 版本火车发版测试</li>
<li><input checked="" disabled="" type="checkbox"> 避撞模块的评审</li>
</ul>
<p><em>20240111-周四</em></p>
<ul>
<li><p><input checked="" disabled="" type="checkbox"> 
适配idl 1.6</p>
<ol>
<li>data attribute不再分发chassis_state和uss_perception。重新从Comm idl里面去订阅</li>
<li>发布给决策的数据reserved从uint8-&gt;uint16</li>
</ol>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
修复drawGrid() x9u编译报错的bug</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
生成动态避撞的场景 &amp;&amp; gif</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
查找deleteObs()不生效的原因</p>
</li>
</ul>
<p><em>20240112周五</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 修改限速模块的参数， 亚运城&amp;&amp;小镇标定限速模块的参数</li>
<li><input disabled="" type="checkbox"> 查找规划core dump的问题</li>
</ul>
<p><em>20240115周一</em></p>
<ul>
<li><p><input checked="" disabled="" type="checkbox"> 
解决周末测试的JIRA</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
idl1.6发版</p>
</li>
<li><p><input disabled="" type="checkbox"> 
调度框架初步测试</p>
</li>
</ul>
<p><em>20240116周二</em></p>
<ul>
<li><p><input disabled="" type="checkbox"> 
修改高低障碍物线段std::vector&lt;std::vector&lt;&gt;&gt; -&gt; std::vector&lt;&gt;<br>* 修改障碍物线段插值函数<br>* 修改高低障碍物碰撞判断函数</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
更新平台的communication.json。避免中间件挂掉</p>
</li>
</ul>
<p><em>20240117-周三</em></p>
<ul>
<li><p><input checked="" disabled="" type="checkbox"> 
根据仿真室的要求，切换CI编译为项目线CI。新增x86下的build.yaml。修改config.yaml</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
isBump（）函数的逻辑调整</p>
<ul>
<li>先检测前&#x2F;后 大圆，如果碰撞了，再按顺序检测大圆内的小圆</li>
<li>再检测所有后视镜圆</li>
<li>再检测所有中圆</li>
<li>再检测高障碍物线段</li>
<li>再检测低障碍物线段</li>
<li>调整低障碍物线段中间圆的位置，调整到核心区域正中</li>
<li>低障碍物圆和后视镜一样，不再额外加上安全距离进行判断</li>
</ul>
</li>
</ul>
<p><em>20240118-周四</em></p>
<ul>
<li><p><input checked="" disabled="" type="checkbox"> 
开发getNearObsDis()函数</p>
<ul>
<li>用getNearHighObsDis(const Circle&amp;)获取轮廓圆与高障碍类型点的距离</li>
<li>用getNearLowObsDis(const Circle&amp;)获取轮廓圆与低障碍物类型点的距离</li>
<li>统一getNearObsDisForSpdLimit()的风格</li>
</ul>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
处理JIRA问题</p>
</li>
</ul>
<p><em>20240119-周五</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 添加virtual_obs_segs<ul>
<li>ParkData中添加virtual_obs_segs，并且在init()中初始化</li>
<li>ParkType中添加kTightTailIn &#x3D; 7</li>
<li>如果park_data有virtual_obs_segs，那么在free_space.updateMap()中插值，并且更新到park_data.real_grid_map</li>
</ul>
</li>
</ul>
<p><em>20240122-周一</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> setting.yaml中加入螺旋线速度相关的参数 &amp;&amp; 程序里也加相应的逻辑</li>
</ul>
<p><em>20240123-周二</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 查看udp通信时阻塞的问题，重写upd通信这一块的代码</li>
</ul>
<p><em>20240124-周三</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 更新发版的changlog.txt</li>
<li><input checked="" disabled="" type="checkbox"> 解决JIRA问题</li>
</ul>
<p><em>20240125-周四</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 写完windows下UDP通信封装<code>UDPSocket</code></li>
</ul>
<p><em>20240126-周五</em></p>
<ul>
<li><input disabled="" type="checkbox"> 写完linux下的UDP通信的封装</li>
<li><input checked="" disabled="" type="checkbox"> 解决车辆限速的问题，调整车辆的速度</li>
</ul>
<p>*20240129-周一</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 修复isBump()和getNearObsDis()相互冲突的问题</li>
<li><input checked="" disabled="" type="checkbox"> 查找path_gear()core dump的原因</li>
<li><input checked="" disabled="" type="checkbox"> * deleteObs()添加清除后视镜里的栅格点<ul>
<li>仿照clearGridInCircle()新建clearLowObsInCircle()，用于清除与低障碍物圆干涉的低障碍物线段</li>
</ul>
</li>
</ul>
<h5 id="202402"><a href="#202402" class="headerlink" title="202402"></a>202402</h5><p><em>20240201-周四</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 解决getNearObsDist受isBump影响的问题</li>
<li><input checked="" disabled="" type="checkbox"> 解决没有pub_msg.clear()导致决策&amp;&amp;状态机core dump的问题</li>
<li><input checked="" disabled="" type="checkbox"> 解决bash.cpp 速度规划时，plan_path.back()越界，导致的core dump问题</li>
</ul>
<p><em>20240202-周五</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 查看setting.yaml不生效的问题</li>
<li><input checked="" disabled="" type="checkbox"> 排查JIRA问题</li>
</ul>
<p><em>20240204-周日</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 查找碰撞圆设计中，大圆无法覆盖小圆的问题 &amp;&amp; 解决，将前后大圆半径+0.1m</li>
<li><input checked="" disabled="" type="checkbox"> QPlan工具test harness &amp;&amp; benchmark</li>
</ul>
<p><em>20240220-周二</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 解决jira APOUTER-146 APILOT-2775</li>
<li><input disabled="" type="checkbox"> 写文档，“当前仿真平台和QPlanPlayer相比，需要做什么工作”<ol>
<li>当前仿真平台有哪些方面不太完善的</li>
<li>QPlanPlayer能做哪些方面的仿真</li>
<li>提需求</li>
</ol>
</li>
</ul>
<p><em>20240222-周四</em></p>
<ul>
<li><p><input checked="" disabled="" type="checkbox"> 
完成pushObs()函数</p>
<ul>
<li>collision.h中添加delete_low_obs_sets,delete_high_obs_sets成员，用于储存障碍物与车身轮廓相干涉的点<br>* 新增clearHighObsInCircle()用于清除高障碍物线段与车的干涉部分<br>* 新增pushObs()用于处理delete_low&#x2F;high_obs_sets_<br>* 新增Collision::rotateCircle()用于对轮廓圆的旋转平移<br>* 更新noter.cpp</li>
</ul>
</li>
</ul>
<p><em>20240223-周五</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 解决APILOT-2855 2869 2865等JIRA</li>
<li><input checked="" disabled="" type="checkbox"> 看书时间：effective c++</li>
</ul>
<p><em>20240226-周一</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 使用DockerFile构建plat form 1.3.0的镜像，便于维护和缩小docker image的容积</li>
</ul>
<p><em>20240227-周二</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 适配comunication v1.3.0<ul>
<li>*Type_Support的命名空间不再有::protobuf，代码中做相应的命名空间修改</li>
<li>*Type_Support::MsgType 后缀中加上了Bolemsg，代码中做相应的修改</li>
<li>*Type_Support中的clear()函数更名为Clear()，代码中做相应的修改</li>
<li>*Type_Support中path_attritube()函数以前返回类成员的指针，现在返回const&amp;，代码中做相应的修改</li>
<li>x9u&#x2F;build.sh &amp;&amp; CMakeList.txt 切换到v1.3.0</li>
</ul>
</li>
</ul>
<p><em>20240228-周三</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 适配idl 1.8</li>
</ul>
<p><em>20240229</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 调度框架修改excel，重新改善调度框架的逻辑</li>
<li><input checked="" disabled="" type="checkbox"> 调度框架适配idl1.8 &amp;&amp; sdk1.3.0<ul>
<li>先重新从execel生成代码</li>
<li>将已有的代码替换进去</li>
<li>更新CMakeList.txt等为1.3.0</li>
<li>再统一更新一下算法</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> 解决JIRA，记得看<a target="_blank" rel="noopener" href="http://139.159.231.223:8088/browse/APILOT-2222">APILOT-2222</a>的结论（HMI轨迹线闪烁）</li>
<li><input disabled="" type="checkbox"> 记得看<a target="_blank" rel="noopener" href="http://139.159.231.223:8088/browse/APILOT-2910">APILOT-2910</a>的结论（避撞时未摆正车身）</li>
</ul>
<h5 id="202403"><a href="#202403" class="headerlink" title="202403"></a>202403</h5><p><em>20240304</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 甩头专项汇报文档</li>
<li><input checked="" disabled="" type="checkbox"> 根据专利局的答复，重绘专利文档里面的图片的格式</li>
</ul>
<p><em>20240305</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 每次写replay.yaml时都写一次version.yaml &amp;&amp;<br>调度框架中printDebug()也使用getString()简化输出</li>
</ul>
<p><em>20240306</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 将心跳和诊断放到另一个线程里 </li>
<li><input checked="" disabled="" type="checkbox"> 将心跳和诊断修改为100ms</li>
</ul>
<p><em>20240307</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> JIRA迁移前解决所有珠峰计划名下的JIRA</li>
<li><input checked="" disabled="" type="checkbox"> plan.cpp中存储数据，然后用python matplotlib画出来</li>
</ul>
<p><em>20240311</em></p>
<ul>
<li><input disabled="" type="checkbox"> 写完飞书文档《规控室C++单元测试流程》</li>
</ul>
<p><em>20240312</em></p>
<ul>
<li><p><input checked="" disabled="" type="checkbox"> 
core dump分析</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
泊出调试</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
isFuturePathBump 变成立即重规划</p>
<p>* replan_type 增加: 未来车辆位置碰撞<br>* 规划更新类型: 新增: 未来车辆位置碰撞，请求刹停后重规划<br>* 规划更新类型: 更新: 未来路径碰撞，立即重规划</p>
</li>
</ul>
<p><em>20240313</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 动态规划时采用预测位置作为规划起点</li>
</ul>
<p><em>20240320</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 机械车位修改一下终点的位置</li>
<li><input disabled="" type="checkbox"> 和感知联调库内障碍物</li>
</ul>
<p><em>20240321</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> APOUTER-1750 评论已更新，对于低障碍物点，不执行 pushObs 而是直接删除</li>
<li><input disabled="" type="checkbox"> APOUTER-1924 观看一下这个评论</li>
</ul>
<p><em>20240322</em></p>
<ul>
<li><p><input disabled="" type="checkbox"> 
车辆无法移动相关的JIRA：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://139.159.231.223:8088/browse/APOUTER-1967">APOUTER-1967</a> </li>
<li><a target="_blank" rel="noopener" href="http://139.159.231.223:8088/browse/APOUTER-1955">APOUTER-1955</a></li>
<li><a target="_blank" rel="noopener" href="http://139.159.231.223:8088/browse/APOUTER-1928">APOUTER-1928</a></li>
<li><a target="_blank" rel="noopener" href="http://139.159.231.223:8088/browse/APOUTER-2039">APOUTER-2039</a></li>
</ul>
</li>
<li><p><input disabled="" type="checkbox"> 
同步计算上一次曲率 &amp;&amp; park_data_.curv &#x3D; park_data_rx.curv到调度框架</p>
</li>
</ul>
<p><em>20240323</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 查看JIRA</li>
<li><input checked="" disabled="" type="checkbox"> 对标M9</li>
<li><input checked="" disabled="" type="checkbox"> 查看此JIRA评论APOUTER-2029</li>
</ul>
<p><em>20240325</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 调度框架无法完整泊车的排查，原因是平台的启动脚本有问题，已经修改</li>
<li><input disabled="" type="checkbox"> 查看此JIRA评论APOUTER-2088，规划路径不合理</li>
<li><input checked="" disabled="" type="checkbox"> 机械车位测试 &amp;&amp; 问题排查</li>
</ul>
<p><em>20240326</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 查看车辆无法移动 &amp;&amp; 规划路径不合理的JIRA</li>
<li><input checked="" disabled="" type="checkbox"> 发版前的测试</li>
<li><input checked="" disabled="" type="checkbox"> reset id a9205991</li>
</ul>
<p><em>20240328</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 更新communication和调度框架的gaclog版本为1.1.2</li>
<li><input checked="" disabled="" type="checkbox"> 更新communication和调度框架的sdk 1.3.0 -&gt; 1.3.1</li>
</ul>
<h5 id="202404"><a href="#202404" class="headerlink" title="202404"></a>202404</h5><p><em>20240408</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 查看水平空间受限等14个JIRA</li>
<li><input disabled="" type="checkbox"> 行人避让策略的开发</li>
</ul>
<p><em>20240410</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> CollisionDetection::pushObs: 轮廓圆膨胀 0.2 &#x3D;&gt; 0.12, 解决pushObs()函数内的一个bug</li>
<li><input checked="" disabled="" type="checkbox"> 查看水平车位受限的原因</li>
</ul>
<p><em>20240418</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 水平 &amp;&amp; 斜列库内障碍物更新</li>
<li><input checked="" disabled="" type="checkbox"> 解决JIRA问题</li>
<li><input checked="" disabled="" type="checkbox"> 火焰图工具输出</li>
</ul>
<p><em>20240422</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 设置一个缓存队列，同时储存replan_flag &amp;&amp; veh_goal_pos。现在决策发replan flag只发一帧，如果此时规划正处于主流程中，回调中的这个replan_flag可能会被忽略掉。导致即使veh_goal_pos更新了，但是replan_flag &#x3D;&#x3D; 0。如果过程中没有其他重规划的话，只会在zero_remain_replan时使用新终点，此时plan over的阈值可能会覆盖新终点的更新，导致车头突出之类的问题。</li>
<li><input checked="" disabled="" type="checkbox"> 解决JIRA问题7个</li>
<li><input checked="" disabled="" type="checkbox"> 修改水平单侧腾挪障碍物的阈值 &amp;&amp; 限制</li>
</ul>
<p><em>20240423</em></p>
<ul>
<li><input disabled="" type="checkbox"> 动态障碍物策略</li>
</ul>
<h5 id="202405"><a href="#202405" class="headerlink" title="202405"></a>202405</h5><p><em>20240513</em></p>
<ul>
<li><input disabled="" type="checkbox"> 终点腾挪增加一个探测点，保证场景识别准确</li>
<li><input checked="" disabled="" type="checkbox"> 查看APOUTER-3608，移动障碍物策略</li>
<li><input disabled="" type="checkbox"> 查看APOUTER-3864</li>
</ul>
<p><em>20240520</em></p>
<ul>
<li><input disabled="" type="checkbox"> 4155  规划出来的路径新路径isFuturePosBump()检查中veh_curr_pos不通过，会触发kFuturePosReplan。RePlan后的新路径又会veh_curr_pos不通过。如此往复，直到超时车辆无法移动</li>
<li><input disabled="" type="checkbox"> 4160 规划出来的路径很奇怪，有三段路径，但是每段路径只有两个点，而且规划路径离终点很远</li>
</ul>
<p><em>20240521</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 参数部分已经完成 veh_param* config&#x2F;setting.yaml</li>
<li><input checked="" disabled="" type="checkbox"> updateParkData完成，新设计的updateParkData无论规划是否被更新都会被调用</li>
</ul>
<p><em>20240522</em></p>
<ul>
<li><p><input checked="" disabled="" type="checkbox"> 
4183和4219 可以在台架播包看一下情况，车辆无法移动的case</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
完成getNearDynamicObsDist(veh_pos, dir_type, vector<DynamicObs> dynamic_obs_list)<br>getDynamicObsDist(veh_pos, dir_type, dynamic_obs) </p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
checkDynamicObs(dynamic_obs_list)</p>
</li>
</ul>
<h5 id="202406"><a href="#202406" class="headerlink" title="202406"></a>202406</h5><p><em>20240620</em></p>
<ul>
<li><input disabled="" type="checkbox"> 适配idl2.4.1，屏蔽generated的内容</li>
</ul>
<h5 id="202408"><a href="#202408" class="headerlink" title="202408"></a>202408</h5><p><em>20240812</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 完成sdk1.8.1的适配</li>
<li><input disabled="" type="checkbox"> 播包回放feature分支，debug</li>
<li><input checked="" disabled="" type="checkbox"> 解决名下jira问题</li>
<li><input disabled="" type="checkbox"> em planner查看</li>
</ul>
<h5 id="202410"><a href="#202410" class="headerlink" title="202410"></a>202410</h5><p><em>20241014</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 完成cursor的适配和体验</li>
<li><input checked="" disabled="" type="checkbox"> 用cursor看apollo的代码，对照讲解看</li>
</ul>
<p><em>20241021</em></p>
<ul>
<li><input disabled="" type="checkbox"> 查看时空联合论文spatio-temporal joint planning method</li>
<li><input checked="" disabled="" type="checkbox"> 排查莫名截停的问题</li>
</ul>
<h5 id="202412"><a href="#202412" class="headerlink" title="202412"></a>202412</h5><p><em>20241202</em></p>
<ul>
<li><input disabled="" type="checkbox"> 实现时空联合论文spatio-temporal 的算法部分，并且在可视化展示出来</li>
<li><input checked="" disabled="" type="checkbox"> 查看epsilon论文</li>
</ul>
<p><em>20241203</em></p>
<ul>
<li><input disabled="" type="checkbox"> 继续昨天的工作，今天看完这篇论文</li>
<li><input disabled="" type="checkbox"> 查看Hello算法第4章，数组与链表。先速读，不要精读。</li>
<li><input checked="" disabled="" type="checkbox"> 被JIRA困住，回了一天JIRA</li>
</ul>
<p><em>20241204</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 查看Hello算法第4章，数组与链表。先速读，不要精读。</li>
</ul>
<p><em>20241205</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 上午安装并体验了nuplan数据集</li>
</ul>
<p><em>20241206</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 修改了碰撞时也尝试使用历史路径</li>
<li><input checked="" disabled="" type="checkbox"> getPathCost()增加螺旋线和dcurv的惩罚</li>
<li><input checked="" disabled="" type="checkbox"> 新增菱形场景判断</li>
</ul>
<p><em>20241210</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 成功的基于nuplan数据集实现简单的CV预测模型</li>
</ul>
<p><em>20241211</em></p>
<ul>
<li><input disabled="" type="checkbox"> 查看其他预测模型</li>
<li><input checked="" disabled="" type="checkbox"> 被JIRA拖住</li>
</ul>
<p><em>20241212</em></p>
<ul>
<li><p><input checked="" disabled="" type="checkbox"> 
查看第二章其他预测模型</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
今日论文：End-to-end Autonomous Driving:Challenges and Frontiers</p>
</li>
</ul>
<p><em>20241217</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 查看JIRA</li>
<li><input checked="" disabled="" type="checkbox"> Decision::checkFuturePathRisk时对当前路径和未来路径进行路径擦除时，不删除之前走过的路径，不将ctrl_seg_idx赋为1</li>
</ul>
<p><em>20241218</em></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 实车测试昨天的改动 &amp;&amp; 发版前测试</li>
<li><input checked="" disabled="" type="checkbox"> 今日论文：End-to-end 综述</li>
</ul>
<p><em>20241225</em></p>
<ul>
<li><input disabled="" type="checkbox"> 今日论文：</li>
<li><input disabled="" type="checkbox"> 第二章看完</li>
<li><input disabled="" type="checkbox"> 基于SVM的手工特征的变道的实验</li>
</ul>
<h4 id="2025"><a href="#2025" class="headerlink" title="2025"></a>2025</h4><h5 id="202502"><a href="#202502" class="headerlink" title="202502"></a>202502</h5><p><em>20250208</em></p>
<ul>
<li><input disabled="" type="checkbox"> 复习第二章的内容</li>
<li><input disabled="" type="checkbox"> 查看github算法</li>
<li><input disabled="" type="checkbox"> </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://longfei1995.github.io/2024/01/01/self_driving/self-drivingNote%20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡云浩">
      <meta itemprop="description" content="记录生活，记录工作，记录学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="胡云浩的blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/01/self_driving/self-drivingNote%20/" class="post-title-link" itemprop="url">自动驾驶控制算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-01-01T00:00:00+08:00">2024-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-10 17:05:52" itemprop="dateModified" datetime="2025-04-10T17:05:52+08:00">2025-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/" itemprop="url" rel="index"><span itemprop="name">自动驾驶</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="self-driving"><a href="#self-driving" class="headerlink" title="self-driving"></a>self-driving</h2><h3 id="1-控制算法"><a href="#1-控制算法" class="headerlink" title="1 控制算法"></a>1 控制算法</h3><h4 id="1-1-基础知识"><a href="#1-1-基础知识" class="headerlink" title="1.1 基础知识"></a>1.1 基础知识</h4><h5 id="1-1-1-三个坐标系"><a href="#1-1-1-三个坐标系" class="headerlink" title="1.1.1 三个坐标系"></a>1.1.1 三个坐标系</h5><p>首先，我们来介绍一下横纵向控制的流程</p>
<p>纵向控制：油门&#x2F;刹车–&gt;力–&gt;加速度–&gt;速度–&gt;位置</p>
<p>横向控制：方向盘转角–&gt;车轮转角–&gt;横向位移&#x2F;航向位移</p>
<p><img src="/images/1.png"></p>
<h5 id="1-1-2-一些物理量的定义"><a href="#1-1-2-一些物理量的定义" class="headerlink" title="1.1.2 一些物理量的定义"></a>1.1.2 一些物理量的定义</h5><p>图1</p>
<p><img src="/images/2.png"></p>
<h4 id="1-2-车辆模型"><a href="#1-2-车辆模型" class="headerlink" title="1.2 车辆模型"></a>1.2 车辆模型</h4><h5 id="1-2-1-运动学模型"><a href="#1-2-1-运动学模型" class="headerlink" title="1.2.1 运动学模型"></a>1.2.1 运动学模型</h5><p>假设车辆作平面运动，需要3个坐标值来描述车辆的运动$(X, Y, \psi)$<img src="/images/1-16393611888181.png" alt="1"></p>
<p>此时，车辆运动的微分方程可以表示为<br>$$<br>\dot{X} &#x3D; vcos(\psi+\beta) \<br>\dot{Y} &#x3D; vsin(\psi+\beta) \<br>\dot{\psi} &#x3D; \frac{vcos(\beta)}{l_f+l_r}(tan\delta_f-tan\delta_r)<br>$$</p>
<h5 id="1-2-2-车辆动力学模型"><a href="#1-2-2-车辆动力学模型" class="headerlink" title="1.2.2 车辆动力学模型"></a>1.2.2 车辆动力学模型</h5><p>动力学模型的必要性：</p>
<ul>
<li>动力学模型相对于运动学模型来说，考虑了轮胎的特性。</li>
<li>当选取Frenet坐标系（自然坐标系）时，可以将横纵向控制解耦。</li>
<li>高速时，轮胎没法再看成一个刚体，因此运动学模型在高速时不太适用</li>
</ul>
<h6 id="1-2-2-1-跟踪误差变量的状态空间方程"><a href="#1-2-2-1-跟踪误差变量的状态空间方程" class="headerlink" title="1.2.2.1 跟踪误差变量的状态空间方程"></a>1.2.2.1 跟踪误差变量的状态空间方程</h6><p>我们定义误差向量$x &#x3D; [e_1, \dot{e_1}, e_2, \dot{e_2}]^t$，其中e1为横向误差，e2为航向误差。则误差变量的状态方程经过推导可以写成$\dot{x} &#x3D; Ax+Bu+C\dot{\psi_{des}}$。$\dot{\psi_{des}}$是道路参考点的横摆角速度。</p>
<p>其中A矩阵定义为<br>$$<br>\left[\begin{array}{cccc}<br>0 &amp; 1 &amp; 0 &amp; 0 \<br>0 &amp; -\frac{2 C_{\alpha f}+2 C_{\alpha r}}{m v_{x}} &amp; \frac{2 C_{\alpha f}+2 C_{\alpha r}}{m} &amp; \frac{-2 C_{\alpha d} l_{f}+2 C_{\alpha r} l_{r}}{m v_{x}} \<br>0 &amp; 0 &amp; 0 &amp; 1 \<br>0 &amp; -\frac{2 C_{\alpha f} l_{f}-2 C_{\alpha r} l_{r}}{I_{z} v_{x}} &amp; \frac{2 C_{\alpha f} l_{f}-2 C_{\alpha r} l_{r}}{I_{z}} &amp; -\frac{2 C_{\alpha f} l_{f}^{2}+2 C_{\alpha r} l_{r}^{2}}{I_{z} v_{x}}<br>\end{array}\right]<br>$$<br>B矩阵定义为<br>$$<br>\left[\begin{array}{c}<br>0 \<br>\frac{2 C_{\alpha f}}{m} \<br>0 \<br>\frac{2 C_{\alpha f} l_{f}}{I_{z}}<br>\end{array}\right]<br>$$<br>C矩阵定义为<br>$$<br>\begin{bmatrix}<br> 0\<br> -\frac{C_{\alpha f}l_f-2C_{\alpha r}l_r}{mv_x}-v_x \<br> 0\<br>-\frac{2C_{\alpha f}l_f^2+2C_{\alpha r}l_r^2}{I_zv_x}<br>\end{bmatrix}<br>$$<br>其中m是车辆总质量[kg]，$v_x$是车辆质心处的纵向速度[m&#x2F;s^2]，$l_f&#x2F;l_r$是车辆质心到前&#x2F;后轴的距离[m]，Iz是车辆横摆转动惯量[kg*m^2]，$C_{\alpha f}&#x2F;C_{\alpha r}$分别为前后轮侧偏刚度[N&#x2F;rad]</p>
<h5 id="1-2-3-路径偏差的计算"><a href="#1-2-3-路径偏差的计算" class="headerlink" title="1.2.3 路径偏差的计算"></a>1.2.3 路径偏差的计算</h5><h6 id="1-2-3-1-计算投影点的速度大小和横向偏差对时间的导数"><a href="#1-2-3-1-计算投影点的速度大小和横向偏差对时间的导数" class="headerlink" title="1.2.3.1 计算投影点的速度大小和横向偏差对时间的导数"></a>1.2.3.1 计算投影点的速度大小和横向偏差对时间的导数</h6><p>如图所示，我们以车辆质心c为圆心，以质心速度为$\tau$方向建立Frenet坐标系，并且将车辆质心投影到规划轨迹上，投影点为r。质心处的位矢为$\vec{x}$，投影点的位矢为$\vec{x_r}$。$\theta$为车辆的航向角，$\theta_r$为投影点的切线角。</p>
<p>p.s:Frenet坐标系的基向量为单位向量，若$\tau$与直角坐标系x轴成$\theta$角。那么有如下结论<br>$$<br>\vec{\tau} &#x3D; [cos\theta, sin\theta]^T \<br>\vec{n} &#x3D; [-sin\theta, cos\theta]^T \<br>\frac{d\vec{\tau}}{ds} &#x3D; k\vec{n} \<br>\frac{d\vec{n}}{ds} &#x3D; -k\vec{\tau} \<br>$$<br>其中，k是坐标点处的曲率。</p>
<p>![](images&#x2F;屏幕截图 2021-12-15 115616.png)</p>
<p>从图中可知，横向误差d是c, r两点之间的距离；航向误差&#x3D;$\theta-\theta_r$；记投影点的速度大小为$\left | \vec{v_r} \right | $。</p>
<p>根据向量的平行四边形法则，我们容易得出$d\vec{n_r}&#x3D;\vec{x}-\vec{x_r}$，等号两边同时右乘$\vec{n_r}$，可以得到$d &#x3D; (\vec{x}-\vec{x_r})\cdot\vec{n_r}$。根据复合求导法则有，$\dot{d} &#x3D;( \vec{\dot{x}}-\vec{\dot{x_r}})\cdot\vec{n_r}+(\vec{x}-\vec{x_r})\cdot\vec{\dot{n_r}}$。</p>
<p>根据大学物理中，位矢的导数的意义，我们可以知道：<br>$$<br>\vec{\dot{x}} &#x3D; \left | \vec{v} \right | \vec{\tau} \<br>\vec{\dot{x_r}} &#x3D; \left | \vec{v_r} \right | \vec{\tau_r}<br>$$<br>将其代入$\dot{d}$的表达式，我们可以得出：<br>$$<br>\dot{d} &#x3D;  \left | \vec{v} \right | *cos&lt;\vec{\tau},\vec{n_r}&gt; \<br>根据示意图，我们可以得知\vec{\tau}与\vec{n_r}的夹角为:\pi&#x2F;2-(\theta-\theta_r) \<br>故，\dot{d} &#x3D; \left | \vec{v} \right |*sin(\theta-\theta_r)<br>$$<br>接下来，我们来求投影点的速度大小$\left | \vec{v_r} \right |$。<br>$$<br>根据平行四边形法则有:\vec{x_r}+d\vec{n_r}&#x3D;\vec{x} \<br>对等号两边求导:\vec{\dot{x_r}}+\dot{d}\vec{n_r}+d\vec{\dot{n_r}}&#x3D;\vec{\dot{x}} \<br>代入前面的内容，可知 \<br>\left | \vec{v_r} \right | &#x3D; \frac{\left | \vec{v} \right |*cos(\theta-\theta_r)}{1-k_rd}<br>$$<br>其中$k_r$是投影点的曲率。</p>
<h6 id="1-2-3-2-计算误差向量x"><a href="#1-2-3-2-计算误差向量x" class="headerlink" title="1.2.3.2 计算误差向量x"></a>1.2.3.2 计算误差向量x</h6><p>我们定义误差向量$x&#x3D;[e_1, \dot{e_1}, e_2, \dot{e_2}]$，$e_1$为横向偏差，$\dot{e_1}$为横向偏差率，$e_2$为横摆角偏差，$\dot{e_2}$为横摆角偏差率。</p>
<p>根据1.2.3.1所讲，$x$的计算可写成<br>$$<br>e_1 &#x3D; d &#x3D; (\vec{x}-\vec{x_r})\cdot\vec{n_r} \<br>\dot{e_1} &#x3D; \dot{d} &#x3D; \left | \vec{v} \right |<em>sin(\theta-\theta_r) \<br>e_2 &#x3D; \phi-\theta_r \<br>\dot{e_2} &#x3D; \dot{\phi}-\dot{\theta_r} &#x3D; \dot{\phi} - k_r</em>\left | \vec{v_r} \right |<br>$$<br>其中，$\dot{\theta_r} &#x3D; k_r * \left | \vec{v_r} \right |$是由曲率的定义公式推导而来的。</p>
<p>**但在离散规划轨迹中，投影点往往与规划的离散点不重合。**我们可以计算出离散轨迹点中离车辆位置$\vec{x}&#x3D;[x,y]$最近的点，这个点在Apollo中称为匹配点（match_point）。然后用匹配点代替投影点来计算误差向量$x$。</p>
<p><img src="/images/2-16395606113832.png" alt="2"></p>
<p>如图上图所示，m点为规划路径上搜索到的最近点。我们有一点假设：m点的曲率$k_m$与投影点的曲率$k_r$相等。然后我们借助最近点m来计算误差向量x。</p>
<p>根据Frenet坐标系的定义，我们可知</p>
<p>$\vec{\tau_m}&#x3D;[cos\theta_m,sin\theta_m]$，$\vec{n_m}&#x3D;[-sin\theta_m,cos\theta_m]$</p>
<p>我们用cm两点之间的距离在$\vec{n_m}$上的投影来近似横向误差$e_1$，在$\vec{\tau_m}$上的投影来近似纵向误差（在横向控制中用不到）。</p>
<p>可得：<br>$$<br>e_1 \approx (\vec{x}-\vec{x_m})\cdot\vec{n_m} &#x3D;<br>(x-x_m)*(-sin\theta_m)+(y-y_m)<em>cos\theta_m \<br>纵向误差 &#x3D; e_s \approx (\vec{x}-\vec{x_m})\cdot\vec{\tau_m} &#x3D;<br>(x-x_m)</em>(cos\theta_m)+(y-y_m)<em>sin\theta_m \<br>$$<br>基于前面的假设，我们将可知$kr &#x3D; k_m$。根据下图，也可以计算出$\theta_r &#x3D; \theta_m+k_m</em>e_s$。在Apollo中，他们认为$\theta_r &#x3D; \theta_m$。两者均可。</p>
<p>![屏幕截图 2021-12-15 175126](images&#x2F;屏幕截图 2021-12-15 175126-16395620076083.png)</p>
<p>因此，根据本节开头提到的公式。我们就可以得到误差向量x的表达式。</p>
<h4 id="1-3-横向控制算法-LQR"><a href="#1-3-横向控制算法-LQR" class="headerlink" title="1.3 横向控制算法-LQR"></a>1.3 横向控制算法-LQR</h4><h5 id="1-3-1-LQR控制"><a href="#1-3-1-LQR控制" class="headerlink" title="1.3.1 LQR控制"></a>1.3.1 LQR控制</h5><p>LQR（Linear Quadratic Regulator）线性二次型调节器是常用的最优化控制算法的一种。LQR是针对线性系统的，其Cost Function（目标函数）J是状态变量和控制变量的二次型函数。LQR分为离散型和连续型。实际工程应用大多为离散LQR，并且连续型LQR相对比较难，所以这里只对离散LQR进行讨论。</p>
<p>接下来，我们将按步骤实现离散LQR，作为反馈控制（feed-back control）u&#x3D;-Kx。</p>
<p><strong>1.建立路面误差状态空间方程，作为LQR目标函数的约束</strong></p>
<p>我们在前面1.2.2中已经建立好了，我们忽略掉$C\psi_{des}$项，可以将路面误差状态方程（约束）写为：$\dot{x}(t) &#x3D; Ax(t)+Bu(t)$</p>
<p><strong>2.离散化约束方程</strong></p>
<p>在数学分析中，对连续方程的离散化有多种，比如向前欧拉法，中点欧拉法，向后欧拉法等。我们利用向前欧拉法可以将连续化的约束方程转成离散化的约束方程<br>$$<br>x(t+dt) &#x3D; (I + A<em>dt)x(t)+B</em>dt<em>u(t) \<br>即x_{t+1} &#x3D; \bar{A}x_t+\bar{B}x_t<br>$$<br>也就是说，离散化后的矩阵$\bar{A} &#x3D; A</em>dt+I$，矩阵$\bar{B}&#x3D;B*dt$</p>
<p>其中I为单位矩阵，dt是控制的循环周期，如dt &#x3D; 0.01s。</p>
<p>对于我们的横向控制来说$\bar{A}$是一个4x4的矩阵，$\bar{B}$是一个4x1的矩阵</p>
<p><strong>3.设计适合的参数矩阵Q和R</strong></p>
<p>Q矩阵是状态权重矩阵，它的行数&#x3D;列数&#x3D;状态向量x的维度。它是一个4x4的矩阵。</p>
<p>R矩阵是控制权重矩阵，是一个1x1的矩阵。</p>
<p>刚开始调试时，我们可以将Q矩阵和R矩阵都设置成单位阵，后面再根据控制的效果慢慢调试Q矩阵和R矩阵。</p>
<p><strong>4.迭代求解黎卡提（Riccati）方程，得到：</strong><br>$$<br>P &#x3D; Q+A^TPA-A^TPB(R+B^TPB)^{-1}B^TPA<br>$$<br>当迭代计算的P矩阵的两次差值很小的时候，迭代收敛。P是一个4x4的矩阵。</p>
<p><strong>5.求解反馈控制增益矩阵K</strong><br>$$<br>K &#x3D; (B^TPB+R)^{-1}B^TPA<br>$$<br>是一个1x4的向量</p>
<p><strong>6.求解反馈控制量u(t)</strong><br>$$<br>u(t) &#x3D; \delta(t) &#x3D; -K*x(t)<br>$$<br>x(t)在1.2车辆模型那一节已经计算出来了，在每个控制周期，将x(t)更新即可。</p>
<h5 id="1-3-2-LQR的前馈控制（feed-forward-control）"><a href="#1-3-2-LQR的前馈控制（feed-forward-control）" class="headerlink" title="1.3.2 LQR的前馈控制（feed-forward control）"></a>1.3.2 LQR的前馈控制（feed-forward control）</h5><p><strong>Q1 为什么要引用前馈控制？</strong></p>
<p>**A1：**前面我们已经知道，误差变量的状态空间方程为$\dot{x}&#x3D;Ax+Bu+C\dot{\psi_{des}}$。若只用$u&#x3D;-Kx$进行反馈控制的话，那么此时状态空间方程为$\dot{x}&#x3D;(A-BK)x+C\dot{\psi_{des}}$。从这个微分方程我们可以看出，$\dot{x}$和$x$是不可能同时为0的，因为同时为0的话，方程不成立。而状态空间方程是基于车辆二自由度动力学模型建立的，是一个客观的物理规律，是不可违背的。因此，我们只用反馈控制的话，会存在一个稳态误差。</p>
<p><strong>Q2 什么是稳态误差？</strong></p>
<p>**A2：**详细的定义，请参照“现代控制理论”，在这里，稳态误差是指，$\dot{x}&#x3D;0$而$x\ne0$的现象，也就是说，当系统处于稳定状态时，存在一个恒定的误差值。</p>
<p>我们引入前馈项$\delta_f$来使输入$u&#x3D;-Kx+\delta_f$，借此来消除稳态误差。经过计算（计算过程请参考《车辆动力学及控制_第2版》），$\delta_f$应该取如下值，才能消除横向稳态误差：<br>$$<br>\delta_{\mathrm{ff}}&#x3D;\frac{L}{R}+K_{\mathrm{V}} a_{\mathrm{y}}-k_{3}\left[\frac{l_{\mathrm{r}}}{R}-\frac{l_{\mathrm{f}}}{2 C_{\mathrm{\alpha r}}} \times \frac{m v_{\mathrm{x}}^{2}}{R l}\right]<br>$$<br>其中$K_{\mathrm{V}}&#x3D;\frac{l_{\mathrm{r}} m}{2 C_{\alpha \mathrm{f}}\left(l_{\mathrm{f}}+l_{\mathrm{r}}\right)}-\frac{l_{\mathrm{f}} m}{2 C_{\alpha \mathrm{r}}\left(l_{\mathrm{f}}+l_{\mathrm{r}}\right)}$，称为转向不足梯度。</p>
<p>$ay &#x3D; \frac{v_x^2}{R}$，k3是LQR求出的K向量(1x4)的第三项。</p>
<p>而横摆角稳态误差e2可以推出：<br>$$<br>e2 &#x3D; -\frac{l_r}{R}+\frac{l_f}{2C_{\alpha f}(l_f+l_r)}\times\frac{mv_x^2}{R}<br>$$<br>我们可以看出，e2不受$\delta_f$和K的控制，只与车辆的纵向车速和道路曲率相关，而道路曲率是不可控的，欲使e2为0的话，纵向车速必须取一个确定的值。但是在汽车行驶过程中，我们不可能永远让纵向车速取成恒定的值，因此，e2是一直存在稳态误差的。</p>
<p>幸运的是，经过推算，我们可以得出，稳态误差$e2&#x3D;-\beta$，而航向角误差$e_{\theta}&#x3D;\theta-\theta_{des}&#x3D;\phi+\beta-\theta_{des}&#x3D;\beta+e_2$，故，虽然稳态横摆角误差不为0，但这样恰好导致了稳态航向误差为0，因此，我们不用去管怎么将e2调节为0，因为e2的稳态误差恰好会导致航向角误差$e_{\theta}$为0，这正是我们想要的结果。</p>
<h5 id="1-3-3-LQR算法总结"><a href="#1-3-3-LQR算法总结" class="headerlink" title="1.3.3 LQR算法总结"></a>1.3.3 LQR算法总结</h5><h6 id="1-3-3-1-算法的输入"><a href="#1-3-3-1-算法的输入" class="headerlink" title="1.3.3.1 算法的输入"></a>1.3.3.1 算法的输入</h6><ol>
<li>整车的参数：$l_f,l_r,C_{\alpha f},C_{\alpha r},m,I_z$</li>
<li>车辆的位置与状态：在全局坐标下的$x, y, \phi, v_x, v_y, \dot{\phi}$，其中，如果横摆角速度未给出，也可以根据$\dot{\phi}&#x3D;\frac{v_x}{R}$来计算（这里的R是道路参考点的曲率半径）。</li>
<li>规划的轨迹点：全局坐标下的$x_{des}, y_{des}, \theta_{des}, k_{des}$</li>
</ol>
<h6 id="1-3-3-2-算法的输出"><a href="#1-3-3-2-算法的输出" class="headerlink" title="1.3.3.2 算法的输出"></a>1.3.3.2 算法的输出</h6><p>$u&#x3D;-Kx+\delta_{ff}$</p>
<h6 id="1-3-3-3-算法流程图"><a href="#1-3-3-3-算法流程图" class="headerlink" title="1.3.3.3 算法流程图"></a>1.3.3.3 算法流程图</h6><img src="images/LQR流程图-16394695260081.png" alt="LQR流程图" style="zoom: 200%;" />

<h4 id="1-4-纵向控制"><a href="#1-4-纵向控制" class="headerlink" title="1.4 纵向控制"></a>1.4 纵向控制</h4><p>油门-&gt;发动机功率改变-&gt;发动机转速&#x2F;扭矩改变-&gt;车加速</p>
<p>刹车-&gt;制动压力增大-&gt;制动盘摩擦力增大-&gt;阻力增大-&gt;车减速</p>
<h5 id="1-4-1-发动机扭矩-转速曲线"><a href="#1-4-1-发动机扭矩-转速曲线" class="headerlink" title="1.4.1 发动机扭矩-转速曲线"></a>1.4.1 发动机扭矩-转速曲线</h5><p><img src="/images/1-16399808327761.png"></p>
<p>我们的纵向控制是基于电动车的。因此，做纵向控制，需要标定油门刹车表(v-a-thr&#x2F;v-a-brake)，然后将两表合在一起</p>
<h5 id="1-4-2-双环PID控制"><a href="#1-4-2-双环PID控制" class="headerlink" title="1.4.2 双环PID控制"></a>1.4.2 双环PID控制</h5><h6 id="1-4-2-1-PID简单介绍"><a href="#1-4-2-1-PID简单介绍" class="headerlink" title="1.4.2.1 PID简单介绍"></a>1.4.2.1 PID简单介绍</h6><p>在PID控制中：</p>
<p>P是比例项，可以用来放大误差。加快期望值接近目标值。在仿真中，因为没有延迟，所以不会引起超调，但是在实际控制中，因为延迟的存在，会引起超调；</p>
<p>I是积分项，可以用来消除稳态误差，但会引起超调</p>
<p>D是微分项，可以用来抑制超调。</p>
<p>一般来说，我们常用P，PD控制。因为在纵向控制中，即使没有达到精准的车速也没关系，只要满足控制精度即可。一般先调P再调D然后再调I。</p>
<h6 id="1-4-2-2-Simulink实现"><a href="#1-4-2-2-Simulink实现" class="headerlink" title="1.4.2.2 Simulink实现"></a>1.4.2.2 Simulink实现</h6><p>Apollo纵向控制采用双环PID控制，原理图如下：</p>
<p><img src="C:/Users/HuYunhao/Desktop/2018091917092752.png"></p>
<p>用Simulink实现如下：</p>
<img src="images/image-20211223150116439-16402429099701.png" style="zoom:150%;" />

<h3 id="2-决策与规划规划算法"><a href="#2-决策与规划规划算法" class="headerlink" title="2 决策与规划规划算法"></a>2 决策与规划规划算法</h3><h4 id="2-1-基础知识"><a href="#2-1-基础知识" class="headerlink" title="2.1 基础知识"></a>2.1 基础知识</h4><h5 id="2-1-1-决策规划简介"><a href="#2-1-1-决策规划简介" class="headerlink" title="2.1.1 决策规划简介"></a>2.1.1 决策规划简介</h5><p><strong>1.决策规划有哪些模块？</strong></p>
<p>一般来说，规划算法分为三个模块：</p>
<p>**全局路径规划模块&#x2F;导航规划算法：**此算法计算出大地图上A到B的最优路径，长度从几公里到几百公里不等。是整个规划模块中最为成熟的算法。**特点：**全局路径规划的结果是一个粗略的，大范围的路径，这个路径不会考虑避障，也不会考虑车辆的动力学约束，一般全局路径规划的路径是不规则的折线。全局路径规划算法一般只需要执行一次，只有遇到大范围的道路拥堵、施工、偏航等情况，才会再次执行全局路径规划。</p>
<p>**决策算法&#x2F;行为规划算法：**此算法决定车辆行驶的意图，比如：对静态障碍物到底往左绕还是往右绕，对于动态障碍物到底是减速避让还是加速超车。<strong>这是整个规划算法中最难的部分。特点</strong>：决策算法会给定车辆的行驶意图，会指导车辆该避让还是超车，该左转还是右转，但是决策算法不会给出具体的运动建议，比如左转多少度，车辆加速到多少。实际的环境是瞬息万变的，因此决策模块的执行效率一般较高，为10HZ，同时，决策算法还需要一定的稳定性，不允许在周围环境稳定时出现“朝令夕改”的现象。</p>
<p>**局部路径规划&#x2F;运动规划算法：**根据决策给出的驾驶行为意图，在相关的时空搜索出一条详细的路径，并且该路径是满足各个约束条件的轨迹。这条轨迹就是发送给控制模块去跟踪的轨迹，一般长度在几米到几十米不等。**特点：**局部路径规划生成的轨迹是决策规划模块最终的输出，具有详细的路径和速度信息。执行的频率和决策算法模块相同，为10HZ。同样，运动规划的轨迹也需要具有一定的稳定性。</p>
<p><strong>2.决策规划的流程</strong></p>
<p>前提：已经有了全局路径规划的路径。</p>
<ol>
<li>由定位模块+全局路径，生成参考线。</li>
<li>将静态障碍物投影到以参考线为坐标轴的Frenet坐标系上。</li>
<li>决策算法对障碍物做出决策（往左绕还是往右绕等），等价于开辟最优凸空间。</li>
<li>规划算法在决策算法开辟的最优凸空间内，搜索出一条最优的路径。</li>
<li>后处理：将最优路径平滑并且转换成cartesian坐标，发送给控制模块。</li>
</ol>
<h5 id="2-1-2-数学基础-五次多项式"><a href="#2-1-2-数学基础-五次多项式" class="headerlink" title="2.1.2 数学基础-五次多项式"></a>2.1.2 数学基础-五次多项式</h5><p>五次多项式是规划论文中的常客，本节将详细讲述五次多项式的特殊性。</p>
<p><strong>1.如何定量评价车辆的舒适性？</strong></p>
<p>在车辆有运动规划中，一个非常重要的指标就是舒适性。在物理中，衡量舒适性的物理量为跃度，英文为Jerk，Jerk定义为：<br>$$<br>Jerk &#x3D; \frac{da}{dt}<br>$$<br>即Jerk是加速度对时间的导数，Jerk的绝对值越小意味着加速度的变化越平缓，加速度变化平缓也意味着越舒适。</p>
<p>如果有一个质点的轨迹为：S&#x3D;f(t)，则$Jerk&#x3D;\frac{d^3f}{dt^3}$，若在区间[0, T]的时间中，Jerk的绝对值都比较小，那么意味着[0, T]内规划的轨迹是比较舒适的。此时，问题变成了一个数学问题：有一个函数S&#x3D;f(t)，那么什么样的f(t)可以使得[0, T]内的Jerk的绝对值越小？（由于绝对值的处理较为繁琐，因此一般用平方代替）。也就是说，找到一个f(t)，使得<br>$$<br>\int_{0}^{T}(\frac{d^3f}{dt^3})^2dt<br>$$<br>最小，显然，积分$\int_{0}^{T}(\frac{d^3f}{dt^3})^2dt$是一个关于f(t)的泛函，积分的值取决于f(t)在[0, T]上的整体形状。P.S.泛函可以看一下变分法和最速降线相关的书籍。</p>
<p><img src="/images/3.png"></p>
<h5 id="2-1-3-数学基础-凸优化"><a href="#2-1-3-数学基础-凸优化" class="headerlink" title="2.1.3 数学基础-凸优化"></a>2.1.3 数学基础-凸优化</h5><p><strong>1.规划轨迹最优指标的定量描述</strong></p>
<p>自动驾驶的规划目标：算出一条满足约束的最优轨迹，让控制去执行。</p>
<p>那最优的指标是什么呢？约束有哪些呢？</p>
<blockquote>
<p>指标：平滑性；舒适性；尽可能短，耗时少</p>
<p>约束：轨迹连续性；无碰撞；遵守交规；遵循车辆动力学特性；</p>
</blockquote>
<p>我们往往用一个数学函数cost function去定量的描述最优指标，假设有一条轨迹$s &#x3D; f(t) &#x3D; a_0+a_1t+a_2t^2+a_3t^3+a_4t^4+a_5t^5$，我们构建如下的成本函数J<br>$$<br>J &#x3D; w_1\dot{f}^2+w_2\ddot{f}^2+w_3\dddot{f}^2<br>$$<br>其中w1, w2, w3分别代表权重，J越小，说明各个导数的值越小，也就意味着轨迹s越平滑。</p>
<p><strong>2.如何求cost function在约束下的最小值</strong></p>
<p>这一节，我们来探讨一个数学问题：<strong>如何求解cost function在约束下的最小值</strong>。</p>
<p>在《数值分析》中，求一个复杂函数在复杂约束下的最值问题，一般都采用迭代法，而不是求导法。常见的迭代法有：牛顿法，梯度下降法，高斯牛顿法（视觉slam十四讲中有提)。</p>
<p>但是，迭代法在求解复杂函数在复杂约束上的最值时，也有自己的缺点。</p>
<p><strong>缺点一</strong>：如果约束空间不连续的话，会收敛到局部最小值</p>
<p>如下图所示：</p>
<img src="images/image-20220524192926814.png" alt="image-20220524192926814" style="zoom: 50%;" />



<p>如果选取$x_0$为迭代初值的话，那么最小值将会是$x_1$；如果选取$x_0^{‘}$为迭代初值的话，那么迭代法收敛到最小值$x_1{‘}$。</p>
<p>缺点二：约束空间是连续的，但是初值的选择不同也会迭代到局部最小值。</p>
<img src="images/image-20220524193948331.png" alt="image-20220524193948331" style="zoom:50%;" />

<p>如果选取$x_0$为迭代初值，那么迭代的最小值是$x_n$；如果以$x_0{‘}$为迭代初值的话，迭代的最小值为$x_n{‘}$；如果以$x_0{‘’}$为迭代初值的话，迭代的最小值为$x_n{‘’}$。</p>
<p>由此可见，<strong>由于初值的选择不同，迭代法有可能收敛到局部最小值</strong>。</p>
<p><strong>3.凸优化（二次规划）的定义</strong></p>
<p>如果有这么一种函数，它只有一个极值点，且为极小值。并且约束空间是一个完整的连续区间。此时迭代法对初值不敏感，且迭代收敛的解必定是约束下的最小值。满足这样性质的函数我们成为凸函数，这种完整的空间我们成为凸空间，<strong>求凸函数在凸空间下的最小值问题称为凸优化。</strong></p>
<img src="images/image-20220524194437665.png" alt="image-20220524194437665" style="zoom:50%;" />

<p>此定义非严谨定义，是方便理解的凸优化的定义。</p>
<p>但是，对<strong>自动驾驶规划来说，约束的空间并不是一个凸空间</strong>。p.s.，比如在避障工况，障碍物会把约束空间打碎成非凸空间，如下图所示的静态避障的例子：</p>
<img src="images/image-20220524215904173.png" alt="image-20220524215904173" style="zoom: 25%;" />

<p>那么如何求解非凸问题？答案是：把非凸问题转换成凸问题。</p>
<p>非凸问题1：求解一个函数为凸函数，空间为非凸空间的非凸问题</p>
<img src="images/image-20220524220409280.png" alt="image-20220524220409280" style="zoom:25%;" />

<p>我们可以随机在约束空间（非凸空间）采样一些离散的点，然后比较这些离散点的函数值，取最小的那个函数值对应的$x$，作为迭代的初始值，从而求出函数的最小值。</p>
<p>非凸问题2：函数是非凸函数，空间也是非凸空间（不连续的空间）。</p>
<p><img src="/images/1-16417968777281.png" alt="1"></p>
<p>解决方法仍然是随机的采一些离散的函数值，然后取最小函数值对应的$x$作为迭代的初值。</p>
<p>我们把上图提到的离散函数的最小值称为<strong>粗解</strong>，因此，求一个非凸问题的过程可以表述为：非凸空间-&gt;采样离散点(离散化)-&gt;粗解-&gt;根据粗解迭代-&gt;最终解。<strong>但是这种解法会存在一个问题</strong>，就是取的离散点太少时，一样容易导致收敛到局部最优。解决的办法是多采一些离散值，但离散值取多了，又会导致维度灾难的问题。p.s.所谓的维度灾难的问题，就是在一维非凸问题中，如果选取100个离散点，那么对应的在二维非凸问题中，就会要采样100*100个离散点。</p>
<h5 id="2-1-4-Frenet与笛卡尔坐标系的相互转换"><a href="#2-1-4-Frenet与笛卡尔坐标系的相互转换" class="headerlink" title="2.1.4 Frenet与笛卡尔坐标系的相互转换"></a>2.1.4 Frenet与笛卡尔坐标系的相互转换</h5><h6 id="2-1-4-1-预备知识"><a href="#2-1-4-1-预备知识" class="headerlink" title="2.1.4.1 预备知识"></a>2.1.4.1 预备知识</h6><p><strong>预备知识-1</strong></p>
<ul>
<li><p>龙格现象：对离散点进行多项式拟合的时候，一般来说多项式的阶数越高，越准确。但是用高次多项式拟合离散点可能会出现震荡的现象，龙格在1901年发现的。因此我们尽可能用<strong>分段的低次多项式</strong>去拟合离散点，而不是高次多项式。</p>
</li>
<li><p>为什么需要自然坐标系（Frenet)?</p>
</li>
</ul>
<p>​		在直角坐标系下处理规划问题，比较困难。需要先将直角坐标系–&gt;自然坐标系，然后再转换回来。</p>
<ul>
<li>Frenet坐标系的简介</li>
</ul>
<p>​		在大地平面上，局部路面可以看做是一个平面。此时对于自动驾驶的规划模块来说，Frenet坐标系的挠度可以设置为0，从而有下面的Frenet公式：<br>$$<br>\begin {align}<br>	\frac{d\vec{\tau}}{ds} &amp;&#x3D; k\vec{n} \<br>	\frac{d\vec{n}}{ds} &amp;&#x3D; -k\vec{\tau} \<br>\end {align}<br>$$<br>若此时Frenet坐标系的$\vec{\tau}$向量与Cartesian坐标系的x轴的夹角为$\theta$,有如下的结论<br>$$<br>\begin{align}<br>	\vec{\tau} &amp;&#x3D; [cos\theta, sin\theta]^T \<br>	\vec{n} &amp;&#x3D; [-sin\theta, cos\theta]^T \<br>\end{align}<br>$$<br><strong>预备知识2–推导前的变量的定义</strong></p>
<img src="images/image-20220718151502057.png" alt="image-20220718151502057" style="zoom: 33%;" />

<p>如图所示，已知车辆在笛卡尔坐标系下的$(\vec{r}, v, a, \theta, k)$，求车辆在以参考线(reference line)为道路几何(Base frame)下的Frenet坐标$(s, \dot{s}, \ddot{s}, l, \dot{l}, \ddot{l}, l’, l’’)$</p>
<p>这些量的含义为：</p>
<ul>
<li>$s$  Frenet纵坐标</li>
<li>$\dot{s}&#x3D;\frac{ds}{dt}$  Frenet纵坐标对时间的导数，即沿base frame的速度</li>
<li>$\ddot{s} &#x3D; \frac{d\dot{s}}{dt}$  沿base frame的加速度</li>
<li>$l$  Frenet坐标系横坐标</li>
<li>$\dot{l} &#x3D; \frac{dl}{dt}$  Frenet横向速度</li>
<li>$\ddot{l}&#x3D;\frac{d\dot{l}}{dt}$  Frenet横向加速度</li>
<li>$l’&#x3D;\frac{dl}{ds}$  Frenet横坐标对纵坐标的导数</li>
<li>$l’’&#x3D;\frac{dl’}{ds}$  Frenet横坐标对纵坐标的二阶导</li>
<li>$\vec{r}&#x3D;(x,y)$  车辆在笛卡尔坐标系下的坐标，是一个向量</li>
<li>$v&#x3D;\frac{d\vec{r}}{dt}$  车辆在笛卡尔坐标系下的速度</li>
<li>$a$  车辆在笛卡尔坐标系下的加速度</li>
<li>$\theta$  车辆在笛卡尔坐标系下的横摆角</li>
<li>$k$  曲率</li>
</ul>
<p>Frenet坐标系下的点有两种表示方式$(s, \dot{s}, \ddot{s}, l, \dot{l}, \ddot{l})$或者$(s, \dot{s}, \ddot{s}, l,  l’, l’’)$其中$\dot{l}, \ddot{l}$和$l’,l’’$是可以相互转换的，转换关系的推导如下所示：<br>$$<br>\begin{align}<br>	\dot{l} &amp;&#x3D; \frac{dl}{dt} &#x3D; \frac{dl}{ds}\cdot\frac{ds}{dt} &#x3D; l’\cdot\dot{s}  \<br>	\ddot{l} &amp;&#x3D; \frac{d\dot{l}}{dt} &#x3D; \frac{d(l’\cdot\dot{s})}{dt} &#x3D; l’’\cdot\dot{s}^2+l’\cdot\ddot{s}<br>\end{align}<br>$$<br><strong>预备知识3–曲线坐标轴对时间的导数</strong></p>
<p>Frenet坐标系（曲线坐标系）相对于笛卡尔坐标系来说，最大的不同在于：</p>
<p>1.笛卡尔坐标系下的坐标轴的基向量$(\vec{i}, \vec{j})$对时间的导数等于0，而Frenet坐标系的基向量$(\vec{\tau}, \vec{s})$对时间的导数不为0；</p>
<p>2.笛卡尔坐标系下，坐标点的微分$dx$与坐标点在坐标轴上的投影的微分$dx$是相等的，而Frenet坐标系下，坐标点的微分$ds$与投影点的微分$ds$并不相等。也就是说，曲线坐标系下有多个$ds$，必要时，要用不同的符号对齐区分，以免混淆。</p>
<p>我们来求Trajectory上的$(\vec{\tau}, \vec{n})$对时间的导数和Reference Line上的$(\vec{\tau_r}, \vec{n_r})$对时间的导数，我们记Trajectory上的弧微分为$ds_x$<br>$$<br>\begin{align}</p>
<pre><code>\dot&#123;\vec&#123;\tau&#125;&#125; &amp;= \frac&#123;d\vec&#123;\tau&#125;&#125;&#123;dt&#125; = \frac&#123;d\vec&#123;\tau&#125;&#125;&#123;ds_x&#125; \cdot \frac&#123;ds_x&#125;&#123;dt&#125; = k \cdot 			\vec&#123;n&#125; \cdot \left | \vec&#123;v&#125; \right | \tag&#123;1&#125;\\
\dot&#123;\vec&#123;n&#125;&#125; &amp;= -k \cdot \vec&#123;\tau&#125; \cdot \left | \vec&#123;v&#125; \right | \tag&#123;2&#125;\\
\dot&#123;\vec&#123;\tau_r&#125;&#125; &amp;= k_r \cdot \vec&#123;n_r&#125; \cdot \left | \vec&#123;v_r&#125; \right | =  k_r \cdot \vec&#123;n_r&#125; \cdot    		\dot&#123;s&#125; \tag&#123;3&#125;\\
\dot&#123;\vec&#123;n_r&#125;&#125; &amp;= -k_r \cdot \vec&#123;\tau_r&#125; \cdot \dot&#123;s&#125; \tag&#123;4&#125; \\
</code></pre>
<p>\end{align}<br>$$<br><strong>p.s</strong>.Frenet坐标中$\dot{s} &#x3D; \frac{ds}{dt}$，此处的$ds$指的是道路几何(base frame)的$ds$。因此，你可以看到上面的推导中，对于Reference Line的坐标的导数的推导，有$\left | \vec{v_r} \right | &#x3D;\dot{s} $。而对于Trajectory的坐标的导数推导，由于$\left | \vec{v} \right | &#x3D; \frac{ds_x}{dt}$不等于$\frac{ds}{dt}$，故不可以用$\dot{s}$代替$\left | \vec{v} \right |$</p>
<p><strong>预备知识4–速度和加速度的推导</strong><br>$$<br>\begin{align}<br>	\vec{v} &amp;&#x3D; \dot{\vec{r}} &#x3D; \frac{d\vec{r}}{dt} &#x3D; \frac{d\vec{r}}{ds_x} \cdot \frac{ds_x}{dt} &#x3D; 					\vec{\tau} \cdot \left | \vec{v} \right | \tag5 \<br>    \vec{v_r} &amp;&#x3D; \dot{\vec{r_r}} &#x3D; \vec{\tau_r} \cdot \left | \vec{v_r} \right | &#x3D;  \vec{\tau_r} \cdot 				\dot{s} \tag6 \<br>	\vec{a} &amp;&#x3D; \frac{d\vec{v}}{dt} &#x3D; \left | \dot{\vec{v}} \right | \vec{\tau} + k \cdot \left | \vec{v} 			\right |^2 \cdot \vec{n} \tag7 \<br>\end{align}<br>$$</p>
<h6 id="2-1-4-2-推导过程"><a href="#2-1-4-2-推导过程" class="headerlink" title="2.1.4.2 推导过程"></a>2.1.4.2 推导过程</h6><p><strong>1.笛卡尔坐标系转Frenet坐标系</strong></p>
<p>已知车辆在笛卡尔坐标系下的$(\vec{r}, v, a, \theta, k)$，已知reference line上的各个离散点的坐标$(x_i, y_i, \theta_i, k_i)$。求车辆的Frenet坐标$(s, \dot{s}, \ddot{s}, l, \dot{l}, \ddot{l}, l’, l’’)$</p>
<p><strong>第一步</strong>：推导出来<code>预备知识3和预备知识4</code>的7个公式，已完成。</p>
<p><strong>第二步</strong>：找到车辆在Frenet坐标系下的投影点记为$(\vec{r_r}, \theta_r, k_r)$</p>
<img src="images/image-20220720094553623.png" alt="image-20220720094553623" style="zoom:33%;" />

<p>如图所示，已知车辆的位置点$x$，求车辆在离散路径上的投影点$r$。</p>
<p>对于离散轨迹的投影点的计算，我们可以用匹配点$r_m$的信息来估计投影点的信息$r_r$。遍历整个离散点集，找到与车辆距离最近的点，这个点即为离散点$m$。此时可以得到$\vec{d} &#x3D; (x-x_m, y-y_m)$，$\vec{\tau_m} &#x3D; (cos\theta_m,sin\theta_m)$</p>
<p>1)估计$\vec{r_r} &#x3D; (x_r, y_r)$</p>
<p>$\vec{r_r} &#x3D; \vec{r_m} + (\vec{d} \cdot \vec{\tau_m}) \cdot \vec{\tau_m}$，写成非向量形式<br>$$<br>x_r &#x3D; x_m + ((x-x_m)cos\theta_m + (y-y_m)sin\theta_m) cos\theta_m \<br>y_r &#x3D; y_m + ((x-x_m)cos\theta_m + (y-y_m)sin\theta_m) sin\theta_m<br>$$<br>2)估计$\theta_r, k_r$</p>
<p>我们近似的认为$k_r &#x3D; k_m$，也就是说认为匹配点和参考点之间是圆弧过渡的。</p>
<p>因此$\theta_r &#x3D; \theta_m + d\theta$，根据曲率的定义有$k_m &#x3D; \frac{d\theta}{ds}$。而ds近似的等于$ds &#x3D; \vec{d} \cdot \vec{\tau_m}$</p>
<p>故$\theta_r &#x3D; \theta_m + k_m\vec{d} \cdot \vec{\tau}_m$，写成非向量形式有：$\theta_r &#x3D; \theta_m+k_m((x-x_m)cos\theta_m+(y-y_m)sin\theta_m)$</p>
<p><strong>第三步</strong>：利用向量三角形和微积分，求出$(s, \dot{s}, \ddot{s}, l, l’, l’’)$</p>
<p>根据上图中的向量三角形，我们可以得出坐标转换的<strong>核心公式</strong>：$\vec{r} &#x3D; \vec{r_r} + l \cdot \vec{n_r}$。 </p>
<ul>
<li>计算$s$</li>
</ul>
<p>已知离散点的点集，那么投影点的$s$的计算方法就是，以直代曲，将各个离散点的距离加起来。这种粗略的算法对于离散点密集，曲率不大的场景内适合，且鲁棒性很好。</p>
<p>$s &#x3D; ((x_1-x_0)^2+(y_1-y_0)^2)^{1&#x2F;2} + ((x_2-x_1)^2+(y_2-y_1)^2)^{1&#x2F;2}+…+((x_r-x_{r-1})^2+(y_r-y_{r-1})^2)^{1&#x2F;2}$</p>
<ul>
<li>计算$\dot{s}$</li>
</ul>
<p>将核心公式两边求导可知，$\dot{\vec{r}} &#x3D; \dot{\vec{r_r}} + \dot{l} \cdot \vec{n_r} + l \cdot \dot{\vec{n_r}}$</p>
<p>代入公式(4)(5)(6)可知，$\vec{v} &#x3D; \vec{\tau_r} \cdot \dot{s} + \dot{l} \cdot \vec{n_r} + l \cdot (-k_r \cdot \dot{s} \cdot {\tau_r})$(<code>临时公式1</code>)两边同时右乘$\vec{\tau_r}$可得：</p>
<p>$\vec{v} \cdot \vec{\tau_r} &#x3D;(1-k_rl) \cdot \dot{s}$，写成非向量形式，可得</p>
<p>$$<br>\dot{s} &#x3D; \frac{\left | \vec{v} \right | \cdot cos(\theta-\theta_r)}{1-k_rl}<br>$$</p>
<ul>
<li>计算$\ddot{s}$</li>
</ul>
<p>$\ddot{s} &#x3D; \frac{d\dot{s}}{dt}$，代入$\dot{s}$的结果，然后化简可知：</p>
<p>$\ddot{s} &#x3D; \frac{\vec{a} \cdot \vec{\tau_r} + k_r \dot{s}^2 l’ + \dot{s}^2(k_r’l+k_rl’)}{1-k_rl}$化简成非向量的形式：<br>$$<br>\ddot{s} &#x3D; \frac{\left | \dot{\vec{v}} \right | cos(\theta-\theta_r) - \dot{s}^2[l’(\frac{k(1-k_rl)}{cos(\theta-\theta_r)}-k_r)-(k_r’l+k_rl’)]}{1-k_rl}<br>$$</p>
<ul>
<li>计算$l$</li>
</ul>
<p>将核心公式恒等变化可知，$l &#x3D; (\vec{r}-\vec{r_r}) \cdot \vec{n_r}$，写成非向量形式</p>
<p>$$<br>l &#x3D; -sin\theta_r(x-x_r) + cos\theta_r(y-y_r)<br>$$</p>
<ul>
<li>计算$\dot{l}$</li>
</ul>
<p>由<code>临时公式1</code>，$\vec{v} &#x3D; \vec{\tau_r} \cdot \dot{s} + \dot{l} \cdot \vec{n_r} + l \cdot (-k_r \cdot \dot{s} \cdot {\tau_r})$。两边同点乘$\vec{n_r}$可得：</p>
<p>$\dot{l} &#x3D; \vec{v} \cdot \vec{n_r}$，写成非向量形式</p>
<p>$$<br>\dot{l} &#x3D; \left | \vec{v} \right | \cdot sin(\theta-\theta_r)<br>$$</p>
<ul>
<li>计算$l’$</li>
</ul>
<p>$l’ &#x3D; \frac{dl}{ds} &#x3D; \frac{\frac{dl}{dt}}{\frac{ds}{dt}} &#x3D; \frac{\dot{l}}{\dot{s}}$，代入前述结果可知：</p>
<p>$$<br>l’ &#x3D; (1-k_rl)tan(\theta-\theta_r)<br>$$</p>
<ul>
<li>计算$\ddot{l}$</li>
</ul>
<p>$\ddot{l} &#x3D; \frac{d\dot{l}}{dt} &#x3D; \frac{d(\vec{v} \cdot \vec{n_r})}{dt}$由公式(4)可知，</p>
<p>$$<br>\ddot{l} &#x3D; \vec{a} \cdot \vec{n_r} - k_r(1-k_rl)\dot{s}^2<br>$$</p>
<ul>
<li>计算$l’’$</li>
</ul>
<p>由预备知识2可知，$\ddot{l} &#x3D; l’’\cdot\dot{s}^2+l’\cdot\ddot{s}$，即$l’’ &#x3D; \frac{\ddot{l}-l’\ddot{s}}{\dot{s}^2}$，写成非向量形式<br>$$<br>l’’ &#x3D; -(k_r’l+k_rl’)tan(\theta-\theta_r)+ \frac{(1-k_rl)}{cos^2(\theta-\theta_r)} (\frac{k(1-k_rl)}{cos(\theta-\theta_r)}-k_r)<br>$$</p>
<p><strong>2.Frenet坐标系转笛卡尔坐标系</strong></p>
<p>​	已知reference line上的各个离散点的坐标$r_i(x_i, y_i, \theta_i, k_i)$，已知车辆的Frenet坐标$(s, \dot{s}, \ddot{s}, l, \dot{l}, \ddot{l}, l’, l’’)$，求车辆的笛卡尔坐标$(\vec{r}, v, a, \theta, k)$。</p>
<p>**第一步：**计算参考线上各个离散点$r_i(x_i, y_i, \theta_i, k_i)$与Frenet s坐标的对应关系</p>
<table>
<thead>
<tr>
<th align="center">$r_i$</th>
<th align="center">$(x_0,y_0,\theta_0,k_0)$</th>
<th align="center">$(x_1,y_1,\theta_1,k_1)$</th>
<th align="center">$(x_i,y_i,\theta_i,k_i)$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$s_i$</td>
<td align="center">0</td>
<td align="center">$((x_1-x_0)^2+(y_1-y_0)^2)^{1&#x2F;2}$</td>
<td align="center">$\sum_{i&#x3D;0}^{i-1}((x_{i+1}-x_i)^2+(y_{i+1}-y_i)^2)^{1&#x2F;2} $</td>
</tr>
</tbody></table>
<p>**第二步：**根据车辆投影点的s坐标（与车辆的s坐标一致），查上表得到投影点的前一个点$r_n$，和投影点的后一个点$r_{n+1}$。</p>
<img src="images/image-20220801152101382.png" alt="image-20220801152101382" style="zoom: 67%;" />

<p>**第三步：**求投影点$r_r(x_r, y_r, \theta_r, k_r, k_r’)$</p>
<p>根据向量三角形有$\vec{r_r} &#x3D; \vec{r_n}+\vec{r_d}$，并且，$\vec{r_d}$可以用长度为$s-s_n$，方向为n点切线方向的向量来近似表示。即有</p>
<p>$\vec{r_r} &#x3D; \vec{r_n} + (s-s_n)\vec{\tau_n}$，写成非向量的形式有：<br>$$<br>x_r &#x3D; x_n + (s-s_n)cos\theta_n \<br>y_r &#x3D; y_n + (s-s_n)sin\theta_n<br>$$<br>根据曲率定义和圆弧假设，有$\theta_r &#x3D; \theta_n + k_n(s-s_n)$，$k_r &#x3D; k_n$。</p>
<p>$k_r’ &#x3D; \frac{dk_r}{ds} \approx \frac{k_{n+1}-k_n}{s_{n+1}-s_n}$</p>
<p>**第四步：**有了投影点的信息$(x_r,y_r,\theta_r,k_r)$和车辆的Frenet坐标$(s, \dot{s}, \ddot{s}, l, \dot{l}, \ddot{l}, l’, l’’)$后，我们根据<code>笛卡尔转Frenet</code>的公式可以反推得出</p>
<p>车辆的笛卡尔坐标$(\vec{r}, v, a, \theta, k)$</p>
<h6 id="2-1-4-3-结论"><a href="#2-1-4-3-结论" class="headerlink" title="2.1.4.3 结论"></a>2.1.4.3 结论</h6><p>车辆在笛卡尔坐标系下的坐标表示为$(\vec{r}, v, a, \theta, k)$，车辆在Frenet坐标系下的坐标表示为$(s, \dot{s}, \ddot{s}, l, \dot{l}, \ddot{l}, l’, l’’)$。车辆在参考线上的投影点的坐标表示为$(x_r,y_r,\theta_r,k_r,k_r’)$</p>
<blockquote>
<p>CartesianToFrenet</p>
</blockquote>
<p>$$<br>\begin{align}<br>&amp; s &#x3D; ((x_1-x_0)^2+(y_1-y_0)^2)^{1&#x2F;2} + ((x_2-x_1)^2+(y_2-y_1)^2)^{1&#x2F;2}+…+((x_r-x_{r-1})^2+(y_r-y_{r-1})^2)^{1&#x2F;2} \<br>&amp; \dot{s} &#x3D; \frac{\left | \vec{v} \right | \cdot cos(\theta-\theta_r)}{1-k_rl} \<br>&amp; \ddot{s} &#x3D; \frac{\left | \dot{\vec{v}} \right | cos(\theta-\theta_r) - \dot{s}^2[l’(\frac{k(1-k_rl)}{cos(\theta-\theta_r)}-k_r)-(k_r’l+k_rl’)]}{1-k_rl} \<br>&amp; l &#x3D; -sin\theta_r(x-x_r) + cos\theta_r(y-y_r) \<br>&amp; l’ &#x3D; (1-k_rl)tan(\theta-\theta_r) \<br>&amp; l’’ &#x3D; -(k_r’l+k_rl’)tan(\theta-\theta_r)+ \frac{(1-k_rl)}{cos^2(\theta-\theta_r)} (\frac{k(1-k_rl)}{cos(\theta-\theta_r)}-k_r) \<br>&amp; \dot{l} &#x3D; l’\cdot\dot{s} \<br>&amp; \ddot{l} &#x3D; l’’\cdot\dot{s}^2+l’\cdot\ddot{s} \<br>\end{align}<br>$$</p>
<p>其中：</p>
<p>$\left | \vec{v} \right |$为车辆的车速的模, 这里用速度$v$的值即可。</p>
<p>$\left | \dot{\vec{v}} \right |$为车辆的切向加速度的模，这里用加速度$a$的值即可。注意：由<code>公式(7)</code>或者物理常识，我们可以知道，切向加速度的大小不等于加速度的大小，即$\left | \dot{\vec{v}} \right | \ne   \left | \vec{a} \right |$。</p>
<blockquote>
<p>FrenetToCartesian</p>
</blockquote>
<p>$$<br>\begin{align}<br>&amp; x &#x3D; x_r - lsin\theta_r \<br>&amp; y &#x3D; y_r + lcos\theta_r \<br>&amp; \theta &#x3D; arctan(\frac{l’}{1-k_rl}) + \theta_r \<br>&amp; k &#x3D; { [l’’+(k_r’l+k_rl’)tan(\theta-\theta_r)] \frac{cos^2(\theta-\theta_r)}{1-k_rl} + k_r } \frac{cos(\theta-\theta_r)}{1-k_rl} \<br>&amp; v &#x3D; \sqrt{[\dot{s}(1-k_rl)]^2 + (\dot{s}l’)^2} \<br>&amp; a &#x3D; \ddot{s}\frac{1-k_rl}{cos(\theta-\theta_r)} + \frac{\dot{s}^2}{cos(\theta-\theta_r)}[l’(k \frac{1-k_rl}{cos(\theta-\theta_r)} - k_r) - (k_r’l+k_rl’)] \<br>\end {align}<br>$$</p>
<h4 id="2-2-参考线模块"><a href="#2-2-参考线模块" class="headerlink" title="2.2 参考线模块"></a>2.2 参考线模块</h4><p>根据<code>2.1</code>中的决策规划模块工作流程，我们先说怎么从“定位+全局路径规划”生成参考线。</p>
<p><strong>1.预备知识</strong></p>
<p>（1）参考线是什么？</p>
<p>参考线是从全局路径截取一段，做平滑生成的曲线。因为全局路径有以下缺点：</p>
<ul>
<li><p>全局路径往往是不平滑的</p>
</li>
<li><p>全局路径一般都比较长，不利于坐标转换（找匹配点，计算S）</p>
</li>
<li><p>障碍物在过长路径上的投影可能不唯一</p>
</li>
</ul>
<p>（2）怎么做参考线？</p>
<p>在每个规划周期内，我们找到车辆在全局路径上的投影点（用匹配点也行），以投影点为坐标原点，往后取一段距离，往前取一段距离，将这个距离内的点做平滑，平滑后的点的集合称为参考线。</p>
<p>（3）参考线算法如何提高运行速度？</p>
<ul>
<li>减少规划的频率，规划算法每100ms执行一次，控制算法每10ms执行一次</li>
<li>充分利用上一个规划周期的结果</li>
</ul>
<p><strong>2.参考线的平滑算法</strong></p>
<p><em><strong>算法1-FEM Smoother：</strong></em></p>
<p>算法优点：优化的变量较少</p>
<p>算法缺点：无法保证曲率是连续的（没有曲率项的约束）。</p>
<p>算法的观点：</p>
<p><code>平滑性条件1</code>：认为平滑后的点，越接近直线越平滑。</p>
<img src="images/image-20220804100524106.png" alt="image-20220804100524106" style="zoom:33%;" />

<p>如图，假设$p_0’,p_1’,p_2’$为平滑后的点，即认为$\left | \vec{p_1’p_3’} \right |$长度越短，越平滑</p>
<p><code>平滑性条件2</code>：认为越接近原有的几何形状越好</p>
<img src="images/image-20220803090023251.png" alt="image-20220803090023251" style="zoom: 67%;" />

<p>如上图所示，$p_0,p_1,p_2$为平滑之前的点，$p_0’,p_1’,p_2’$为平滑后的点。即$\left | p_0p_0’ \right | + \left | p_1p_1’ \right | + \left | p_2p_2’ \right | $越小越平滑</p>
<p><code>平滑性条件3</code>:平滑后的每两个点之间的长度，尽可能的均匀和紧凑。</p>
<img src="images/image-20220804101056813.png" alt="image-20220804101056813" style="zoom:33%;" />

<p>如图所示，$p_0’,p_1’,p_2’$为平滑之后的均匀点，$p_0’’,p_1’’,p_2’’$是平滑之后的点。假设三个点之间的总长度为2a，</p>
<p>则有$\left | p_0’p_1’ \right | &#x3D; \left | p_1’p_2’ \right | &#x3D; a$，计算平方和可知：$\left | p_0’p_1’ \right | ^2 + \left | p_1’p_2’ \right |^2 &#x3D; 2a^2$</p>
<p>假设$\left | p_0’p_1’ \right | &#x3D; \left | p_1’p_2’ \right | &#x3D; a$，则$\left | p_1’’p_2’’ \right | &#x3D; a + b$。计算平方和可知：$\left | p_0’’p_1’’ \right | ^2 + \left | p_1’’p_2’’ \right |^2 &#x3D; 2a^2 + 2b^2$</p>
<p>结论：$\left | p_0p_1 \right | ^2 + \left | p_1p_2 \right |^2$越小，平滑后的每两个点之间越均匀、紧凑。</p>
<p>综合<code>平滑性条件1,2,3</code>，假设平滑之前的点为$p_0,p_1,p_2$(已知点),平滑后的点为$p_0’,p_1’,p_2’$可得出如下<code>cost function J</code></p>
<img src="images/image-20220805091614894.png" alt="image-20220805091614894" style="zoom: 33%;" />
$$
J = w1[(x_0'+x_2'-2x_1')^2+(y_0'+y_2'-2y_1')^2] + w2\sum_{i=0}^{2}[(x_i-x_i')^2+(y_i-y_i')^2] + w3 \sum_{i=0}^{1}[(x_{i+1}'-x_i')^2+(y_{i+1}'-y_i')^2]
$$
$w1,w2,w3$分别为`平滑条件123`的权重系数。代价函数最小的路径，即为平滑的路径。

<p><strong>如何求解这个优化问题？</strong></p>
<p>（1）将求解最小代价函数问题（优化问题）转成二次规划问题</p>
<h4 id="2-3-Hybird-A"><a href="#2-3-Hybird-A" class="headerlink" title="2.3 Hybird A*"></a>2.3 Hybird A*</h4><h5 id="2-3-1-简介"><a href="#2-3-1-简介" class="headerlink" title="2.3.1 简介"></a>2.3.1 简介</h5><h5 id="2-3-2-启发函数-Heuristic-function"><a href="#2-3-2-启发函数-Heuristic-function" class="headerlink" title="2.3.2 启发函数 Heuristic function"></a>2.3.2 启发函数 Heuristic function</h5><h4 id="2-4-em-planner"><a href="#2-4-em-planner" class="headerlink" title="2.4 em planner"></a>2.4 em planner</h4><h5 id="2-4-1-简介"><a href="#2-4-1-简介" class="headerlink" title="2.4.1 简介"></a>2.4.1 简介</h5><p>EM Planner是Apollo面向L4的实时运动规划算法，该算法首先通过顶层多车道策略，选择出一条参考路径，再根据这条参考线，在Frenet坐标系下，进行车道级的路径和速度规划，规划主要通过Dynamic Programming和基于样条的Quadratic Programming实现。</p>
<p>EM Planner充分考虑了无人车安全性、舒适性、可扩展性的需求，通过考虑交通规则、障碍物决策、轨迹光滑性等要求，可适应高速公路、低速城区场景的规划需求。</p>
<img src="images/em planner.png" alt="em planner" style="zoom:67%;" />

<p>说明：</p>
<ol>
<li><code>Reference Line Generator</code>的输入是高精地图和<code>Routing</code>模块给出的全局路径规划的结果，输出是包含障碍物和交通规划的多条参考线。</li>
<li>通过给定参考线，将自车和环境信息投影到参考线下的<code>Frenet</code>坐标系中</li>
<li>接下来所有的车道级信息将会传递给车道级最优求解器，该求解器会求解最优路径和最优速度。在求解最优路径时，周围环境信息将会被投影到Frenet坐标系（E-step），然后基于投影的信息生成一条光滑路径（M-step）</li>
<li>同样的，在求解最优速度时，一旦生成了一条最优路径，障碍物就会被投影到ST图中（E-step），然后最优速度求解器会生成一条光滑的速度规划（M-step）。结合路径和速度规划结果，就生成了一条给定车道的光滑轨迹。</li>
<li>最后一步会将所有的车道级轨迹传递给参考线轨迹决策器，基于当前车辆状态、相关约束和每条轨迹的代价，轨迹决策器会决定一条最优的轨迹。</li>
</ol>
<p>具体说来，针对单个车道级的EM Planner的框架如下：<br>![em planner2](images&#x2F;em planner2.png)</p>
<p>说明：</p>
<ol>
<li>在路径E-step中，障碍物会被投影到车道Frenet坐标系，障碍物包括了静态障碍物和动态障碍物。静态障碍物会直接从笛卡尔坐标系转换到Frenet坐标系，而动态的信息则以其运动轨迹来描述。通过上一帧的预测信息，和自车的运动信息，可以估算自车和动态障碍物在每个时间点的交互情况，轨迹重叠的部分会被映射到Frenet坐标系中。除此之外，在最优路径求解过程中，动态障碍物的出现会最终导致自车做出避让的决策。因此，出于安全的考虑，SL投影只考虑低速和对向障碍物，而对于高速的动态障碍物，EM Planner的平行变道策略会考虑这种情景。</li>
<li>在速度E-step，所有的障碍物都会在ST图中与生成的速度信息进行估计，如果对应的ST中重叠部分，那么对应区域将会在ST中进行重新生成。</li>
<li>在两次M-step过程中，通过Dynamic Programming和Quadratic Programming生成路径和速度规划。然而在进行投影的SL和ST坐标内求解是非凸的。为了解决这个非凸问题，首先使用Dynamic Programming获得一个粗略的解，同时这个解也能够提供诸如避让、减速、超车的决策。通过这个粗略的解，可以构建一个凸的通道，然后使用基于Quadratic Programming的样条最优求解。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://longfei1995.github.io/2024/01/01/self_driving/End-to-End/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡云浩">
      <meta itemprop="description" content="记录生活，记录工作，记录学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="胡云浩的blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/01/self_driving/End-to-End/" class="post-title-link" itemprop="url">端到端自动驾驶</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-01-01T00:00:00+08:00">2024-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-10 17:12:08" itemprop="dateModified" datetime="2025-04-10T17:12:08+08:00">2025-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AB%AF%E5%88%B0%E7%AB%AF%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/" itemprop="url" rel="index"><span itemprop="name">端到端自动驾驶</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1-综述"><a href="#1-综述" class="headerlink" title="1 综述"></a>1 综述</h4><h5 id="1-1-分类"><a href="#1-1-分类" class="headerlink" title="1.1 分类"></a>1.1 分类</h5><p>端到端的学习常用到模仿学习和强化学习。</p>
<p>**模仿学习：*<em>其优化策略是通过学习一个策略$\pi ^{</em>} $来模仿专家的策略$\pi _{E}$。好处在于可以快速的学习人类专家的知识，缺点在于对专家的错误演示敏感且难以探索新的策略。</p>
<p>模仿学习（imitation learning）可以分为以下几类</p>
<ul>
<li>行为克隆（behavior clone）</li>
<li>逆强化学习 （inverse reinforcement learning）</li>
</ul>
<p>**强化学习：**最大化累积奖励。好处在于可以处理没见过的场景，缺点在于有安全隐患。</p>
<p>强化学习（Reinforcement learning）可以分为以下几类</p>
<ul>
<li>价值基RL</li>
<li>策略基RL</li>
<li>演员-评论家RL</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://longfei1995.github.io/2024/01/01/IDE/vscode/vscode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡云浩">
      <meta itemprop="description" content="记录生活，记录工作，记录学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="胡云浩的blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/01/IDE/vscode/vscode/" class="post-title-link" itemprop="url">vscode</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-01-01T00:00:00+08:00">2024-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-10 17:16:38" itemprop="dateModified" datetime="2025-04-10T17:16:38+08:00">2025-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vscode/" itemprop="url" rel="index"><span itemprop="name">vscode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="setting-json"><a href="#setting-json" class="headerlink" title="setting.json"></a>setting.json</h4><h5 id="1-windows-下的设置"><a href="#1-windows-下的设置" class="headerlink" title="1. windows 下的设置"></a>1. windows 下的设置</h5><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>    <span class="comment">// 仅适用于 Windows 的特定设置</span></span><br><span class="line">    <span class="attr">&quot;cmake.cmakePath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\msys64\\mingw64\\bin\\cmake.exe&quot;</span><span class="punctuation">,</span>   <span class="comment">// cmake的路径</span></span><br><span class="line">    <span class="attr">&quot;cmake.additionalCompilerSearchDirs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;C:\\msys64\\mingw64\\bin&quot;</span>                              <span class="comment">// 编译器搜索目录</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cmake.configureEnvironment&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;CMAKE_PREFIX_PATH&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\Qt\\Qt5.12.12\\5.12.12\\mingw73_64\\&quot;</span> <span class="comment">// cmake配置环境</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cmake.toolchain&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;compiler&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gcc&quot;</span><span class="punctuation">,</span>      <span class="comment">// 编译器</span></span><br><span class="line">        <span class="attr">&quot;abi&quot;</span><span class="punctuation">:</span> <span class="string">&quot;g++&quot;</span><span class="punctuation">,</span>           <span class="comment">// 二进制接口</span></span><br><span class="line">        <span class="attr">&quot;stdlib&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gnu++11&quot;</span><span class="punctuation">,</span>    <span class="comment">// 标准库</span></span><br><span class="line">        <span class="attr">&quot;os&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Windows&quot;</span>         <span class="comment">// 操作系统</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="2-linux-下的设置"><a href="#2-linux-下的设置" class="headerlink" title="2. linux 下的设置"></a>2. linux 下的设置</h5><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// &quot;cmake.sourceDirectory&quot;: &quot;/home/hyh/coder/gac_gerrit_http/AppAPAPlaning/QPlan/qt&quot;,</span></span><br><span class="line">    <span class="attr">&quot;cmake.sourceDirectory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/hyh/coder/gac_gerrit_http/AppAPAPlaning/QPlan/x9u_a02/communication_frame&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cmake.configureArgs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;-DCROSS_COMPILE_MACRO=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;-DCMAKE_BUILD_TYPE=Debug&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://longfei1995.github.io/2024/01/01/other_tools/gitNote/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡云浩">
      <meta itemprop="description" content="记录生活，记录工作，记录学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="胡云浩的blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/01/other_tools/gitNote/" class="post-title-link" itemprop="url">git笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-01-01T00:00:00+08:00">2024-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-10 17:05:06" itemprop="dateModified" datetime="2025-04-10T17:05:06+08:00">2025-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/git/" itemprop="url" rel="index"><span itemprop="name">git</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1-仓库的创建"><a href="#1-仓库的创建" class="headerlink" title="1 仓库的创建"></a>1 仓库的创建</h4><p>添加git的用户名和邮箱：<code> git config --global user.name &quot;Your Name&quot;</code> &amp;&amp; <code>git config --global user.email &quot;email@example.com&quot;</code></p>
<p>初始化git仓库：<code>git init</code></p>
<p>添加文件到git：<code>git add &lt;filename&gt; </code>添加单一文件</p>
<p> <code>git add *.cpp</code>添加所有.cpp文件</p>
<p> <code>git add .</code>（添加所有更改了的文件）</p>
<p>提交到本地仓库：<code>git commit -m &quot;message&quot;</code></p>
<p>查看仓库状态：<code>git status</code></p>
<h5 id="1-1-添加-gitignore"><a href="#1-1-添加-gitignore" class="headerlink" title="1.1 添加.gitignore"></a>1.1 添加.gitignore</h5><p>创建<code>.gitignore</code>：如果不希望文件被git追踪的话，可以在根目录下（注意不是.git下）创建名为<code>.gitignore</code>的文件，文件的模板如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># dir </span><br><span class="line">/build # 忽略根目录下的build文件夹以及子文件夹中的文件</span><br><span class="line">build/  # 忽略所有目录下的build文件夹以及子文件夹</span><br><span class="line"></span><br><span class="line"># file </span><br><span class="line">config.ini #忽略所有目录下的config.ini文件</span><br><span class="line"></span><br><span class="line"># log </span><br><span class="line">/*.log # 忽略根目录下的所有尾缀为.log的文件</span><br><span class="line"></span><br><span class="line"># 忽略结尾为.o和.a的文件。</span><br><span class="line">*.[oa]</span><br></pre></td></tr></table></figure>

<p>p.s:<code>*.[oa]</code>这种写法叫glob模式，具体介绍可见<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93">Git - 记录每次更新到仓库 (git-scm.com)</a></p>
<p>如果文件已经被git追踪，还想要忽略的话，执行命令<code>git rm --cached &lt;file&gt;</code>或者<code>git rm -r --cached &lt;dir&gt;</code>来取消对文件或者文件夹的追踪。</p>
<h5 id="1-2-添加-gitattributes"><a href="#1-2-添加-gitattributes" class="headerlink" title="1.2 添加.gitattributes"></a>1.2 添加.gitattributes</h5><p><code>.gitattributes</code>文件允许你指定文件和路径的属性，每当有文件保存或者创建时，git都会用指定的属性来保存这个文件。</p>
<ul>
<li>其中有个属性是<code>eol(end of line)</code>，用与配置文件的末尾行。比如<code>windows</code>上默认的末尾行是<code>回车换行(Carriage Return Line Feed,CRLF)</code>，而<code>linux/MacOS</code>上则是<code>换行(Line Feed, LF)</code>。</li>
</ul>
<p>那么如何添加这个属性呢，我们可以在根目录上创建<code>.gitattributes</code>文件，下面是该文件的样例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*.sh 	eol=lf</span><br><span class="line">*.json	eol=lf</span><br><span class="line">*.jsx	eol=lf</span><br></pre></td></tr></table></figure>

<p>如果是新的git仓库，那么提交这个文件即可。如果是将<code>.gitattributes</code>添加到已有的git仓库，那么执行如下命令即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 将文件从暂存区中删除（仅仅从git跟踪单中删除该文件），磁盘上该文件还是存在</span><br><span class="line">git rm -r --cached .</span><br><span class="line">git reset --hard</span><br></pre></td></tr></table></figure>

<p>上面的命令就会根据文件 <code>.gitattributes</code> 中的定义，更新文件的结尾行。</p>
<h4 id="2-版本管理"><a href="#2-版本管理" class="headerlink" title="2 版本管理"></a>2 版本管理</h4><h5 id="2-1-reset到指定commit-id"><a href="#2-1-reset到指定commit-id" class="headerlink" title="2.1 reset到指定commit id"></a>2.1 reset到指定commit id</h5><p>共同的作用：都是将当前HEAD指针指向某个commit id。</p>
<ul>
<li><p>git reset –soft <commit-id></p>
<p>将现在所有工作区和staged区的内容都放到staged区<br>适用场景：想合并几个 commit 或者 想修改最近的 commit 信息</p>
</li>
<li><p>git reset –mixed <commit-id></p>
</li>
<li><p>git reset –hard <commit-id></p>
</li>
</ul>
<h5 id="2-3-远程仓库管理"><a href="#2-3-远程仓库管理" class="headerlink" title="2.3 远程仓库管理"></a>2.3 远程仓库管理</h5><p><strong>1.已有远程仓库</strong></p>
<p>克隆远程仓库：<code>git clone &lt;仓库地址&gt;</code></p>
<p>克隆远程仓库的指定分支：<code>git clone -b &lt;远程分支名&gt; &lt;仓库地址&gt;</code></p>
<p>本地已经有远程仓库的一个分支，想要克隆其它分支：<code>git checkout -t &lt;远程分支名&gt;</code></p>
<p> <strong>2.已有本地仓库</strong></p>
<p>将本地仓库关联到远程仓库：<code>git remote add &lt;远程仓库名&gt; &lt;远程仓库地址&gt;</code>,例<code>git remote add gitee git@gitee.com:xx/xx</code></p>
<p>建立本地分支和远程分支的联系：新版本<code>git branch --set-upstream-to=&lt;远程仓库名&gt;/&lt;远程分支名&gt; &lt;本地分支名&gt;</code>，旧版本<code>git branch --set-upstream &lt;本地分支名&gt; &lt;远程仓库名&gt;/&lt;远程分支名&gt;</code></p>
<p>查看远程仓库信息：<code>git remote -v</code><br>将本地仓库推送到远程仓库origin的指定分支master：<code>git push origin master</code>，强制推送<code>git push -f origin master</code></p>
<h4 id="3-git分支操作"><a href="#3-git分支操作" class="headerlink" title="3 git分支操作"></a>3 git分支操作</h4><h5 id="3-1-基础操作"><a href="#3-1-基础操作" class="headerlink" title="3.1 基础操作"></a>3.1 基础操作</h5><p><em>对于所有分支而言，工作区和暂存区都是公用的，所以在其它分支工作时，务必git add &amp;&amp; git commit，然后再进行分支切换操作</em></p>
<p>查看分支：查看本地分支<code>git branch</code>，查看远程分支<code>git branch -r</code>，查看所有分支<code>git branch -a</code></p>
<p>创建分支：<code>git branch &lt;branchName&gt;</code></p>
<p>切换分支：老版本<code>git checkout &lt;branchName&gt;</code>，新版本<code>git switch &lt;branchName&gt;</code></p>
<p>创建+切换分支：老版本<code>git checkout -b &lt;branchName&gt;</code>，新版本<code>git switch -c &lt;branchName&gt;</code></p>
<p>从远端创建分支：<code>git switch -c &lt;name&gt; &lt;remote/name&gt;</code></p>
<p>合并某分支到当前分支：在当前分支下，<code>git merge &lt;某分支名&gt;</code></p>
<p>删除分支：<code>git branch -d &lt;name&gt;</code></p>
<p>删除远端分支：<code>git push origin --delete &lt;远程分支名&gt;</code></p>
<h5 id="3-2-进阶操作"><a href="#3-2-进阶操作" class="headerlink" title="3.2 进阶操作"></a>3.2 进阶操作</h5><p>保存当前分支的工作现场：<code>git stash</code></p>
<p>恢复现场：先用<code>git stash list</code>查看保存的现场。然后用<code>git stash pop</code>恢复现场，或者用<code>git stash apply &lt;stash list中指定的内容&gt;</code></p>
<p>复制特定的提交到当前分支：<code>git cherry-pick &lt;commit-id&gt;</code></p>
<h5 id="3-3-多人如何协作开发"><a href="#3-3-多人如何协作开发" class="headerlink" title="3.3 多人如何协作开发"></a>3.3 多人如何协作开发</h5><p>多人协作的工作模式通常是这样：</p>
<ol>
<li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li>
<li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li>
<li>如果合并有冲突，则解决冲突，并在本地提交（git add &amp;&amp; git commit)；</li>
<li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li>
</ol>
<h4 id="4-git分模块管理"><a href="#4-git分模块管理" class="headerlink" title="4 git分模块管理"></a>4 git分模块管理</h4><h5 id="4-1-库的克隆"><a href="#4-1-库的克隆" class="headerlink" title="4.1 库的克隆"></a>4.1 库的克隆</h5><p>方法1：</p>
<ol>
<li><p>先克隆主项目，<code>git clone &lt;父项目仓库地址&gt;</code></p>
<p>ps:这个命令不会clone子仓库的文件，只会克隆<code>.gitmodule</code>描述文件，需要执行下面的命令拉取仓库文件。</p>
</li>
<li><p>然后在主项目根目录下执行<code>git submodule init</code>,初始化本地子项目的配置</p>
</li>
<li><p>最后拉取子项目的文件，<code>git submodule update</code>			ps:此命令后，子模块只是拉取的“主项目对子模块引用的那个HEAD”，如果想要子模块更新到子模块仓库的最新版本，还需要在子模块目录中执行<code>git pull origin master</code></p>
</li>
</ol>
<p>方法2：</p>
<p>克隆主项目时，递归拉取子项目代码，<code>git clone &lt;主项目url&gt; --recurse-submodules</code>。</p>
<p>ps:这样拉取的子项目，只有子项目的文件夹，而没有子项目的具体代码。因此，还需分别进入各子项目文件夹，执行<code>git pull origin master</code></p>
<h5 id="4-2-库的拉取和推送"><a href="#4-2-库的拉取和推送" class="headerlink" title="4.2 库的拉取和推送"></a>4.2 库的拉取和推送</h5><p>主项目的拉取和推送：和正常库一样即可</p>
<p>子项目拉取：<strong>进入子项目文件夹中</strong>，<code>git pull origin master</code><br>子项目推送：<strong>进入子项目文件夹中</strong>，<code>git push origin HEAD:master</code>,ps:子模块push后，主项目对子模块的引用还没有更新，如果想更新的话。</p>
<p>先<code>git add &lt;子模块文件夹名&gt;</code>，再<code>git commit -m &quot;msg&quot;</code>，然后<code>git push</code></p>
<h5 id="4-3-创建子模块库"><a href="#4-3-创建子模块库" class="headerlink" title="4.3 创建子模块库"></a>4.3 创建子模块库</h5><p>先进入父仓库的目录下，执行命令<code>git submodule add &lt;子模块仓库地址&gt; &lt;本地路径&gt;</code></p>
<p>其中本地路径是可选的，默认情况下，子模块会添加在当前目录下面。如果指定了路径，则会把子项目放到指定的本地路径下。执行上面命令后，父仓库的<code>.gitmodule</code>文件会添加如下内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[submodule  仓库名称]</span><br><span class="line">    path = 仓库名称（或指定的本地路径）</span><br><span class="line">    url = 仓库地址</span><br></pre></td></tr></table></figure>

<h4 id="5-标签管理"><a href="#5-标签管理" class="headerlink" title="5 标签管理"></a>5 标签管理</h4><h5 id="5-1-简述"><a href="#5-1-简述" class="headerlink" title="5.1 简述"></a>5.1 简述</h5><p>tag的作用：在发布一个版本的时候，我们通常会在版本库中打一个标签(tag)，将来无论什么时候，我们可以取这个标签对应的历史版本。相当于版本库的快照，和commit id很像。</p>
<p>tag的实质：其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p>
<p>有了commit id后为什么还要tag?</p>
<p>“请把上周一的那个版本打包发布，commit号是6a5819e…”</p>
<p>“一串乱七八糟的数字不好找！”</p>
<p>如果换一个办法：</p>
<p>“请把上周一的那个版本打包发布，版本号是v1.2”</p>
<p>“好的，按照tag v1.2查找commit就行！”</p>
<p>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p>
<h5 id="5-2-tag相关命令"><a href="#5-2-tag相关命令" class="headerlink" title="5.2 tag相关命令"></a>5.2 tag相关命令</h5><ul>
<li>创建tag</li>
</ul>
<p>新建一个tag：<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id来给历史版本打tag <code>git tag &lt;tagname&gt; &lt;commit id&gt;</code></p>
<p>新建一个带有标签信息的tag：<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息</p>
<ul>
<li>查看tag</li>
</ul>
<p>查看所有标签：<code>git tag</code></p>
<p>查看指定标签的详细信息：<code>git show &lt;tagname&gt;</code></p>
<ul>
<li>删除tag</li>
</ul>
<p>删除本地tag：<code>git tag -d &lt;tagname&gt;</code></p>
<p>删除远程tag，删除命令也是push：先删除本地tag，然后<code>git push origin :refs/tags/&lt;tagname&gt;</code></p>
<ul>
<li>推送tag</li>
</ul>
<p>推送一个tag：<code>git push origin &lt;tagname&gt;</code></p>
<p>推送本地所有的tag：<code>git push origin --tags</code></p>
<ul>
<li>切换到指定的tag</li>
</ul>
<p>如果直接将当前的分支，切换到某个tag是不安全的，git会提示”detached HEAD”，也就是当前的HEAD指针移动到了tag分支处，有可能丢失tag之后的commit。</p>
<p>我们可以新建一个基于某个tag的分支：<code>git switch -c &lt;branch name&gt; &lt;tagname&gt;</code>，操作完之后，将这个分支删除即可。</p>
<h6 id=""><a href="#" class="headerlink" title=""></a></h6>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">胡云浩</p>
  <div class="site-description" itemprop="description">记录生活，记录工作，记录学习</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">52</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">胡云浩</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
