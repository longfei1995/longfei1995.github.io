<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"longfei1995.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="self-driving1 控制算法1.1 基础知识1.1.1 三个坐标系首先，我们来介绍一下横纵向控制的流程 纵向控制：油门&#x2F;刹车–&gt;力–&gt;加速度–&gt;速度–&gt;位置 横向控制：方向盘转角–&gt;车轮转角–&gt;横向位移&#x2F;航向位移  1.1.2 一些物理量的定义图1  1.2 车辆模型1.2.1 运动学模型假设车辆作平面运动，需要3个坐标值来描述车辆的">
<meta property="og:type" content="article">
<meta property="og:title" content="自动驾驶控制算法">
<meta property="og:url" content="https://longfei1995.github.io/2024/01/01/self_driving/self-drivingNote%20/index.html">
<meta property="og:site_name" content="胡云浩的blog">
<meta property="og:description" content="self-driving1 控制算法1.1 基础知识1.1.1 三个坐标系首先，我们来介绍一下横纵向控制的流程 纵向控制：油门&#x2F;刹车–&gt;力–&gt;加速度–&gt;速度–&gt;位置 横向控制：方向盘转角–&gt;车轮转角–&gt;横向位移&#x2F;航向位移  1.1.2 一些物理量的定义图1  1.2 车辆模型1.2.1 运动学模型假设车辆作平面运动，需要3个坐标值来描述车辆的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://longfei1995.github.io/images/1.png">
<meta property="og:image" content="https://longfei1995.github.io/images/2.png">
<meta property="og:image" content="https://longfei1995.github.io/images/1-16393611888181.png">
<meta property="og:image" content="https://longfei1995.github.io/images/2-16395606113832.png">
<meta property="og:image" content="https://longfei1995.github.io/2024/01/01/self_driving/self-drivingNote%20/images/LQR%E6%B5%81%E7%A8%8B%E5%9B%BE-16394695260081.png">
<meta property="og:image" content="https://longfei1995.github.io/images/1-16399808327761.png">
<meta property="og:image" content="c:/Users/HuYunhao/Desktop/2018091917092752.png">
<meta property="og:image" content="https://longfei1995.github.io/2024/01/01/self_driving/self-drivingNote%20/images/image-20211223150116439-16402429099701.png">
<meta property="og:image" content="https://longfei1995.github.io/images/3.png">
<meta property="og:image" content="https://longfei1995.github.io/2024/01/01/self_driving/self-drivingNote%20/images/image-20220524192926814.png">
<meta property="og:image" content="https://longfei1995.github.io/2024/01/01/self_driving/self-drivingNote%20/images/image-20220524193948331.png">
<meta property="og:image" content="https://longfei1995.github.io/2024/01/01/self_driving/self-drivingNote%20/images/image-20220524194437665.png">
<meta property="og:image" content="https://longfei1995.github.io/2024/01/01/self_driving/self-drivingNote%20/images/image-20220524215904173.png">
<meta property="og:image" content="https://longfei1995.github.io/2024/01/01/self_driving/self-drivingNote%20/images/image-20220524220409280.png">
<meta property="og:image" content="https://longfei1995.github.io/images/1-16417968777281.png">
<meta property="og:image" content="https://longfei1995.github.io/2024/01/01/self_driving/self-drivingNote%20/images/image-20220718151502057.png">
<meta property="og:image" content="https://longfei1995.github.io/2024/01/01/self_driving/self-drivingNote%20/images/image-20220720094553623.png">
<meta property="og:image" content="https://longfei1995.github.io/2024/01/01/self_driving/self-drivingNote%20/images/image-20220801152101382.png">
<meta property="og:image" content="https://longfei1995.github.io/2024/01/01/self_driving/self-drivingNote%20/images/image-20220804100524106.png">
<meta property="og:image" content="https://longfei1995.github.io/2024/01/01/self_driving/self-drivingNote%20/images/image-20220803090023251.png">
<meta property="og:image" content="https://longfei1995.github.io/2024/01/01/self_driving/self-drivingNote%20/images/image-20220804101056813.png">
<meta property="og:image" content="https://longfei1995.github.io/2024/01/01/self_driving/self-drivingNote%20/images/image-20220805091614894.png">
<meta property="og:image" content="https://longfei1995.github.io/2024/01/01/self_driving/self-drivingNote%20/images/em%20planner.png">
<meta property="article:published_time" content="2023-12-31T16:00:00.000Z">
<meta property="article:modified_time" content="2025-04-10T09:05:52.340Z">
<meta property="article:author" content="胡云浩">
<meta property="article:tag" content="自动驾驶">
<meta property="article:tag" content="控制算法">
<meta property="article:tag" content="车辆模型">
<meta property="article:tag" content="LQR">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://longfei1995.github.io/images/1.png">

<link rel="canonical" href="https://longfei1995.github.io/2024/01/01/self_driving/self-drivingNote%20/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>自动驾驶控制算法 | 胡云浩的blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">胡云浩的blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">日常笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://longfei1995.github.io/2024/01/01/self_driving/self-drivingNote%20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡云浩">
      <meta itemprop="description" content="记录生活，记录工作，记录学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="胡云浩的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          自动驾驶控制算法
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-01-01T00:00:00+08:00">2024-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-10 17:05:52" itemprop="dateModified" datetime="2025-04-10T17:05:52+08:00">2025-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/" itemprop="url" rel="index"><span itemprop="name">自动驾驶</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="self-driving"><a href="#self-driving" class="headerlink" title="self-driving"></a>self-driving</h2><h3 id="1-控制算法"><a href="#1-控制算法" class="headerlink" title="1 控制算法"></a>1 控制算法</h3><h4 id="1-1-基础知识"><a href="#1-1-基础知识" class="headerlink" title="1.1 基础知识"></a>1.1 基础知识</h4><h5 id="1-1-1-三个坐标系"><a href="#1-1-1-三个坐标系" class="headerlink" title="1.1.1 三个坐标系"></a>1.1.1 三个坐标系</h5><p>首先，我们来介绍一下横纵向控制的流程</p>
<p>纵向控制：油门&#x2F;刹车–&gt;力–&gt;加速度–&gt;速度–&gt;位置</p>
<p>横向控制：方向盘转角–&gt;车轮转角–&gt;横向位移&#x2F;航向位移</p>
<p><img src="/images/1.png"></p>
<h5 id="1-1-2-一些物理量的定义"><a href="#1-1-2-一些物理量的定义" class="headerlink" title="1.1.2 一些物理量的定义"></a>1.1.2 一些物理量的定义</h5><p>图1</p>
<p><img src="/images/2.png"></p>
<h4 id="1-2-车辆模型"><a href="#1-2-车辆模型" class="headerlink" title="1.2 车辆模型"></a>1.2 车辆模型</h4><h5 id="1-2-1-运动学模型"><a href="#1-2-1-运动学模型" class="headerlink" title="1.2.1 运动学模型"></a>1.2.1 运动学模型</h5><p>假设车辆作平面运动，需要3个坐标值来描述车辆的运动$(X, Y, \psi)$<img src="/images/1-16393611888181.png" alt="1"></p>
<p>此时，车辆运动的微分方程可以表示为<br>$$<br>\dot{X} &#x3D; vcos(\psi+\beta) \<br>\dot{Y} &#x3D; vsin(\psi+\beta) \<br>\dot{\psi} &#x3D; \frac{vcos(\beta)}{l_f+l_r}(tan\delta_f-tan\delta_r)<br>$$</p>
<h5 id="1-2-2-车辆动力学模型"><a href="#1-2-2-车辆动力学模型" class="headerlink" title="1.2.2 车辆动力学模型"></a>1.2.2 车辆动力学模型</h5><p>动力学模型的必要性：</p>
<ul>
<li>动力学模型相对于运动学模型来说，考虑了轮胎的特性。</li>
<li>当选取Frenet坐标系（自然坐标系）时，可以将横纵向控制解耦。</li>
<li>高速时，轮胎没法再看成一个刚体，因此运动学模型在高速时不太适用</li>
</ul>
<h6 id="1-2-2-1-跟踪误差变量的状态空间方程"><a href="#1-2-2-1-跟踪误差变量的状态空间方程" class="headerlink" title="1.2.2.1 跟踪误差变量的状态空间方程"></a>1.2.2.1 跟踪误差变量的状态空间方程</h6><p>我们定义误差向量$x &#x3D; [e_1, \dot{e_1}, e_2, \dot{e_2}]^t$，其中e1为横向误差，e2为航向误差。则误差变量的状态方程经过推导可以写成$\dot{x} &#x3D; Ax+Bu+C\dot{\psi_{des}}$。$\dot{\psi_{des}}$是道路参考点的横摆角速度。</p>
<p>其中A矩阵定义为<br>$$<br>\left[\begin{array}{cccc}<br>0 &amp; 1 &amp; 0 &amp; 0 \<br>0 &amp; -\frac{2 C_{\alpha f}+2 C_{\alpha r}}{m v_{x}} &amp; \frac{2 C_{\alpha f}+2 C_{\alpha r}}{m} &amp; \frac{-2 C_{\alpha d} l_{f}+2 C_{\alpha r} l_{r}}{m v_{x}} \<br>0 &amp; 0 &amp; 0 &amp; 1 \<br>0 &amp; -\frac{2 C_{\alpha f} l_{f}-2 C_{\alpha r} l_{r}}{I_{z} v_{x}} &amp; \frac{2 C_{\alpha f} l_{f}-2 C_{\alpha r} l_{r}}{I_{z}} &amp; -\frac{2 C_{\alpha f} l_{f}^{2}+2 C_{\alpha r} l_{r}^{2}}{I_{z} v_{x}}<br>\end{array}\right]<br>$$<br>B矩阵定义为<br>$$<br>\left[\begin{array}{c}<br>0 \<br>\frac{2 C_{\alpha f}}{m} \<br>0 \<br>\frac{2 C_{\alpha f} l_{f}}{I_{z}}<br>\end{array}\right]<br>$$<br>C矩阵定义为<br>$$<br>\begin{bmatrix}<br> 0\<br> -\frac{C_{\alpha f}l_f-2C_{\alpha r}l_r}{mv_x}-v_x \<br> 0\<br>-\frac{2C_{\alpha f}l_f^2+2C_{\alpha r}l_r^2}{I_zv_x}<br>\end{bmatrix}<br>$$<br>其中m是车辆总质量[kg]，$v_x$是车辆质心处的纵向速度[m&#x2F;s^2]，$l_f&#x2F;l_r$是车辆质心到前&#x2F;后轴的距离[m]，Iz是车辆横摆转动惯量[kg*m^2]，$C_{\alpha f}&#x2F;C_{\alpha r}$分别为前后轮侧偏刚度[N&#x2F;rad]</p>
<h5 id="1-2-3-路径偏差的计算"><a href="#1-2-3-路径偏差的计算" class="headerlink" title="1.2.3 路径偏差的计算"></a>1.2.3 路径偏差的计算</h5><h6 id="1-2-3-1-计算投影点的速度大小和横向偏差对时间的导数"><a href="#1-2-3-1-计算投影点的速度大小和横向偏差对时间的导数" class="headerlink" title="1.2.3.1 计算投影点的速度大小和横向偏差对时间的导数"></a>1.2.3.1 计算投影点的速度大小和横向偏差对时间的导数</h6><p>如图所示，我们以车辆质心c为圆心，以质心速度为$\tau$方向建立Frenet坐标系，并且将车辆质心投影到规划轨迹上，投影点为r。质心处的位矢为$\vec{x}$，投影点的位矢为$\vec{x_r}$。$\theta$为车辆的航向角，$\theta_r$为投影点的切线角。</p>
<p>p.s:Frenet坐标系的基向量为单位向量，若$\tau$与直角坐标系x轴成$\theta$角。那么有如下结论<br>$$<br>\vec{\tau} &#x3D; [cos\theta, sin\theta]^T \<br>\vec{n} &#x3D; [-sin\theta, cos\theta]^T \<br>\frac{d\vec{\tau}}{ds} &#x3D; k\vec{n} \<br>\frac{d\vec{n}}{ds} &#x3D; -k\vec{\tau} \<br>$$<br>其中，k是坐标点处的曲率。</p>
<p>![](images&#x2F;屏幕截图 2021-12-15 115616.png)</p>
<p>从图中可知，横向误差d是c, r两点之间的距离；航向误差&#x3D;$\theta-\theta_r$；记投影点的速度大小为$\left | \vec{v_r} \right | $。</p>
<p>根据向量的平行四边形法则，我们容易得出$d\vec{n_r}&#x3D;\vec{x}-\vec{x_r}$，等号两边同时右乘$\vec{n_r}$，可以得到$d &#x3D; (\vec{x}-\vec{x_r})\cdot\vec{n_r}$。根据复合求导法则有，$\dot{d} &#x3D;( \vec{\dot{x}}-\vec{\dot{x_r}})\cdot\vec{n_r}+(\vec{x}-\vec{x_r})\cdot\vec{\dot{n_r}}$。</p>
<p>根据大学物理中，位矢的导数的意义，我们可以知道：<br>$$<br>\vec{\dot{x}} &#x3D; \left | \vec{v} \right | \vec{\tau} \<br>\vec{\dot{x_r}} &#x3D; \left | \vec{v_r} \right | \vec{\tau_r}<br>$$<br>将其代入$\dot{d}$的表达式，我们可以得出：<br>$$<br>\dot{d} &#x3D;  \left | \vec{v} \right | *cos&lt;\vec{\tau},\vec{n_r}&gt; \<br>根据示意图，我们可以得知\vec{\tau}与\vec{n_r}的夹角为:\pi&#x2F;2-(\theta-\theta_r) \<br>故，\dot{d} &#x3D; \left | \vec{v} \right |*sin(\theta-\theta_r)<br>$$<br>接下来，我们来求投影点的速度大小$\left | \vec{v_r} \right |$。<br>$$<br>根据平行四边形法则有:\vec{x_r}+d\vec{n_r}&#x3D;\vec{x} \<br>对等号两边求导:\vec{\dot{x_r}}+\dot{d}\vec{n_r}+d\vec{\dot{n_r}}&#x3D;\vec{\dot{x}} \<br>代入前面的内容，可知 \<br>\left | \vec{v_r} \right | &#x3D; \frac{\left | \vec{v} \right |*cos(\theta-\theta_r)}{1-k_rd}<br>$$<br>其中$k_r$是投影点的曲率。</p>
<h6 id="1-2-3-2-计算误差向量x"><a href="#1-2-3-2-计算误差向量x" class="headerlink" title="1.2.3.2 计算误差向量x"></a>1.2.3.2 计算误差向量x</h6><p>我们定义误差向量$x&#x3D;[e_1, \dot{e_1}, e_2, \dot{e_2}]$，$e_1$为横向偏差，$\dot{e_1}$为横向偏差率，$e_2$为横摆角偏差，$\dot{e_2}$为横摆角偏差率。</p>
<p>根据1.2.3.1所讲，$x$的计算可写成<br>$$<br>e_1 &#x3D; d &#x3D; (\vec{x}-\vec{x_r})\cdot\vec{n_r} \<br>\dot{e_1} &#x3D; \dot{d} &#x3D; \left | \vec{v} \right |<em>sin(\theta-\theta_r) \<br>e_2 &#x3D; \phi-\theta_r \<br>\dot{e_2} &#x3D; \dot{\phi}-\dot{\theta_r} &#x3D; \dot{\phi} - k_r</em>\left | \vec{v_r} \right |<br>$$<br>其中，$\dot{\theta_r} &#x3D; k_r * \left | \vec{v_r} \right |$是由曲率的定义公式推导而来的。</p>
<p>**但在离散规划轨迹中，投影点往往与规划的离散点不重合。**我们可以计算出离散轨迹点中离车辆位置$\vec{x}&#x3D;[x,y]$最近的点，这个点在Apollo中称为匹配点（match_point）。然后用匹配点代替投影点来计算误差向量$x$。</p>
<p><img src="/images/2-16395606113832.png" alt="2"></p>
<p>如图上图所示，m点为规划路径上搜索到的最近点。我们有一点假设：m点的曲率$k_m$与投影点的曲率$k_r$相等。然后我们借助最近点m来计算误差向量x。</p>
<p>根据Frenet坐标系的定义，我们可知</p>
<p>$\vec{\tau_m}&#x3D;[cos\theta_m,sin\theta_m]$，$\vec{n_m}&#x3D;[-sin\theta_m,cos\theta_m]$</p>
<p>我们用cm两点之间的距离在$\vec{n_m}$上的投影来近似横向误差$e_1$，在$\vec{\tau_m}$上的投影来近似纵向误差（在横向控制中用不到）。</p>
<p>可得：<br>$$<br>e_1 \approx (\vec{x}-\vec{x_m})\cdot\vec{n_m} &#x3D;<br>(x-x_m)*(-sin\theta_m)+(y-y_m)<em>cos\theta_m \<br>纵向误差 &#x3D; e_s \approx (\vec{x}-\vec{x_m})\cdot\vec{\tau_m} &#x3D;<br>(x-x_m)</em>(cos\theta_m)+(y-y_m)<em>sin\theta_m \<br>$$<br>基于前面的假设，我们将可知$kr &#x3D; k_m$。根据下图，也可以计算出$\theta_r &#x3D; \theta_m+k_m</em>e_s$。在Apollo中，他们认为$\theta_r &#x3D; \theta_m$。两者均可。</p>
<p>![屏幕截图 2021-12-15 175126](images&#x2F;屏幕截图 2021-12-15 175126-16395620076083.png)</p>
<p>因此，根据本节开头提到的公式。我们就可以得到误差向量x的表达式。</p>
<h4 id="1-3-横向控制算法-LQR"><a href="#1-3-横向控制算法-LQR" class="headerlink" title="1.3 横向控制算法-LQR"></a>1.3 横向控制算法-LQR</h4><h5 id="1-3-1-LQR控制"><a href="#1-3-1-LQR控制" class="headerlink" title="1.3.1 LQR控制"></a>1.3.1 LQR控制</h5><p>LQR（Linear Quadratic Regulator）线性二次型调节器是常用的最优化控制算法的一种。LQR是针对线性系统的，其Cost Function（目标函数）J是状态变量和控制变量的二次型函数。LQR分为离散型和连续型。实际工程应用大多为离散LQR，并且连续型LQR相对比较难，所以这里只对离散LQR进行讨论。</p>
<p>接下来，我们将按步骤实现离散LQR，作为反馈控制（feed-back control）u&#x3D;-Kx。</p>
<p><strong>1.建立路面误差状态空间方程，作为LQR目标函数的约束</strong></p>
<p>我们在前面1.2.2中已经建立好了，我们忽略掉$C\psi_{des}$项，可以将路面误差状态方程（约束）写为：$\dot{x}(t) &#x3D; Ax(t)+Bu(t)$</p>
<p><strong>2.离散化约束方程</strong></p>
<p>在数学分析中，对连续方程的离散化有多种，比如向前欧拉法，中点欧拉法，向后欧拉法等。我们利用向前欧拉法可以将连续化的约束方程转成离散化的约束方程<br>$$<br>x(t+dt) &#x3D; (I + A<em>dt)x(t)+B</em>dt<em>u(t) \<br>即x_{t+1} &#x3D; \bar{A}x_t+\bar{B}x_t<br>$$<br>也就是说，离散化后的矩阵$\bar{A} &#x3D; A</em>dt+I$，矩阵$\bar{B}&#x3D;B*dt$</p>
<p>其中I为单位矩阵，dt是控制的循环周期，如dt &#x3D; 0.01s。</p>
<p>对于我们的横向控制来说$\bar{A}$是一个4x4的矩阵，$\bar{B}$是一个4x1的矩阵</p>
<p><strong>3.设计适合的参数矩阵Q和R</strong></p>
<p>Q矩阵是状态权重矩阵，它的行数&#x3D;列数&#x3D;状态向量x的维度。它是一个4x4的矩阵。</p>
<p>R矩阵是控制权重矩阵，是一个1x1的矩阵。</p>
<p>刚开始调试时，我们可以将Q矩阵和R矩阵都设置成单位阵，后面再根据控制的效果慢慢调试Q矩阵和R矩阵。</p>
<p><strong>4.迭代求解黎卡提（Riccati）方程，得到：</strong><br>$$<br>P &#x3D; Q+A^TPA-A^TPB(R+B^TPB)^{-1}B^TPA<br>$$<br>当迭代计算的P矩阵的两次差值很小的时候，迭代收敛。P是一个4x4的矩阵。</p>
<p><strong>5.求解反馈控制增益矩阵K</strong><br>$$<br>K &#x3D; (B^TPB+R)^{-1}B^TPA<br>$$<br>是一个1x4的向量</p>
<p><strong>6.求解反馈控制量u(t)</strong><br>$$<br>u(t) &#x3D; \delta(t) &#x3D; -K*x(t)<br>$$<br>x(t)在1.2车辆模型那一节已经计算出来了，在每个控制周期，将x(t)更新即可。</p>
<h5 id="1-3-2-LQR的前馈控制（feed-forward-control）"><a href="#1-3-2-LQR的前馈控制（feed-forward-control）" class="headerlink" title="1.3.2 LQR的前馈控制（feed-forward control）"></a>1.3.2 LQR的前馈控制（feed-forward control）</h5><p><strong>Q1 为什么要引用前馈控制？</strong></p>
<p>**A1：**前面我们已经知道，误差变量的状态空间方程为$\dot{x}&#x3D;Ax+Bu+C\dot{\psi_{des}}$。若只用$u&#x3D;-Kx$进行反馈控制的话，那么此时状态空间方程为$\dot{x}&#x3D;(A-BK)x+C\dot{\psi_{des}}$。从这个微分方程我们可以看出，$\dot{x}$和$x$是不可能同时为0的，因为同时为0的话，方程不成立。而状态空间方程是基于车辆二自由度动力学模型建立的，是一个客观的物理规律，是不可违背的。因此，我们只用反馈控制的话，会存在一个稳态误差。</p>
<p><strong>Q2 什么是稳态误差？</strong></p>
<p>**A2：**详细的定义，请参照“现代控制理论”，在这里，稳态误差是指，$\dot{x}&#x3D;0$而$x\ne0$的现象，也就是说，当系统处于稳定状态时，存在一个恒定的误差值。</p>
<p>我们引入前馈项$\delta_f$来使输入$u&#x3D;-Kx+\delta_f$，借此来消除稳态误差。经过计算（计算过程请参考《车辆动力学及控制_第2版》），$\delta_f$应该取如下值，才能消除横向稳态误差：<br>$$<br>\delta_{\mathrm{ff}}&#x3D;\frac{L}{R}+K_{\mathrm{V}} a_{\mathrm{y}}-k_{3}\left[\frac{l_{\mathrm{r}}}{R}-\frac{l_{\mathrm{f}}}{2 C_{\mathrm{\alpha r}}} \times \frac{m v_{\mathrm{x}}^{2}}{R l}\right]<br>$$<br>其中$K_{\mathrm{V}}&#x3D;\frac{l_{\mathrm{r}} m}{2 C_{\alpha \mathrm{f}}\left(l_{\mathrm{f}}+l_{\mathrm{r}}\right)}-\frac{l_{\mathrm{f}} m}{2 C_{\alpha \mathrm{r}}\left(l_{\mathrm{f}}+l_{\mathrm{r}}\right)}$，称为转向不足梯度。</p>
<p>$ay &#x3D; \frac{v_x^2}{R}$，k3是LQR求出的K向量(1x4)的第三项。</p>
<p>而横摆角稳态误差e2可以推出：<br>$$<br>e2 &#x3D; -\frac{l_r}{R}+\frac{l_f}{2C_{\alpha f}(l_f+l_r)}\times\frac{mv_x^2}{R}<br>$$<br>我们可以看出，e2不受$\delta_f$和K的控制，只与车辆的纵向车速和道路曲率相关，而道路曲率是不可控的，欲使e2为0的话，纵向车速必须取一个确定的值。但是在汽车行驶过程中，我们不可能永远让纵向车速取成恒定的值，因此，e2是一直存在稳态误差的。</p>
<p>幸运的是，经过推算，我们可以得出，稳态误差$e2&#x3D;-\beta$，而航向角误差$e_{\theta}&#x3D;\theta-\theta_{des}&#x3D;\phi+\beta-\theta_{des}&#x3D;\beta+e_2$，故，虽然稳态横摆角误差不为0，但这样恰好导致了稳态航向误差为0，因此，我们不用去管怎么将e2调节为0，因为e2的稳态误差恰好会导致航向角误差$e_{\theta}$为0，这正是我们想要的结果。</p>
<h5 id="1-3-3-LQR算法总结"><a href="#1-3-3-LQR算法总结" class="headerlink" title="1.3.3 LQR算法总结"></a>1.3.3 LQR算法总结</h5><h6 id="1-3-3-1-算法的输入"><a href="#1-3-3-1-算法的输入" class="headerlink" title="1.3.3.1 算法的输入"></a>1.3.3.1 算法的输入</h6><ol>
<li>整车的参数：$l_f,l_r,C_{\alpha f},C_{\alpha r},m,I_z$</li>
<li>车辆的位置与状态：在全局坐标下的$x, y, \phi, v_x, v_y, \dot{\phi}$，其中，如果横摆角速度未给出，也可以根据$\dot{\phi}&#x3D;\frac{v_x}{R}$来计算（这里的R是道路参考点的曲率半径）。</li>
<li>规划的轨迹点：全局坐标下的$x_{des}, y_{des}, \theta_{des}, k_{des}$</li>
</ol>
<h6 id="1-3-3-2-算法的输出"><a href="#1-3-3-2-算法的输出" class="headerlink" title="1.3.3.2 算法的输出"></a>1.3.3.2 算法的输出</h6><p>$u&#x3D;-Kx+\delta_{ff}$</p>
<h6 id="1-3-3-3-算法流程图"><a href="#1-3-3-3-算法流程图" class="headerlink" title="1.3.3.3 算法流程图"></a>1.3.3.3 算法流程图</h6><img src="images/LQR流程图-16394695260081.png" alt="LQR流程图" style="zoom: 200%;" />

<h4 id="1-4-纵向控制"><a href="#1-4-纵向控制" class="headerlink" title="1.4 纵向控制"></a>1.4 纵向控制</h4><p>油门-&gt;发动机功率改变-&gt;发动机转速&#x2F;扭矩改变-&gt;车加速</p>
<p>刹车-&gt;制动压力增大-&gt;制动盘摩擦力增大-&gt;阻力增大-&gt;车减速</p>
<h5 id="1-4-1-发动机扭矩-转速曲线"><a href="#1-4-1-发动机扭矩-转速曲线" class="headerlink" title="1.4.1 发动机扭矩-转速曲线"></a>1.4.1 发动机扭矩-转速曲线</h5><p><img src="/images/1-16399808327761.png"></p>
<p>我们的纵向控制是基于电动车的。因此，做纵向控制，需要标定油门刹车表(v-a-thr&#x2F;v-a-brake)，然后将两表合在一起</p>
<h5 id="1-4-2-双环PID控制"><a href="#1-4-2-双环PID控制" class="headerlink" title="1.4.2 双环PID控制"></a>1.4.2 双环PID控制</h5><h6 id="1-4-2-1-PID简单介绍"><a href="#1-4-2-1-PID简单介绍" class="headerlink" title="1.4.2.1 PID简单介绍"></a>1.4.2.1 PID简单介绍</h6><p>在PID控制中：</p>
<p>P是比例项，可以用来放大误差。加快期望值接近目标值。在仿真中，因为没有延迟，所以不会引起超调，但是在实际控制中，因为延迟的存在，会引起超调；</p>
<p>I是积分项，可以用来消除稳态误差，但会引起超调</p>
<p>D是微分项，可以用来抑制超调。</p>
<p>一般来说，我们常用P，PD控制。因为在纵向控制中，即使没有达到精准的车速也没关系，只要满足控制精度即可。一般先调P再调D然后再调I。</p>
<h6 id="1-4-2-2-Simulink实现"><a href="#1-4-2-2-Simulink实现" class="headerlink" title="1.4.2.2 Simulink实现"></a>1.4.2.2 Simulink实现</h6><p>Apollo纵向控制采用双环PID控制，原理图如下：</p>
<p><img src="C:/Users/HuYunhao/Desktop/2018091917092752.png"></p>
<p>用Simulink实现如下：</p>
<img src="images/image-20211223150116439-16402429099701.png" style="zoom:150%;" />

<h3 id="2-决策与规划规划算法"><a href="#2-决策与规划规划算法" class="headerlink" title="2 决策与规划规划算法"></a>2 决策与规划规划算法</h3><h4 id="2-1-基础知识"><a href="#2-1-基础知识" class="headerlink" title="2.1 基础知识"></a>2.1 基础知识</h4><h5 id="2-1-1-决策规划简介"><a href="#2-1-1-决策规划简介" class="headerlink" title="2.1.1 决策规划简介"></a>2.1.1 决策规划简介</h5><p><strong>1.决策规划有哪些模块？</strong></p>
<p>一般来说，规划算法分为三个模块：</p>
<p>**全局路径规划模块&#x2F;导航规划算法：**此算法计算出大地图上A到B的最优路径，长度从几公里到几百公里不等。是整个规划模块中最为成熟的算法。**特点：**全局路径规划的结果是一个粗略的，大范围的路径，这个路径不会考虑避障，也不会考虑车辆的动力学约束，一般全局路径规划的路径是不规则的折线。全局路径规划算法一般只需要执行一次，只有遇到大范围的道路拥堵、施工、偏航等情况，才会再次执行全局路径规划。</p>
<p>**决策算法&#x2F;行为规划算法：**此算法决定车辆行驶的意图，比如：对静态障碍物到底往左绕还是往右绕，对于动态障碍物到底是减速避让还是加速超车。<strong>这是整个规划算法中最难的部分。特点</strong>：决策算法会给定车辆的行驶意图，会指导车辆该避让还是超车，该左转还是右转，但是决策算法不会给出具体的运动建议，比如左转多少度，车辆加速到多少。实际的环境是瞬息万变的，因此决策模块的执行效率一般较高，为10HZ，同时，决策算法还需要一定的稳定性，不允许在周围环境稳定时出现“朝令夕改”的现象。</p>
<p>**局部路径规划&#x2F;运动规划算法：**根据决策给出的驾驶行为意图，在相关的时空搜索出一条详细的路径，并且该路径是满足各个约束条件的轨迹。这条轨迹就是发送给控制模块去跟踪的轨迹，一般长度在几米到几十米不等。**特点：**局部路径规划生成的轨迹是决策规划模块最终的输出，具有详细的路径和速度信息。执行的频率和决策算法模块相同，为10HZ。同样，运动规划的轨迹也需要具有一定的稳定性。</p>
<p><strong>2.决策规划的流程</strong></p>
<p>前提：已经有了全局路径规划的路径。</p>
<ol>
<li>由定位模块+全局路径，生成参考线。</li>
<li>将静态障碍物投影到以参考线为坐标轴的Frenet坐标系上。</li>
<li>决策算法对障碍物做出决策（往左绕还是往右绕等），等价于开辟最优凸空间。</li>
<li>规划算法在决策算法开辟的最优凸空间内，搜索出一条最优的路径。</li>
<li>后处理：将最优路径平滑并且转换成cartesian坐标，发送给控制模块。</li>
</ol>
<h5 id="2-1-2-数学基础-五次多项式"><a href="#2-1-2-数学基础-五次多项式" class="headerlink" title="2.1.2 数学基础-五次多项式"></a>2.1.2 数学基础-五次多项式</h5><p>五次多项式是规划论文中的常客，本节将详细讲述五次多项式的特殊性。</p>
<p><strong>1.如何定量评价车辆的舒适性？</strong></p>
<p>在车辆有运动规划中，一个非常重要的指标就是舒适性。在物理中，衡量舒适性的物理量为跃度，英文为Jerk，Jerk定义为：<br>$$<br>Jerk &#x3D; \frac{da}{dt}<br>$$<br>即Jerk是加速度对时间的导数，Jerk的绝对值越小意味着加速度的变化越平缓，加速度变化平缓也意味着越舒适。</p>
<p>如果有一个质点的轨迹为：S&#x3D;f(t)，则$Jerk&#x3D;\frac{d^3f}{dt^3}$，若在区间[0, T]的时间中，Jerk的绝对值都比较小，那么意味着[0, T]内规划的轨迹是比较舒适的。此时，问题变成了一个数学问题：有一个函数S&#x3D;f(t)，那么什么样的f(t)可以使得[0, T]内的Jerk的绝对值越小？（由于绝对值的处理较为繁琐，因此一般用平方代替）。也就是说，找到一个f(t)，使得<br>$$<br>\int_{0}^{T}(\frac{d^3f}{dt^3})^2dt<br>$$<br>最小，显然，积分$\int_{0}^{T}(\frac{d^3f}{dt^3})^2dt$是一个关于f(t)的泛函，积分的值取决于f(t)在[0, T]上的整体形状。P.S.泛函可以看一下变分法和最速降线相关的书籍。</p>
<p><img src="/images/3.png"></p>
<h5 id="2-1-3-数学基础-凸优化"><a href="#2-1-3-数学基础-凸优化" class="headerlink" title="2.1.3 数学基础-凸优化"></a>2.1.3 数学基础-凸优化</h5><p><strong>1.规划轨迹最优指标的定量描述</strong></p>
<p>自动驾驶的规划目标：算出一条满足约束的最优轨迹，让控制去执行。</p>
<p>那最优的指标是什么呢？约束有哪些呢？</p>
<blockquote>
<p>指标：平滑性；舒适性；尽可能短，耗时少</p>
<p>约束：轨迹连续性；无碰撞；遵守交规；遵循车辆动力学特性；</p>
</blockquote>
<p>我们往往用一个数学函数cost function去定量的描述最优指标，假设有一条轨迹$s &#x3D; f(t) &#x3D; a_0+a_1t+a_2t^2+a_3t^3+a_4t^4+a_5t^5$，我们构建如下的成本函数J<br>$$<br>J &#x3D; w_1\dot{f}^2+w_2\ddot{f}^2+w_3\dddot{f}^2<br>$$<br>其中w1, w2, w3分别代表权重，J越小，说明各个导数的值越小，也就意味着轨迹s越平滑。</p>
<p><strong>2.如何求cost function在约束下的最小值</strong></p>
<p>这一节，我们来探讨一个数学问题：<strong>如何求解cost function在约束下的最小值</strong>。</p>
<p>在《数值分析》中，求一个复杂函数在复杂约束下的最值问题，一般都采用迭代法，而不是求导法。常见的迭代法有：牛顿法，梯度下降法，高斯牛顿法（视觉slam十四讲中有提)。</p>
<p>但是，迭代法在求解复杂函数在复杂约束上的最值时，也有自己的缺点。</p>
<p><strong>缺点一</strong>：如果约束空间不连续的话，会收敛到局部最小值</p>
<p>如下图所示：</p>
<img src="images/image-20220524192926814.png" alt="image-20220524192926814" style="zoom: 50%;" />



<p>如果选取$x_0$为迭代初值的话，那么最小值将会是$x_1$；如果选取$x_0^{‘}$为迭代初值的话，那么迭代法收敛到最小值$x_1{‘}$。</p>
<p>缺点二：约束空间是连续的，但是初值的选择不同也会迭代到局部最小值。</p>
<img src="images/image-20220524193948331.png" alt="image-20220524193948331" style="zoom:50%;" />

<p>如果选取$x_0$为迭代初值，那么迭代的最小值是$x_n$；如果以$x_0{‘}$为迭代初值的话，迭代的最小值为$x_n{‘}$；如果以$x_0{‘’}$为迭代初值的话，迭代的最小值为$x_n{‘’}$。</p>
<p>由此可见，<strong>由于初值的选择不同，迭代法有可能收敛到局部最小值</strong>。</p>
<p><strong>3.凸优化（二次规划）的定义</strong></p>
<p>如果有这么一种函数，它只有一个极值点，且为极小值。并且约束空间是一个完整的连续区间。此时迭代法对初值不敏感，且迭代收敛的解必定是约束下的最小值。满足这样性质的函数我们成为凸函数，这种完整的空间我们成为凸空间，<strong>求凸函数在凸空间下的最小值问题称为凸优化。</strong></p>
<img src="images/image-20220524194437665.png" alt="image-20220524194437665" style="zoom:50%;" />

<p>此定义非严谨定义，是方便理解的凸优化的定义。</p>
<p>但是，对<strong>自动驾驶规划来说，约束的空间并不是一个凸空间</strong>。p.s.，比如在避障工况，障碍物会把约束空间打碎成非凸空间，如下图所示的静态避障的例子：</p>
<img src="images/image-20220524215904173.png" alt="image-20220524215904173" style="zoom: 25%;" />

<p>那么如何求解非凸问题？答案是：把非凸问题转换成凸问题。</p>
<p>非凸问题1：求解一个函数为凸函数，空间为非凸空间的非凸问题</p>
<img src="images/image-20220524220409280.png" alt="image-20220524220409280" style="zoom:25%;" />

<p>我们可以随机在约束空间（非凸空间）采样一些离散的点，然后比较这些离散点的函数值，取最小的那个函数值对应的$x$，作为迭代的初始值，从而求出函数的最小值。</p>
<p>非凸问题2：函数是非凸函数，空间也是非凸空间（不连续的空间）。</p>
<p><img src="/images/1-16417968777281.png" alt="1"></p>
<p>解决方法仍然是随机的采一些离散的函数值，然后取最小函数值对应的$x$作为迭代的初值。</p>
<p>我们把上图提到的离散函数的最小值称为<strong>粗解</strong>，因此，求一个非凸问题的过程可以表述为：非凸空间-&gt;采样离散点(离散化)-&gt;粗解-&gt;根据粗解迭代-&gt;最终解。<strong>但是这种解法会存在一个问题</strong>，就是取的离散点太少时，一样容易导致收敛到局部最优。解决的办法是多采一些离散值，但离散值取多了，又会导致维度灾难的问题。p.s.所谓的维度灾难的问题，就是在一维非凸问题中，如果选取100个离散点，那么对应的在二维非凸问题中，就会要采样100*100个离散点。</p>
<h5 id="2-1-4-Frenet与笛卡尔坐标系的相互转换"><a href="#2-1-4-Frenet与笛卡尔坐标系的相互转换" class="headerlink" title="2.1.4 Frenet与笛卡尔坐标系的相互转换"></a>2.1.4 Frenet与笛卡尔坐标系的相互转换</h5><h6 id="2-1-4-1-预备知识"><a href="#2-1-4-1-预备知识" class="headerlink" title="2.1.4.1 预备知识"></a>2.1.4.1 预备知识</h6><p><strong>预备知识-1</strong></p>
<ul>
<li><p>龙格现象：对离散点进行多项式拟合的时候，一般来说多项式的阶数越高，越准确。但是用高次多项式拟合离散点可能会出现震荡的现象，龙格在1901年发现的。因此我们尽可能用<strong>分段的低次多项式</strong>去拟合离散点，而不是高次多项式。</p>
</li>
<li><p>为什么需要自然坐标系（Frenet)?</p>
</li>
</ul>
<p>​		在直角坐标系下处理规划问题，比较困难。需要先将直角坐标系–&gt;自然坐标系，然后再转换回来。</p>
<ul>
<li>Frenet坐标系的简介</li>
</ul>
<p>​		在大地平面上，局部路面可以看做是一个平面。此时对于自动驾驶的规划模块来说，Frenet坐标系的挠度可以设置为0，从而有下面的Frenet公式：<br>$$<br>\begin {align}<br>	\frac{d\vec{\tau}}{ds} &amp;&#x3D; k\vec{n} \<br>	\frac{d\vec{n}}{ds} &amp;&#x3D; -k\vec{\tau} \<br>\end {align}<br>$$<br>若此时Frenet坐标系的$\vec{\tau}$向量与Cartesian坐标系的x轴的夹角为$\theta$,有如下的结论<br>$$<br>\begin{align}<br>	\vec{\tau} &amp;&#x3D; [cos\theta, sin\theta]^T \<br>	\vec{n} &amp;&#x3D; [-sin\theta, cos\theta]^T \<br>\end{align}<br>$$<br><strong>预备知识2–推导前的变量的定义</strong></p>
<img src="images/image-20220718151502057.png" alt="image-20220718151502057" style="zoom: 33%;" />

<p>如图所示，已知车辆在笛卡尔坐标系下的$(\vec{r}, v, a, \theta, k)$，求车辆在以参考线(reference line)为道路几何(Base frame)下的Frenet坐标$(s, \dot{s}, \ddot{s}, l, \dot{l}, \ddot{l}, l’, l’’)$</p>
<p>这些量的含义为：</p>
<ul>
<li>$s$  Frenet纵坐标</li>
<li>$\dot{s}&#x3D;\frac{ds}{dt}$  Frenet纵坐标对时间的导数，即沿base frame的速度</li>
<li>$\ddot{s} &#x3D; \frac{d\dot{s}}{dt}$  沿base frame的加速度</li>
<li>$l$  Frenet坐标系横坐标</li>
<li>$\dot{l} &#x3D; \frac{dl}{dt}$  Frenet横向速度</li>
<li>$\ddot{l}&#x3D;\frac{d\dot{l}}{dt}$  Frenet横向加速度</li>
<li>$l’&#x3D;\frac{dl}{ds}$  Frenet横坐标对纵坐标的导数</li>
<li>$l’’&#x3D;\frac{dl’}{ds}$  Frenet横坐标对纵坐标的二阶导</li>
<li>$\vec{r}&#x3D;(x,y)$  车辆在笛卡尔坐标系下的坐标，是一个向量</li>
<li>$v&#x3D;\frac{d\vec{r}}{dt}$  车辆在笛卡尔坐标系下的速度</li>
<li>$a$  车辆在笛卡尔坐标系下的加速度</li>
<li>$\theta$  车辆在笛卡尔坐标系下的横摆角</li>
<li>$k$  曲率</li>
</ul>
<p>Frenet坐标系下的点有两种表示方式$(s, \dot{s}, \ddot{s}, l, \dot{l}, \ddot{l})$或者$(s, \dot{s}, \ddot{s}, l,  l’, l’’)$其中$\dot{l}, \ddot{l}$和$l’,l’’$是可以相互转换的，转换关系的推导如下所示：<br>$$<br>\begin{align}<br>	\dot{l} &amp;&#x3D; \frac{dl}{dt} &#x3D; \frac{dl}{ds}\cdot\frac{ds}{dt} &#x3D; l’\cdot\dot{s}  \<br>	\ddot{l} &amp;&#x3D; \frac{d\dot{l}}{dt} &#x3D; \frac{d(l’\cdot\dot{s})}{dt} &#x3D; l’’\cdot\dot{s}^2+l’\cdot\ddot{s}<br>\end{align}<br>$$<br><strong>预备知识3–曲线坐标轴对时间的导数</strong></p>
<p>Frenet坐标系（曲线坐标系）相对于笛卡尔坐标系来说，最大的不同在于：</p>
<p>1.笛卡尔坐标系下的坐标轴的基向量$(\vec{i}, \vec{j})$对时间的导数等于0，而Frenet坐标系的基向量$(\vec{\tau}, \vec{s})$对时间的导数不为0；</p>
<p>2.笛卡尔坐标系下，坐标点的微分$dx$与坐标点在坐标轴上的投影的微分$dx$是相等的，而Frenet坐标系下，坐标点的微分$ds$与投影点的微分$ds$并不相等。也就是说，曲线坐标系下有多个$ds$，必要时，要用不同的符号对齐区分，以免混淆。</p>
<p>我们来求Trajectory上的$(\vec{\tau}, \vec{n})$对时间的导数和Reference Line上的$(\vec{\tau_r}, \vec{n_r})$对时间的导数，我们记Trajectory上的弧微分为$ds_x$<br>$$<br>\begin{align}</p>
<pre><code>\dot&#123;\vec&#123;\tau&#125;&#125; &amp;= \frac&#123;d\vec&#123;\tau&#125;&#125;&#123;dt&#125; = \frac&#123;d\vec&#123;\tau&#125;&#125;&#123;ds_x&#125; \cdot \frac&#123;ds_x&#125;&#123;dt&#125; = k \cdot 			\vec&#123;n&#125; \cdot \left | \vec&#123;v&#125; \right | \tag&#123;1&#125;\\
\dot&#123;\vec&#123;n&#125;&#125; &amp;= -k \cdot \vec&#123;\tau&#125; \cdot \left | \vec&#123;v&#125; \right | \tag&#123;2&#125;\\
\dot&#123;\vec&#123;\tau_r&#125;&#125; &amp;= k_r \cdot \vec&#123;n_r&#125; \cdot \left | \vec&#123;v_r&#125; \right | =  k_r \cdot \vec&#123;n_r&#125; \cdot    		\dot&#123;s&#125; \tag&#123;3&#125;\\
\dot&#123;\vec&#123;n_r&#125;&#125; &amp;= -k_r \cdot \vec&#123;\tau_r&#125; \cdot \dot&#123;s&#125; \tag&#123;4&#125; \\
</code></pre>
<p>\end{align}<br>$$<br><strong>p.s</strong>.Frenet坐标中$\dot{s} &#x3D; \frac{ds}{dt}$，此处的$ds$指的是道路几何(base frame)的$ds$。因此，你可以看到上面的推导中，对于Reference Line的坐标的导数的推导，有$\left | \vec{v_r} \right | &#x3D;\dot{s} $。而对于Trajectory的坐标的导数推导，由于$\left | \vec{v} \right | &#x3D; \frac{ds_x}{dt}$不等于$\frac{ds}{dt}$，故不可以用$\dot{s}$代替$\left | \vec{v} \right |$</p>
<p><strong>预备知识4–速度和加速度的推导</strong><br>$$<br>\begin{align}<br>	\vec{v} &amp;&#x3D; \dot{\vec{r}} &#x3D; \frac{d\vec{r}}{dt} &#x3D; \frac{d\vec{r}}{ds_x} \cdot \frac{ds_x}{dt} &#x3D; 					\vec{\tau} \cdot \left | \vec{v} \right | \tag5 \<br>    \vec{v_r} &amp;&#x3D; \dot{\vec{r_r}} &#x3D; \vec{\tau_r} \cdot \left | \vec{v_r} \right | &#x3D;  \vec{\tau_r} \cdot 				\dot{s} \tag6 \<br>	\vec{a} &amp;&#x3D; \frac{d\vec{v}}{dt} &#x3D; \left | \dot{\vec{v}} \right | \vec{\tau} + k \cdot \left | \vec{v} 			\right |^2 \cdot \vec{n} \tag7 \<br>\end{align}<br>$$</p>
<h6 id="2-1-4-2-推导过程"><a href="#2-1-4-2-推导过程" class="headerlink" title="2.1.4.2 推导过程"></a>2.1.4.2 推导过程</h6><p><strong>1.笛卡尔坐标系转Frenet坐标系</strong></p>
<p>已知车辆在笛卡尔坐标系下的$(\vec{r}, v, a, \theta, k)$，已知reference line上的各个离散点的坐标$(x_i, y_i, \theta_i, k_i)$。求车辆的Frenet坐标$(s, \dot{s}, \ddot{s}, l, \dot{l}, \ddot{l}, l’, l’’)$</p>
<p><strong>第一步</strong>：推导出来<code>预备知识3和预备知识4</code>的7个公式，已完成。</p>
<p><strong>第二步</strong>：找到车辆在Frenet坐标系下的投影点记为$(\vec{r_r}, \theta_r, k_r)$</p>
<img src="images/image-20220720094553623.png" alt="image-20220720094553623" style="zoom:33%;" />

<p>如图所示，已知车辆的位置点$x$，求车辆在离散路径上的投影点$r$。</p>
<p>对于离散轨迹的投影点的计算，我们可以用匹配点$r_m$的信息来估计投影点的信息$r_r$。遍历整个离散点集，找到与车辆距离最近的点，这个点即为离散点$m$。此时可以得到$\vec{d} &#x3D; (x-x_m, y-y_m)$，$\vec{\tau_m} &#x3D; (cos\theta_m,sin\theta_m)$</p>
<p>1)估计$\vec{r_r} &#x3D; (x_r, y_r)$</p>
<p>$\vec{r_r} &#x3D; \vec{r_m} + (\vec{d} \cdot \vec{\tau_m}) \cdot \vec{\tau_m}$，写成非向量形式<br>$$<br>x_r &#x3D; x_m + ((x-x_m)cos\theta_m + (y-y_m)sin\theta_m) cos\theta_m \<br>y_r &#x3D; y_m + ((x-x_m)cos\theta_m + (y-y_m)sin\theta_m) sin\theta_m<br>$$<br>2)估计$\theta_r, k_r$</p>
<p>我们近似的认为$k_r &#x3D; k_m$，也就是说认为匹配点和参考点之间是圆弧过渡的。</p>
<p>因此$\theta_r &#x3D; \theta_m + d\theta$，根据曲率的定义有$k_m &#x3D; \frac{d\theta}{ds}$。而ds近似的等于$ds &#x3D; \vec{d} \cdot \vec{\tau_m}$</p>
<p>故$\theta_r &#x3D; \theta_m + k_m\vec{d} \cdot \vec{\tau}_m$，写成非向量形式有：$\theta_r &#x3D; \theta_m+k_m((x-x_m)cos\theta_m+(y-y_m)sin\theta_m)$</p>
<p><strong>第三步</strong>：利用向量三角形和微积分，求出$(s, \dot{s}, \ddot{s}, l, l’, l’’)$</p>
<p>根据上图中的向量三角形，我们可以得出坐标转换的<strong>核心公式</strong>：$\vec{r} &#x3D; \vec{r_r} + l \cdot \vec{n_r}$。 </p>
<ul>
<li>计算$s$</li>
</ul>
<p>已知离散点的点集，那么投影点的$s$的计算方法就是，以直代曲，将各个离散点的距离加起来。这种粗略的算法对于离散点密集，曲率不大的场景内适合，且鲁棒性很好。</p>
<p>$s &#x3D; ((x_1-x_0)^2+(y_1-y_0)^2)^{1&#x2F;2} + ((x_2-x_1)^2+(y_2-y_1)^2)^{1&#x2F;2}+…+((x_r-x_{r-1})^2+(y_r-y_{r-1})^2)^{1&#x2F;2}$</p>
<ul>
<li>计算$\dot{s}$</li>
</ul>
<p>将核心公式两边求导可知，$\dot{\vec{r}} &#x3D; \dot{\vec{r_r}} + \dot{l} \cdot \vec{n_r} + l \cdot \dot{\vec{n_r}}$</p>
<p>代入公式(4)(5)(6)可知，$\vec{v} &#x3D; \vec{\tau_r} \cdot \dot{s} + \dot{l} \cdot \vec{n_r} + l \cdot (-k_r \cdot \dot{s} \cdot {\tau_r})$(<code>临时公式1</code>)两边同时右乘$\vec{\tau_r}$可得：</p>
<p>$\vec{v} \cdot \vec{\tau_r} &#x3D;(1-k_rl) \cdot \dot{s}$，写成非向量形式，可得</p>
<p>$$<br>\dot{s} &#x3D; \frac{\left | \vec{v} \right | \cdot cos(\theta-\theta_r)}{1-k_rl}<br>$$</p>
<ul>
<li>计算$\ddot{s}$</li>
</ul>
<p>$\ddot{s} &#x3D; \frac{d\dot{s}}{dt}$，代入$\dot{s}$的结果，然后化简可知：</p>
<p>$\ddot{s} &#x3D; \frac{\vec{a} \cdot \vec{\tau_r} + k_r \dot{s}^2 l’ + \dot{s}^2(k_r’l+k_rl’)}{1-k_rl}$化简成非向量的形式：<br>$$<br>\ddot{s} &#x3D; \frac{\left | \dot{\vec{v}} \right | cos(\theta-\theta_r) - \dot{s}^2[l’(\frac{k(1-k_rl)}{cos(\theta-\theta_r)}-k_r)-(k_r’l+k_rl’)]}{1-k_rl}<br>$$</p>
<ul>
<li>计算$l$</li>
</ul>
<p>将核心公式恒等变化可知，$l &#x3D; (\vec{r}-\vec{r_r}) \cdot \vec{n_r}$，写成非向量形式</p>
<p>$$<br>l &#x3D; -sin\theta_r(x-x_r) + cos\theta_r(y-y_r)<br>$$</p>
<ul>
<li>计算$\dot{l}$</li>
</ul>
<p>由<code>临时公式1</code>，$\vec{v} &#x3D; \vec{\tau_r} \cdot \dot{s} + \dot{l} \cdot \vec{n_r} + l \cdot (-k_r \cdot \dot{s} \cdot {\tau_r})$。两边同点乘$\vec{n_r}$可得：</p>
<p>$\dot{l} &#x3D; \vec{v} \cdot \vec{n_r}$，写成非向量形式</p>
<p>$$<br>\dot{l} &#x3D; \left | \vec{v} \right | \cdot sin(\theta-\theta_r)<br>$$</p>
<ul>
<li>计算$l’$</li>
</ul>
<p>$l’ &#x3D; \frac{dl}{ds} &#x3D; \frac{\frac{dl}{dt}}{\frac{ds}{dt}} &#x3D; \frac{\dot{l}}{\dot{s}}$，代入前述结果可知：</p>
<p>$$<br>l’ &#x3D; (1-k_rl)tan(\theta-\theta_r)<br>$$</p>
<ul>
<li>计算$\ddot{l}$</li>
</ul>
<p>$\ddot{l} &#x3D; \frac{d\dot{l}}{dt} &#x3D; \frac{d(\vec{v} \cdot \vec{n_r})}{dt}$由公式(4)可知，</p>
<p>$$<br>\ddot{l} &#x3D; \vec{a} \cdot \vec{n_r} - k_r(1-k_rl)\dot{s}^2<br>$$</p>
<ul>
<li>计算$l’’$</li>
</ul>
<p>由预备知识2可知，$\ddot{l} &#x3D; l’’\cdot\dot{s}^2+l’\cdot\ddot{s}$，即$l’’ &#x3D; \frac{\ddot{l}-l’\ddot{s}}{\dot{s}^2}$，写成非向量形式<br>$$<br>l’’ &#x3D; -(k_r’l+k_rl’)tan(\theta-\theta_r)+ \frac{(1-k_rl)}{cos^2(\theta-\theta_r)} (\frac{k(1-k_rl)}{cos(\theta-\theta_r)}-k_r)<br>$$</p>
<p><strong>2.Frenet坐标系转笛卡尔坐标系</strong></p>
<p>​	已知reference line上的各个离散点的坐标$r_i(x_i, y_i, \theta_i, k_i)$，已知车辆的Frenet坐标$(s, \dot{s}, \ddot{s}, l, \dot{l}, \ddot{l}, l’, l’’)$，求车辆的笛卡尔坐标$(\vec{r}, v, a, \theta, k)$。</p>
<p>**第一步：**计算参考线上各个离散点$r_i(x_i, y_i, \theta_i, k_i)$与Frenet s坐标的对应关系</p>
<table>
<thead>
<tr>
<th align="center">$r_i$</th>
<th align="center">$(x_0,y_0,\theta_0,k_0)$</th>
<th align="center">$(x_1,y_1,\theta_1,k_1)$</th>
<th align="center">$(x_i,y_i,\theta_i,k_i)$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$s_i$</td>
<td align="center">0</td>
<td align="center">$((x_1-x_0)^2+(y_1-y_0)^2)^{1&#x2F;2}$</td>
<td align="center">$\sum_{i&#x3D;0}^{i-1}((x_{i+1}-x_i)^2+(y_{i+1}-y_i)^2)^{1&#x2F;2} $</td>
</tr>
</tbody></table>
<p>**第二步：**根据车辆投影点的s坐标（与车辆的s坐标一致），查上表得到投影点的前一个点$r_n$，和投影点的后一个点$r_{n+1}$。</p>
<img src="images/image-20220801152101382.png" alt="image-20220801152101382" style="zoom: 67%;" />

<p>**第三步：**求投影点$r_r(x_r, y_r, \theta_r, k_r, k_r’)$</p>
<p>根据向量三角形有$\vec{r_r} &#x3D; \vec{r_n}+\vec{r_d}$，并且，$\vec{r_d}$可以用长度为$s-s_n$，方向为n点切线方向的向量来近似表示。即有</p>
<p>$\vec{r_r} &#x3D; \vec{r_n} + (s-s_n)\vec{\tau_n}$，写成非向量的形式有：<br>$$<br>x_r &#x3D; x_n + (s-s_n)cos\theta_n \<br>y_r &#x3D; y_n + (s-s_n)sin\theta_n<br>$$<br>根据曲率定义和圆弧假设，有$\theta_r &#x3D; \theta_n + k_n(s-s_n)$，$k_r &#x3D; k_n$。</p>
<p>$k_r’ &#x3D; \frac{dk_r}{ds} \approx \frac{k_{n+1}-k_n}{s_{n+1}-s_n}$</p>
<p>**第四步：**有了投影点的信息$(x_r,y_r,\theta_r,k_r)$和车辆的Frenet坐标$(s, \dot{s}, \ddot{s}, l, \dot{l}, \ddot{l}, l’, l’’)$后，我们根据<code>笛卡尔转Frenet</code>的公式可以反推得出</p>
<p>车辆的笛卡尔坐标$(\vec{r}, v, a, \theta, k)$</p>
<h6 id="2-1-4-3-结论"><a href="#2-1-4-3-结论" class="headerlink" title="2.1.4.3 结论"></a>2.1.4.3 结论</h6><p>车辆在笛卡尔坐标系下的坐标表示为$(\vec{r}, v, a, \theta, k)$，车辆在Frenet坐标系下的坐标表示为$(s, \dot{s}, \ddot{s}, l, \dot{l}, \ddot{l}, l’, l’’)$。车辆在参考线上的投影点的坐标表示为$(x_r,y_r,\theta_r,k_r,k_r’)$</p>
<blockquote>
<p>CartesianToFrenet</p>
</blockquote>
<p>$$<br>\begin{align}<br>&amp; s &#x3D; ((x_1-x_0)^2+(y_1-y_0)^2)^{1&#x2F;2} + ((x_2-x_1)^2+(y_2-y_1)^2)^{1&#x2F;2}+…+((x_r-x_{r-1})^2+(y_r-y_{r-1})^2)^{1&#x2F;2} \<br>&amp; \dot{s} &#x3D; \frac{\left | \vec{v} \right | \cdot cos(\theta-\theta_r)}{1-k_rl} \<br>&amp; \ddot{s} &#x3D; \frac{\left | \dot{\vec{v}} \right | cos(\theta-\theta_r) - \dot{s}^2[l’(\frac{k(1-k_rl)}{cos(\theta-\theta_r)}-k_r)-(k_r’l+k_rl’)]}{1-k_rl} \<br>&amp; l &#x3D; -sin\theta_r(x-x_r) + cos\theta_r(y-y_r) \<br>&amp; l’ &#x3D; (1-k_rl)tan(\theta-\theta_r) \<br>&amp; l’’ &#x3D; -(k_r’l+k_rl’)tan(\theta-\theta_r)+ \frac{(1-k_rl)}{cos^2(\theta-\theta_r)} (\frac{k(1-k_rl)}{cos(\theta-\theta_r)}-k_r) \<br>&amp; \dot{l} &#x3D; l’\cdot\dot{s} \<br>&amp; \ddot{l} &#x3D; l’’\cdot\dot{s}^2+l’\cdot\ddot{s} \<br>\end{align}<br>$$</p>
<p>其中：</p>
<p>$\left | \vec{v} \right |$为车辆的车速的模, 这里用速度$v$的值即可。</p>
<p>$\left | \dot{\vec{v}} \right |$为车辆的切向加速度的模，这里用加速度$a$的值即可。注意：由<code>公式(7)</code>或者物理常识，我们可以知道，切向加速度的大小不等于加速度的大小，即$\left | \dot{\vec{v}} \right | \ne   \left | \vec{a} \right |$。</p>
<blockquote>
<p>FrenetToCartesian</p>
</blockquote>
<p>$$<br>\begin{align}<br>&amp; x &#x3D; x_r - lsin\theta_r \<br>&amp; y &#x3D; y_r + lcos\theta_r \<br>&amp; \theta &#x3D; arctan(\frac{l’}{1-k_rl}) + \theta_r \<br>&amp; k &#x3D; { [l’’+(k_r’l+k_rl’)tan(\theta-\theta_r)] \frac{cos^2(\theta-\theta_r)}{1-k_rl} + k_r } \frac{cos(\theta-\theta_r)}{1-k_rl} \<br>&amp; v &#x3D; \sqrt{[\dot{s}(1-k_rl)]^2 + (\dot{s}l’)^2} \<br>&amp; a &#x3D; \ddot{s}\frac{1-k_rl}{cos(\theta-\theta_r)} + \frac{\dot{s}^2}{cos(\theta-\theta_r)}[l’(k \frac{1-k_rl}{cos(\theta-\theta_r)} - k_r) - (k_r’l+k_rl’)] \<br>\end {align}<br>$$</p>
<h4 id="2-2-参考线模块"><a href="#2-2-参考线模块" class="headerlink" title="2.2 参考线模块"></a>2.2 参考线模块</h4><p>根据<code>2.1</code>中的决策规划模块工作流程，我们先说怎么从“定位+全局路径规划”生成参考线。</p>
<p><strong>1.预备知识</strong></p>
<p>（1）参考线是什么？</p>
<p>参考线是从全局路径截取一段，做平滑生成的曲线。因为全局路径有以下缺点：</p>
<ul>
<li><p>全局路径往往是不平滑的</p>
</li>
<li><p>全局路径一般都比较长，不利于坐标转换（找匹配点，计算S）</p>
</li>
<li><p>障碍物在过长路径上的投影可能不唯一</p>
</li>
</ul>
<p>（2）怎么做参考线？</p>
<p>在每个规划周期内，我们找到车辆在全局路径上的投影点（用匹配点也行），以投影点为坐标原点，往后取一段距离，往前取一段距离，将这个距离内的点做平滑，平滑后的点的集合称为参考线。</p>
<p>（3）参考线算法如何提高运行速度？</p>
<ul>
<li>减少规划的频率，规划算法每100ms执行一次，控制算法每10ms执行一次</li>
<li>充分利用上一个规划周期的结果</li>
</ul>
<p><strong>2.参考线的平滑算法</strong></p>
<p><em><strong>算法1-FEM Smoother：</strong></em></p>
<p>算法优点：优化的变量较少</p>
<p>算法缺点：无法保证曲率是连续的（没有曲率项的约束）。</p>
<p>算法的观点：</p>
<p><code>平滑性条件1</code>：认为平滑后的点，越接近直线越平滑。</p>
<img src="images/image-20220804100524106.png" alt="image-20220804100524106" style="zoom:33%;" />

<p>如图，假设$p_0’,p_1’,p_2’$为平滑后的点，即认为$\left | \vec{p_1’p_3’} \right |$长度越短，越平滑</p>
<p><code>平滑性条件2</code>：认为越接近原有的几何形状越好</p>
<img src="images/image-20220803090023251.png" alt="image-20220803090023251" style="zoom: 67%;" />

<p>如上图所示，$p_0,p_1,p_2$为平滑之前的点，$p_0’,p_1’,p_2’$为平滑后的点。即$\left | p_0p_0’ \right | + \left | p_1p_1’ \right | + \left | p_2p_2’ \right | $越小越平滑</p>
<p><code>平滑性条件3</code>:平滑后的每两个点之间的长度，尽可能的均匀和紧凑。</p>
<img src="images/image-20220804101056813.png" alt="image-20220804101056813" style="zoom:33%;" />

<p>如图所示，$p_0’,p_1’,p_2’$为平滑之后的均匀点，$p_0’’,p_1’’,p_2’’$是平滑之后的点。假设三个点之间的总长度为2a，</p>
<p>则有$\left | p_0’p_1’ \right | &#x3D; \left | p_1’p_2’ \right | &#x3D; a$，计算平方和可知：$\left | p_0’p_1’ \right | ^2 + \left | p_1’p_2’ \right |^2 &#x3D; 2a^2$</p>
<p>假设$\left | p_0’p_1’ \right | &#x3D; \left | p_1’p_2’ \right | &#x3D; a$，则$\left | p_1’’p_2’’ \right | &#x3D; a + b$。计算平方和可知：$\left | p_0’’p_1’’ \right | ^2 + \left | p_1’’p_2’’ \right |^2 &#x3D; 2a^2 + 2b^2$</p>
<p>结论：$\left | p_0p_1 \right | ^2 + \left | p_1p_2 \right |^2$越小，平滑后的每两个点之间越均匀、紧凑。</p>
<p>综合<code>平滑性条件1,2,3</code>，假设平滑之前的点为$p_0,p_1,p_2$(已知点),平滑后的点为$p_0’,p_1’,p_2’$可得出如下<code>cost function J</code></p>
<img src="images/image-20220805091614894.png" alt="image-20220805091614894" style="zoom: 33%;" />
$$
J = w1[(x_0'+x_2'-2x_1')^2+(y_0'+y_2'-2y_1')^2] + w2\sum_{i=0}^{2}[(x_i-x_i')^2+(y_i-y_i')^2] + w3 \sum_{i=0}^{1}[(x_{i+1}'-x_i')^2+(y_{i+1}'-y_i')^2]
$$
$w1,w2,w3$分别为`平滑条件123`的权重系数。代价函数最小的路径，即为平滑的路径。

<p><strong>如何求解这个优化问题？</strong></p>
<p>（1）将求解最小代价函数问题（优化问题）转成二次规划问题</p>
<h4 id="2-3-Hybird-A"><a href="#2-3-Hybird-A" class="headerlink" title="2.3 Hybird A*"></a>2.3 Hybird A*</h4><h5 id="2-3-1-简介"><a href="#2-3-1-简介" class="headerlink" title="2.3.1 简介"></a>2.3.1 简介</h5><h5 id="2-3-2-启发函数-Heuristic-function"><a href="#2-3-2-启发函数-Heuristic-function" class="headerlink" title="2.3.2 启发函数 Heuristic function"></a>2.3.2 启发函数 Heuristic function</h5><h4 id="2-4-em-planner"><a href="#2-4-em-planner" class="headerlink" title="2.4 em planner"></a>2.4 em planner</h4><h5 id="2-4-1-简介"><a href="#2-4-1-简介" class="headerlink" title="2.4.1 简介"></a>2.4.1 简介</h5><p>EM Planner是Apollo面向L4的实时运动规划算法，该算法首先通过顶层多车道策略，选择出一条参考路径，再根据这条参考线，在Frenet坐标系下，进行车道级的路径和速度规划，规划主要通过Dynamic Programming和基于样条的Quadratic Programming实现。</p>
<p>EM Planner充分考虑了无人车安全性、舒适性、可扩展性的需求，通过考虑交通规则、障碍物决策、轨迹光滑性等要求，可适应高速公路、低速城区场景的规划需求。</p>
<img src="images/em planner.png" alt="em planner" style="zoom:67%;" />

<p>说明：</p>
<ol>
<li><code>Reference Line Generator</code>的输入是高精地图和<code>Routing</code>模块给出的全局路径规划的结果，输出是包含障碍物和交通规划的多条参考线。</li>
<li>通过给定参考线，将自车和环境信息投影到参考线下的<code>Frenet</code>坐标系中</li>
<li>接下来所有的车道级信息将会传递给车道级最优求解器，该求解器会求解最优路径和最优速度。在求解最优路径时，周围环境信息将会被投影到Frenet坐标系（E-step），然后基于投影的信息生成一条光滑路径（M-step）</li>
<li>同样的，在求解最优速度时，一旦生成了一条最优路径，障碍物就会被投影到ST图中（E-step），然后最优速度求解器会生成一条光滑的速度规划（M-step）。结合路径和速度规划结果，就生成了一条给定车道的光滑轨迹。</li>
<li>最后一步会将所有的车道级轨迹传递给参考线轨迹决策器，基于当前车辆状态、相关约束和每条轨迹的代价，轨迹决策器会决定一条最优的轨迹。</li>
</ol>
<p>具体说来，针对单个车道级的EM Planner的框架如下：<br>![em planner2](images&#x2F;em planner2.png)</p>
<p>说明：</p>
<ol>
<li>在路径E-step中，障碍物会被投影到车道Frenet坐标系，障碍物包括了静态障碍物和动态障碍物。静态障碍物会直接从笛卡尔坐标系转换到Frenet坐标系，而动态的信息则以其运动轨迹来描述。通过上一帧的预测信息，和自车的运动信息，可以估算自车和动态障碍物在每个时间点的交互情况，轨迹重叠的部分会被映射到Frenet坐标系中。除此之外，在最优路径求解过程中，动态障碍物的出现会最终导致自车做出避让的决策。因此，出于安全的考虑，SL投影只考虑低速和对向障碍物，而对于高速的动态障碍物，EM Planner的平行变道策略会考虑这种情景。</li>
<li>在速度E-step，所有的障碍物都会在ST图中与生成的速度信息进行估计，如果对应的ST中重叠部分，那么对应区域将会在ST中进行重新生成。</li>
<li>在两次M-step过程中，通过Dynamic Programming和Quadratic Programming生成路径和速度规划。然而在进行投影的SL和ST坐标内求解是非凸的。为了解决这个非凸问题，首先使用Dynamic Programming获得一个粗略的解，同时这个解也能够提供诸如避让、减速、超车的决策。通过这个粗略的解，可以构建一个凸的通道，然后使用基于Quadratic Programming的样条最优求解。</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/" rel="tag"># 自动驾驶</a>
              <a href="/tags/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95/" rel="tag"># 控制算法</a>
              <a href="/tags/%E8%BD%A6%E8%BE%86%E6%A8%A1%E5%9E%8B/" rel="tag"># 车辆模型</a>
              <a href="/tags/LQR/" rel="tag"># LQR</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/01/01/self_driving/End-to-End/" rel="prev" title="端到端自动驾驶">
      <i class="fa fa-chevron-left"></i> 端到端自动驾驶
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/01/01/work_plan/daily_work/" rel="next" title="工作计划">
      工作计划 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#self-driving"><span class="nav-number">1.</span> <span class="nav-text">self-driving</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-number">1.1.</span> <span class="nav-text">1 控制算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-1-%E4%B8%89%E4%B8%AA%E5%9D%90%E6%A0%87%E7%B3%BB"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">1.1.1 三个坐标系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-2-%E4%B8%80%E4%BA%9B%E7%89%A9%E7%90%86%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">1.1.2 一些物理量的定义</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E8%BD%A6%E8%BE%86%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 车辆模型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-1-%E8%BF%90%E5%8A%A8%E5%AD%A6%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">1.2.1 运动学模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-2-%E8%BD%A6%E8%BE%86%E5%8A%A8%E5%8A%9B%E5%AD%A6%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">1.2.2 车辆动力学模型</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-2-2-1-%E8%B7%9F%E8%B8%AA%E8%AF%AF%E5%B7%AE%E5%8F%98%E9%87%8F%E7%9A%84%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E6%96%B9%E7%A8%8B"><span class="nav-number">1.1.2.2.1.</span> <span class="nav-text">1.2.2.1 跟踪误差变量的状态空间方程</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-3-%E8%B7%AF%E5%BE%84%E5%81%8F%E5%B7%AE%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">1.2.3 路径偏差的计算</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-2-3-1-%E8%AE%A1%E7%AE%97%E6%8A%95%E5%BD%B1%E7%82%B9%E7%9A%84%E9%80%9F%E5%BA%A6%E5%A4%A7%E5%B0%8F%E5%92%8C%E6%A8%AA%E5%90%91%E5%81%8F%E5%B7%AE%E5%AF%B9%E6%97%B6%E9%97%B4%E7%9A%84%E5%AF%BC%E6%95%B0"><span class="nav-number">1.1.2.3.1.</span> <span class="nav-text">1.2.3.1 计算投影点的速度大小和横向偏差对时间的导数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#1-2-3-2-%E8%AE%A1%E7%AE%97%E8%AF%AF%E5%B7%AE%E5%90%91%E9%87%8Fx"><span class="nav-number">1.1.2.3.2.</span> <span class="nav-text">1.2.3.2 计算误差向量x</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-%E6%A8%AA%E5%90%91%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-LQR"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.3 横向控制算法-LQR</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-1-LQR%E6%8E%A7%E5%88%B6"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">1.3.1 LQR控制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-2-LQR%E7%9A%84%E5%89%8D%E9%A6%88%E6%8E%A7%E5%88%B6%EF%BC%88feed-forward-control%EF%BC%89"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">1.3.2 LQR的前馈控制（feed-forward control）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-3-LQR%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">1.3.3 LQR算法总结</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-3-3-1-%E7%AE%97%E6%B3%95%E7%9A%84%E8%BE%93%E5%85%A5"><span class="nav-number">1.1.3.3.1.</span> <span class="nav-text">1.3.3.1 算法的输入</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#1-3-3-2-%E7%AE%97%E6%B3%95%E7%9A%84%E8%BE%93%E5%87%BA"><span class="nav-number">1.1.3.3.2.</span> <span class="nav-text">1.3.3.2 算法的输出</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#1-3-3-3-%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-number">1.1.3.3.3.</span> <span class="nav-text">1.3.3.3 算法流程图</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-%E7%BA%B5%E5%90%91%E6%8E%A7%E5%88%B6"><span class="nav-number">1.1.4.</span> <span class="nav-text">1.4 纵向控制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-4-1-%E5%8F%91%E5%8A%A8%E6%9C%BA%E6%89%AD%E7%9F%A9-%E8%BD%AC%E9%80%9F%E6%9B%B2%E7%BA%BF"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">1.4.1 发动机扭矩-转速曲线</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-4-2-%E5%8F%8C%E7%8E%AFPID%E6%8E%A7%E5%88%B6"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">1.4.2 双环PID控制</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-4-2-1-PID%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.4.2.1.</span> <span class="nav-text">1.4.2.1 PID简单介绍</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#1-4-2-2-Simulink%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.1.4.2.2.</span> <span class="nav-text">1.4.2.2 Simulink实现</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%86%B3%E7%AD%96%E4%B8%8E%E8%A7%84%E5%88%92%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">2 决策与规划规划算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-1-%E5%86%B3%E7%AD%96%E8%A7%84%E5%88%92%E7%AE%80%E4%BB%8B"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">2.1.1 决策规划简介</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-2-%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E4%BA%94%E6%AC%A1%E5%A4%9A%E9%A1%B9%E5%BC%8F"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">2.1.2 数学基础-五次多项式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-3-%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E5%87%B8%E4%BC%98%E5%8C%96"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">2.1.3 数学基础-凸优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-4-Frenet%E4%B8%8E%E7%AC%9B%E5%8D%A1%E5%B0%94%E5%9D%90%E6%A0%87%E7%B3%BB%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">2.1.4 Frenet与笛卡尔坐标系的相互转换</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#2-1-4-1-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86"><span class="nav-number">1.2.1.4.1.</span> <span class="nav-text">2.1.4.1 预备知识</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-1-4-2-%E6%8E%A8%E5%AF%BC%E8%BF%87%E7%A8%8B"><span class="nav-number">1.2.1.4.2.</span> <span class="nav-text">2.1.4.2 推导过程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-1-4-3-%E7%BB%93%E8%AE%BA"><span class="nav-number">1.2.1.4.3.</span> <span class="nav-text">2.1.4.3 结论</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E5%8F%82%E8%80%83%E7%BA%BF%E6%A8%A1%E5%9D%97"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 参考线模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-Hybird-A"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3 Hybird A*</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-1-%E7%AE%80%E4%BB%8B"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">2.3.1 简介</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-2-%E5%90%AF%E5%8F%91%E5%87%BD%E6%95%B0-Heuristic-function"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">2.3.2 启发函数 Heuristic function</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-em-planner"><span class="nav-number">1.2.4.</span> <span class="nav-text">2.4 em planner</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-1-%E7%AE%80%E4%BB%8B"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">2.4.1 简介</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">胡云浩</p>
  <div class="site-description" itemprop="description">记录生活，记录工作，记录学习</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">52</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">胡云浩</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
