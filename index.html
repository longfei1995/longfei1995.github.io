<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"longfei1995.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="记录生活，记录工作，记录学习">
<meta property="og:type" content="website">
<meta property="og:title" content="胡云浩的blog">
<meta property="og:url" content="https://longfei1995.github.io/index.html">
<meta property="og:site_name" content="胡云浩的blog">
<meta property="og:description" content="记录生活，记录工作，记录学习">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="胡云浩">
<meta property="article:tag" content="胡云浩, 博客, 笔记">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://longfei1995.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>胡云浩的blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">胡云浩的blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">日常笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://longfei1995.github.io/2024/01/01/IDE/cursor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡云浩">
      <meta itemprop="description" content="记录生活，记录工作，记录学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="胡云浩的blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/01/IDE/cursor/" class="post-title-link" itemprop="url">Cursor</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-01-01T00:00:00+08:00">2024-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-10 17:02:16" itemprop="dateModified" datetime="2025-04-10T17:02:16+08:00">2025-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IDE/" itemprop="url" rel="index"><span itemprop="name">IDE</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h5><h5 id="2-实用技巧"><a href="#2-实用技巧" class="headerlink" title="2. 实用技巧"></a>2. 实用技巧</h5><h6 id="1-快捷栏设置成垂直"><a href="#1-快捷栏设置成垂直" class="headerlink" title="1. 快捷栏设置成垂直"></a>1. 快捷栏设置成垂直</h6><p><code>workbench.activityBar.orientation</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://longfei1995.github.io/2024/01/01/cpp/cppNote/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡云浩">
      <meta itemprop="description" content="记录生活，记录工作，记录学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="胡云浩的blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/01/cpp/cppNote/" class="post-title-link" itemprop="url">C++笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-01-01T00:00:00+08:00">2024-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-10 17:02:18" itemprop="dateModified" datetime="2025-04-10T17:02:18+08:00">2025-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h2><h4 id="1-windows编译环境"><a href="#1-windows编译环境" class="headerlink" title="1 windows编译环境"></a>1 windows编译环境</h4><h5 id="1-1-安装msys2"><a href="#1-1-安装msys2" class="headerlink" title="1.1 安装msys2"></a>1.1 安装msys2</h5><ol>
<li><p>下载地址：<a target="_blank" rel="noopener" href="https://mirrors.aliyun.com/msys2/distrib/?spm=a2c6h.25603864.0.0.69df8c835ArYmx">阿里云Msys2镜像</a> p.s.该镜像源下载的msys2已经进行pacman换源操作，因此无需再换源。</p>
</li>
<li><p>安装make, gcc，g++等工具链</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 刷新pacman数据库与系统包</span></span><br><span class="line">pacman -Syu</span><br><span class="line"><span class="comment"># 安装MinGW64全部工具链</span></span><br><span class="line">pacman -S mingw-w64-x86_64-toolchain</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装CMake和make</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pacman -S mingw-w64-x86_64-cmake</span><br><span class="line"># 安装make, 在mingw-w64-x86_64-toolchain中有</span><br><span class="line">pacman -S mingw-w64-x86_64-make</span><br><span class="line"># 安装好make后，在终端输入make --version会提示make不存在</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="1-2-pacman的常用命令"><a href="#1-2-pacman的常用命令" class="headerlink" title="1.2 pacman的常用命令"></a>1.2 pacman的常用命令</h5><p><code>pacman -Ss &lt;关键字&gt;</code> 搜索包含关键字的包</p>
<h5 id="1-3-添加右键打开msys2"><a href="#1-3-添加右键打开msys2" class="headerlink" title="1.3 添加右键打开msys2"></a>1.3 添加右键打开msys2</h5><ul>
<li>背景知识：</li>
</ul>
<p>windows资源管理器”右键菜单”的注册表项位于<code>计算机\HKEY_CLASSES_ROOT\Directory\</code>中。其中，<code>Background\shell\</code>决定了在空白处右击（right-clicking on folder backround in Windows Explorer），弹出的菜单内容；<code>shell\</code>决定了在文件夹上（on folder itself）右击，弹出菜单的内容。</p>
<ul>
<li>举例解释</li>
</ul>
<p>以<code>计算机\HKEY_CLASSES_ROOT\Directory\Background\shell\git_shell</code>为例，做简单的解释：</p>
<p><code>git_shell</code><br><img src="/images/image-20230920153523301.png" alt="image-20230920153523301"></p>
<p>默认项的value是右键时的显示内容</p>
<p>Icon的value应该指定图标的位置</p>
<p><code>git_shell\command</code></p>
<p><img src="/images/image-20230920153555643.png" alt="image-20230920153555643"></p>
<p>默认项的value应该是这个程序的位置</p>
<ul>
<li>如何设置</li>
</ul>
<p><code>msys2</code>(名字随意)</p>
<img src="images/image-20230920155438731.png" alt="image-20230920155438731" style="zoom:67%;" />

<p><code>msys2\command</code></p>
<img src="images/image-20230920155541889.png" alt="image-20230920155541889" style="zoom:67%;" />

<h5 id="1-4-在vscode中配置默认终端为msys2-mingw64"><a href="#1-4-在vscode中配置默认终端为msys2-mingw64" class="headerlink" title="1.4 在vscode中配置默认终端为msys2 mingw64"></a>1.4 在vscode中配置默认终端为msys2 mingw64</h5><p>我们只需要在项目或者用户的setting.json里添加如下字段：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用msys2终端</span></span><br><span class="line"><span class="attr">&quot;terminal.integrated.defaultProfile.windows&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MSYS2 MinGW64&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;terminal.integrated.profiles.windows&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;MSYS2 MinGW64&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\msys64\\usr\\bin\\bash.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;--login&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-i&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;MSYSTEM&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MINGW64&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;CHERE_INVOKING&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MSYS2_PATH_TYPE&quot;</span><span class="punctuation">:</span> <span class="string">&quot;inherit&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MINGW_PREFIX&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/mingw64&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MINGW_CHOST&quot;</span><span class="punctuation">:</span> <span class="string">&quot;x86_64-w64-mingw32&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MINGW_PACKAGE_PREFIX&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mingw-w64-x86_64&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;PATH&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\msys64\\mingw64\\bin;C:\\msys64\\usr\\local\\bin;C:\\msys64\\usr\\bin;C:\\msys64\\bin;$&#123;env:PATH&#125;&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-编译相关的知识"><a href="#2-编译相关的知识" class="headerlink" title="2 编译相关的知识"></a>2 编译相关的知识</h4><h5 id="2-1-C-头文件中可以有的内容"><a href="#2-1-C-头文件中可以有的内容" class="headerlink" title="2.1 C++头文件中可以有的内容"></a>2.1 C++头文件中可以有的内容</h5><ul>
<li>变量声明，应该以extern int a;方式出现。p.s.直接用int a是定义一个变量而不是声明一个变量，如果在头文件中定义一个变量，然后又有多个cpp包含这个头文件的话，会引发重定义的问题”multiple definition of  ‘a’  “。</li>
<li>函数声明，void func();</li>
<li>内联函数, inline void func(){ some code;}</li>
<li>用const&#x2F;static修饰的变量</li>
<li>类的声明。p.s.类的成员函数可以直接在类中实现，因为类中的成员函数会被默认为内联函数</li>
</ul>
<h5 id="2-2-动态链接库和静态链接库"><a href="#2-2-动态链接库和静态链接库" class="headerlink" title="2.2 动态链接库和静态链接库"></a>2.2 动态链接库和静态链接库</h5><blockquote>
<ol>
<li>动态库和静态库的区别</li>
</ol>
</blockquote>
<ul>
<li>动态库是个编译好的程序，主程序运行时只是调用动态库中的代码，并不将动态库中的代码编译到自己的程序中来，因此链接动态库的目标程序相对来说比较小，只需要一些链接的指针。但是使用动态链接库文件，必须提前在目标程序即将运行的环境中装好动态库文件，目标程序才能正常运行。</li>
<li>静态库也是个编译好的程序，在主程序编译时，静态库中的代码都将参与编译。</li>
<li><code>.dll.a</code>是一个引用<code>.dll</code>的库，两者必须结合使用</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">动态链接库的后缀</th>
<th align="center">静态库的后缀</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Linux</td>
<td align="center">.so</td>
<td align="center">.a</td>
</tr>
<tr>
<td align="center">Windows</td>
<td align="center">.dll</td>
<td align="center">.lib</td>
</tr>
</tbody></table>
<blockquote>
<ol start="2">
<li>如何将.cpp编译成静态库</li>
</ol>
</blockquote>
<ul>
<li>假设现在有三个文件：hello.h, hello.cpp, main.cpp。目标：将hello.cpp编译成静态库，并且在cmakelist.txt中链接静态库</li>
</ul>
<p>1.将hello.cpp编译成.o文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.cpp</span><br></pre></td></tr></table></figure>

<p>2.由.o文件创建静态库 ps:静态库文件名的命名规范是以lib为前缀，紧接着跟静态库名，扩展名为.a</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar -cr libmyhello.a hello.o</span><br></pre></td></tr></table></figure>

<p>3.在cmakelist.txt中添加库文件即可</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> libmyhello.a) <span class="comment">#链接库</span></span><br></pre></td></tr></table></figure>

<h4 id="3-cmake"><a href="#3-cmake" class="headerlink" title="3 cmake"></a>3 cmake</h4><h5 id="3-1-cmake常用命令"><a href="#3-1-cmake常用命令" class="headerlink" title="3.1 cmake常用命令"></a>3.1 cmake常用命令</h5><h6 id="1-cmake"><a href="#1-cmake" class="headerlink" title="1. **.cmake"></a>1. **.cmake</h6><p> <code>xxx.cmake</code>的路径可以使用相对路径，也可以使用绝对路径</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_TOOLCHAIN_FILE=xxx.cmake</span><br></pre></td></tr></table></figure>

<h6 id="2-set"><a href="#2-set" class="headerlink" title="2. set()"></a>2. set()</h6><p><em>功能1：设置变量</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(PYTHONHOME C:/Users/%username%/AppData/Local/Programs/Python/Python36)</span><br></pre></td></tr></table></figure>

<p><em>功能2：给保留的宏赋值，以实现特殊的功能。</em></p>
<ul>
<li>指定可执行文件的输出路径</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置可执行文件输出目录</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/bin)</span><br></pre></td></tr></table></figure>

<ul>
<li>指定静态库&amp;动态库的输出路径</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置动态库/静态库生成路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/lib)</span><br></pre></td></tr></table></figure>

<h6 id="3-message"><a href="#3-message" class="headerlink" title="3. message()"></a>3. message()</h6><ul>
<li>语法</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] <span class="string">&quot;message to display&quot;</span> ...)</span><br></pre></td></tr></table></figure>

<p>(无) ：重要消息<br>STATUS ：非重要消息<br>WARNING：CMake 警告, 会继续执行<br>AUTHOR_WARNING：CMake 警告 (dev), 会继续执行<br>SEND_ERROR：CMake 错误, 继续执行，但是会跳过生成的步骤<br>FATAL_ERROR：CMake 错误, 终止所有处理过程</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 比如，打印cmake内置变量的路径</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;print directory: $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<h6 id="4-file"><a href="#4-file" class="headerlink" title="4. file()"></a>4. file()</h6><ul>
<li>使用file命令，将文件列表存储到变量中。</li>
<li>警告:每次添加或者删除文件时，都应该手动rebuild cmake。</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1027247/is-it-better-to-specify-source-files-with-glob-or-each-file-individually-in-cmak">Is it better to specify source files with GLOB or each file individually in CMake? - Stack Overflow</a></p>
</blockquote>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令原型：file(GLOB/GLOB_RECURSE &lt;variable&gt; &lt;path&gt;)</span></span><br><span class="line"><span class="comment"># GLOB: 将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中</span></span><br><span class="line"><span class="comment"># GLOB_RECURSE: 递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中。</span></span><br><span class="line"><span class="comment"># &lt;path&gt; 可以加双引号，也可以不加</span></span><br><span class="line"><span class="keyword">file</span>(GLOB <span class="variable">$&#123;PROJECT_NAME&#125;</span>_SOURCES <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;$&#123;PROJECT_NAME&#125;</span>_SOURCES&#125;)</span><br></pre></td></tr></table></figure>

<h6 id="5-aux-source-directory"><a href="#5-aux-source-directory" class="headerlink" title="5. aux_source_directory()"></a>5. aux_source_directory()</h6><p>将<dir>目录下的所有源文件（头文件等都不会包含）， 都存在<variable>中</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span>(&lt;dir&gt; &lt;variable&gt;)</span><br></pre></td></tr></table></figure>

<p>例子：假设<code>src</code>文件夹下有如下文件</p>
<p><img src="/images/image-20230515134715267.png" alt="image-20230515134715267"></p>
<p>执行</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src SRCS)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;SRCS = $&#123;SRCS&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRCS = E:/coder/cpp/test1209/src/main.cpp;E:/coder/cpp/test1209/src/test.cc;E:/coder/cpp/test1209/src/test.cpp</span><br></pre></td></tr></table></figure>

<h6 id="6-cmake-path"><a href="#6-cmake-path" class="headerlink" title="6. cmake_path"></a>6. cmake_path</h6><p>获取当前目录的父级目录<code>cmake_path(GET &lt;path-var&gt; PARENT_PATH &lt;out-var&gt;)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake_path(GET $&#123;CMAKE_CURRENT_PATH&#125; PARENT_PATH QPLAN_DIR)</span><br></pre></td></tr></table></figure>

<h6 id="7-add-library"><a href="#7-add-library" class="headerlink" title="7. add_library()"></a>7. add_library()</h6><p>有些时候我们编写的源代码并不需要将他们编译生成可执行程序，而是生成一些静态库或动态库提供给第三方使用，下面来讲解在cmake中生成这两类库文件的方法。</p>
<ol>
<li>制作静态库</li>
</ol>
<p>在cmake中，如果想要制作静态库，需要使用如下命令</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在Linux中，静态库的名字分为三部分：lib+库名字+.a，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充。</span></span><br><span class="line"><span class="comment"># windows中，静态库的名字格式虽然和Linux不同，但在此处，也只需指定库名字即可</span></span><br><span class="line"><span class="keyword">add_library</span>(库名称 STATIC 源文件<span class="number">1</span> [源文件<span class="number">2</span>] ...) </span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定库的输出路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 打包制作库的.cpp</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SOURCES   <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp</span><br><span class="line">                    <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/common/*.cpp)</span><br><span class="line"><span class="keyword">add_library</span>(srcs_all STATIC <span class="variable">$&#123;SOURCES&#125;</span>)</span><br><span class="line"><span class="comment"># 指定库相关.cpp文件的头文件路径</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(srcs_all PUBLIC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>制作动态库</li>
</ol>
<p>示例和静态库一样，只需要改成动态库的语法<code>add_library(库名称 SHARED 源文件1 [源文件2] ...) </code>即可</p>
<h6 id="8-target-link-libraries"><a href="#8-target-link-libraries" class="headerlink" title="8. target_link_libraries"></a>8. target_link_libraries</h6><ul>
<li>说明</li>
</ul>
<p>链接动态库的链接和静态库是完全不同的：</p>
<p>​			静态库：会在生成可执行程序的链接阶段被打包到可执行程序中，所以可执行程序启动，静态库就被加载到内存中了。<br>​			动态库：在生成可执行程序的链接阶段不会被打包到可执行程序中，当可执行程序被启动并且调用了动态库中的函数的时候，动态库才会被加载到内存</p>
<ul>
<li>语法</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">    &lt;<span class="keyword">target</span>&gt; </span><br><span class="line">    &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;... </span><br><span class="line">    [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...]...)</span><br></pre></td></tr></table></figure>

<p><code>target</code>：要链接库的对象，该对象有可能是源文件、动态库文件、可执行文件。</p>
<p><code>PRIVATE|PUBLIC|INTERFACE：</code>动态库的访问权限，默认为PUBLIC</p>
<p>​		PUBLIC：在public后面的库会被Link到前面的target中，并且里面的符号也会被导出，提供给第三方使用。<br>​		PRIVATE：在private后面的库仅被link到前面的target中，并且终结掉，第三方不能感知你调了啥库<br>​		INTERFACE：在interface后面引入的库不会被链接到前面的target中，只会导出符号。</p>
<p><code>item</code>：库的名字，一般都会掐头去尾，如全名为<code>libpthread.so</code>的动态库，使用如下语法即可：</p>
<p><code>target_link_libraries(app pthread)</code></p>
<h6 id="9-list"><a href="#9-list" class="headerlink" title="9. list()"></a>9. list()</h6><p><em>功能1：字符串拼接</em></p>
<ul>
<li>语法</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(APPEND &lt;<span class="keyword">list</span>&gt; [&lt;element&gt; ...])</span><br><span class="line"><span class="comment"># APPEND 表示进行数据追加</span></span><br><span class="line"><span class="comment"># &lt;list&gt; 要追加的列表的名字</span></span><br><span class="line"><span class="comment"># &lt;element&gt; 待追加的元素</span></span><br></pre></td></tr></table></figure>

<ul>
<li>示例</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src1/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_2 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src2/*.cpp)</span><br><span class="line"><span class="comment"># 追加(拼接)</span></span><br><span class="line"><span class="keyword">list</span>(APPEND SRC_1 <span class="variable">$&#123;SRC_1&#125;</span> <span class="variable">$&#123;SRC_2&#125;</span>)</span><br></pre></td></tr></table></figure>

<p><em>功能2：字符串移除</em></p>
<ul>
<li>使用场景</li>
</ul>
<p>假设我们在通过<code>file</code>搜索某个目录下所有的源文件，但是其中有些源文件并不是我们所需要的，需要移除。</p>
<ul>
<li>语法</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(REMOVE_ITEM &lt;<span class="keyword">list</span>&gt; &lt;value&gt; [&lt;value&gt; ...])</span><br><span class="line"><span class="comment"># REMOVE_ITEM 表示进行数据移除</span></span><br><span class="line"><span class="comment"># 其他参数和数据追加一样</span></span><br></pre></td></tr></table></figure>

<ul>
<li>示例</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/*.cpp)</span><br><span class="line"><span class="comment"># 移除前日志</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;message: $&#123;SRC_1&#125;&quot;</span>)</span><br><span class="line"><span class="comment"># 移除 main.cpp</span></span><br><span class="line"><span class="keyword">list</span>(REMOVE_ITEM SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/main.cpp)</span><br><span class="line"><span class="comment"># 移除后日志</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;message: $&#123;SRC_1&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<h6 id="10-add-definitions"><a href="#10-add-definitions" class="headerlink" title="10. add_definitions()"></a>10. add_definitions()</h6><ul>
<li>作用</li>
</ul>
<p>相当于在代码中定义一个宏</p>
<ul>
<li>语法</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_definitions</span>(-D宏名称)</span><br></pre></td></tr></table></figure>

<h6 id="11-读取shell脚本export变量"><a href="#11-读取shell脚本export变量" class="headerlink" title="11. 读取shell脚本export变量"></a>11. 读取shell脚本export变量</h6><p>首先，我们在shell脚本中设置环境变量，使用<code>export</code>命令，假设我们有如下的<code>test.sh</code>脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash  </span></span><br><span class="line"><span class="built_in">export</span> VAR=<span class="string">&quot;1234&quot;</span>  </span><br></pre></td></tr></table></figure>

<p>运行这个shell脚本，会获得<code>VAR</code>变量。p.s.注意，要<code>source</code>的运行方式。如果不这样运行，那么只能在<code>shell</code>脚本中执行<code>cmake</code>命令以获取变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. test.sh</span><br></pre></td></tr></table></figure>

<p>对于CMake，它可以在运行时读取这些环境变量。在CMakeLists.txt文件中，你可以使用<code>$ENV</code>变量来获取环境变量的值。例如：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;VAR: $ENV&#123;VAR1&#125;&quot;</span>)  </span><br></pre></td></tr></table></figure>

<h5 id="3-2-流程控制"><a href="#3-2-流程控制" class="headerlink" title="3.2 流程控制"></a>3.2 流程控制</h5><p><a target="_blank" rel="noopener" href="https://subingwen.cn/cmake/CMake-advanced/">CMake 保姆级教程（下） | 爱编程的大丙 (subingwen.cn)</a></p>
<h5 id="3-3-cmakelist模板"><a href="#3-3-cmakelist模板" class="headerlink" title="3.3 cmakelist模板"></a>3.3 cmakelist模板</h5><h6 id="1-使用file打包的模板"><a href="#1-使用file打包的模板" class="headerlink" title="1.使用file打包的模板"></a><strong>1.使用file打包的模板</strong></h6><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"><span class="keyword">project</span>(test0606)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(yaml-cpp REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置可执行文件的路径</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 添加src目录下以及所有子目录下的.cpp</span></span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE SOURCES   <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.c</span><br><span class="line">                            <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cxx</span><br><span class="line">                            <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp</span><br><span class="line">                            <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;SOURCES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含头文件</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PRIVATE  <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/inc</span><br><span class="line">                                                    <span class="variable">$&#123;YAML_CPP_INCLUDE_DIR&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含库文件</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PRIVATE yaml-cpp)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-使用Cmake编译Qt的模板"><a href="#2-使用Cmake编译Qt的模板" class="headerlink" title="2.使用Cmake编译Qt的模板"></a><strong>2.使用Cmake编译Qt的模板</strong></h6><p>说明，工程文件结构如下图所示：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(QPlan LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置qt的安装路径</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_PREFIX_PATH <span class="string">&quot;D:\\Qt\\Qt5.12.12\\5.12.12\\mingw73_64\\&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译出支持gdb调试的程序</span></span><br><span class="line"><span class="keyword">add_compile_options</span>(-g)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启MOC,RCC和UIC，则会在预处理之前先进行MOC、RCC、UIC操作</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTOMOC <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTORCC <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTOUIC <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找需要的Qt库</span></span><br><span class="line"><span class="keyword">find_package</span>(Qt5 COMPONENTS Core Gui Widgets REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置UIC的查找路径，uic默认在引入ui文件的源代码路径中查找ui文件，而我们的Ui文件放在ui文件夹下，所以要修改查找路径</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTOUIC_SEARCH_PATHS <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/ui)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置可执行文件的输出路径为/bin文件夹下</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将.cpp &amp;&amp; .qrc &amp;&amp; .ui打包</span></span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE <span class="variable">$&#123;PROJECT_NAME&#125;</span>_SOURCES   <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/main.cpp</span><br><span class="line">                                            <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/plan/*.cpp</span><br><span class="line">                                            <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/ui/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE <span class="variable">$&#123;PROJECT_NAME&#125;</span>_UI  <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/ui/*.ui)</span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE <span class="variable">$&#123;PROJECT_NAME&#125;</span>_QRC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/ui/*.qrc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将上述所有文件进行编译和内部链接，ui和qrc以及包含Qt扩展语法的文件，由于开启了MOC,RCC和UIC，因此会被自行处理</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>  <span class="variable">$&#123;$&#123;PROJECT_NAME&#125;</span>_QRC&#125;</span><br><span class="line">                                <span class="variable">$&#123;$&#123;PROJECT_NAME&#125;</span>_UI&#125;</span><br><span class="line">                                <span class="variable">$&#123;$&#123;PROJECT_NAME&#125;</span>_SOURCES&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加头文件目录</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PRIVATE <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可执行文件和Qt的库进行链接</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> Qt5::Core Qt5::Gui Qt5::Widgets)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="4 类和对象"></a>4 类和对象</h4><h5 id="4-1-类的构造函数"><a href="#4-1-类的构造函数" class="headerlink" title="4.1 类的构造函数"></a>4.1 类的构造函数</h5><h6 id="1-构造函数分类"><a href="#1-构造函数分类" class="headerlink" title="1. 构造函数分类"></a>1. 构造函数分类</h6><p>在 C++ 中一个类有以下 6 种特殊的成员函数需要关注</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(); <span class="comment">// default constructor</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">X</span>();            <span class="comment">// destructor (virtual if X is meant to be a base class)</span></span><br><span class="line">    <span class="built_in">X</span>(<span class="type">const</span> X&amp;);             <span class="comment">// copy constructor</span></span><br><span class="line">    X&amp; <span class="keyword">operator</span>=(<span class="type">const</span> X&amp;);  <span class="comment">// copy assignment</span></span><br><span class="line">    <span class="built_in">X</span>(X&amp;&amp;);                  <span class="comment">// move constructor</span></span><br><span class="line">    X&amp; <span class="keyword">operator</span>=(X&amp;&amp;);       <span class="comment">// move assignment</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>说明1：</strong></p>
<ul>
<li>以上六种特殊的成员函数可以加上 <code>= default</code> 让编译器自动生成， 或者 <code>= delete</code> 阻止编译器自动生成相应的函数定义</li>
<li><code>X::X()</code> 默认构造函数 如果没有声明为 <code>=delete</code>,编译器将会自动生成定义。但是如果用户声明了其他形式的构造函数如<code>X(int x)</code> , 编译器将不会自动生成，除非用户手动定义。</li>
<li><code>X(const X&amp;)</code> 和 <code>X&amp; operator=(const X&amp;)</code> 如果没有用户指定，在需要的时候编译器会自动生成，内容为对成员的值拷贝，如果是指针成员将是”浅复制”。</li>
<li>对除<code>X::X()</code> 默认构造函数之外的特殊成员函数的声明，哪怕是<code>=default</code>或<code>delete</code>，将会阻止编译器生成 <code>move constructor/assignment</code>; 将会导致该类无法使用移动语义；</li>
<li>如果程序员只声明了<code>move constructor/assignment</code>, 编译器隐式生成的复制和赋值语义将会声明为<code>delete</code>, 也就是 class 将是 move-only 的。</li>
</ul>
<p><strong>说明2：</strong></p>
<p>不管哪种构造函数，其基本功能就是在创建对象时调用。比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Complex c2 = c1;	<span class="comment">// 以拷贝的方式初始化对象时，调用复制构造函数，而不是调用重载的operator=</span></span><br><span class="line">Complex c2 = <span class="number">12.5</span>; <span class="keyword">or</span> Complex c2; c2 = <span class="number">12.5</span> <span class="comment">// 调用转换构造函数，将其它类型转换成当前类类型</span></span><br></pre></td></tr></table></figure>

<p>我们可以使用explicit关键字，来屏蔽转换构造函数的功能，禁止将其他类转换成当前类。</p>
<h6 id="2-类成员的初始化"><a href="#2-类成员的初始化" class="headerlink" title="2. 类成员的初始化"></a>2. 类成员的初始化</h6><ul>
<li><p>const修饰的成员变量只能在类内初始化（C++11)或者用初始化列表初始化，不能在构造函数语句中初始化（编译器会报错）</p>
</li>
<li><p>类的初始化顺序为，先类内初始化，然后初始化列表，最后才是构造函数中的语句。</p>
</li>
<li><p>如何初始化vector对象？(c++11)</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt; name = <span class="built_in">vector</span>&lt;string&gt;(<span class="number">5</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; val&#123;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>,<span class="number">0</span>)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-在构造函数中打印类名"><a href="#3-在构造函数中打印类名" class="headerlink" title="3. 在构造函数中打印类名"></a>3. 在构造函数中打印类名</h6><p>想要打印类名，只需要在类的构造函数中使用<code>__func__</code>宏。同样的，在普通函数中使用<code>__func__</code>宏，一样可以打印函数的名字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        name = __func__;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="4-三-五-零法则"><a href="#4-三-五-零法则" class="headerlink" title="4. 三&#x2F;五&#x2F;零法则"></a>4. 三&#x2F;五&#x2F;零法则</h6><ol>
<li>Rule Of Three</li>
</ol>
<p>如果需要自定义<code>析构函数</code>，那么就也需要自定义的<code>copy constructor</code>和自定义的 <code>copy- assignment constructor</code>， 这三个往往同时需要自定义。</p>
<p>具体而言：需要对资源进行管理（例如 raw pointer, POSIX 文件描述符）的时候，需要自己实现析构&#x2F;复制&#x2F;赋值构造函数, 编译器自动生成的往往是浅复制。</p>
<ol start="2">
<li>Rule of Five</li>
</ol>
<blockquote>
<p>Because the presence of a user-defined destructor, copy-constructor, or copy-assignment operator prevents implicit definition of the move constructor and the move assignment operator, any class for which move semantics are desirable, has to declare all five special member functions:</p>
</blockquote>
<p>自定义<code>destructor, copy-constructor, or copy-assignment </code>，编译器不会生成默认的<code>move constructor</code>和<code>move assignment operator</code>。在这种情况下，如果需要移动语义，需要自己定义这 5 个特殊成员函数，移动语义主要是为了性能。</p>
<ol start="3">
<li>Rule of Zero</li>
</ol>
<p>如果不需要手动定义， 就不要定义，一切让它默认。</p>
<h4 id="5-STL库"><a href="#5-STL库" class="headerlink" title="5 STL库"></a>5 STL库</h4><h5 id="5-1-array"><a href="#5-1-array" class="headerlink" title="5.1 array"></a>5.1 array</h5><h6 id="1-将普通c数组转成std-array"><a href="#1-将普通c数组转成std-array" class="headerlink" title="1. 将普通c数组转成std::array"></a>1. 将普通c数组转成std::array</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建二维c数组和二维std::array</span></span><br><span class="line">    <span class="type">int</span> c_array[<span class="number">3</span>][<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    std::array&lt;std::array&lt;<span class="type">int</span>, 2&gt;, 3&gt; array1&#123;&#125;;</span><br><span class="line">    <span class="comment">// 方法1:std::copy</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>; i&lt;array<span class="number">1.</span><span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        std::<span class="built_in">copy</span>(c_array[i], c_array[i]+array<span class="number">1.</span><span class="built_in">at</span>(i).<span class="built_in">size</span>(), array<span class="number">1.</span><span class="built_in">at</span>(i).<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法2:memcpy</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;array1, c_array, <span class="built_in">sizeof</span>(c_array));</span><br><span class="line">    <span class="comment">// 打印std::array</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item : array1)&#123;</span><br><span class="line">        cout &lt;&lt; item.<span class="built_in">at</span>(<span class="number">0</span>) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.<span class="built_in">at</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>

<h6 id="2-std-array赋初始值"><a href="#2-std-array赋初始值" class="headerlink" title="2. std::array赋初始值"></a>2. std::array赋初始值</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="5-2-priority-queue"><a href="#5-2-priority-queue" class="headerlink" title="5.2 priority_queue"></a>5.2 priority_queue</h5><p>优先级队列定义了一个有序排列的队列，队列头部的元素优先级最高。只能访问头部的元素。这个优先级的定义取决于我们自己。</p>
<img src="images/image-20230626104443233.png" alt="image-20230626104443233" style="zoom: 67%;" />

<p>示例代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h2><h4 id="1-智能指针"><a href="#1-智能指针" class="headerlink" title="1 智能指针"></a>1 智能指针</h4><p>智能指针可以在适当时机自动释放分配的堆区内存。也就是说，使用智能指针可以很好地避免”忘记释放内存而导致内存泄漏”问题出现。由此可见，C++ 也逐渐开始支持垃圾回收机制了，尽管目前支持程度还有限。</p>
<p>shared_ptr指针</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/7898.html">C++11 shared_ptr智能指针（超级详细） (biancheng.net)</a></p>
</blockquote>
<p>unique_ptr指针</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/7909.html">C++11 unique_ptr智能指针详解 (biancheng.net)</a></p>
</blockquote>
<h4 id="2-lambda匿名函数"><a href="#2-lambda匿名函数" class="headerlink" title="2 lambda匿名函数"></a>2 lambda匿名函数</h4><h5 id="2-1-语法格式"><a href="#2-1-语法格式" class="headerlink" title="2.1 语法格式"></a>2.1 语法格式</h5><p>匿名函数的语法格式如下：</p>
<p><code>[capture](params) opt -&gt; ret &#123;body;&#125;;</code></p>
<ul>
<li>捕获列表(capture):捕获一定范围内的变量</li>
</ul>
<p>​			[] - 不捕捉任何变量</p>
<p>​			[&amp;] - 捕获外部作用域中所有变量，并作为引用在函数体内使用 (按引用捕获)</p>
<p>​			[&#x3D;] - 捕获外部作用域中所有变量，并作为副本在函数体内使用 (按值捕获)，拷贝的副本在匿名函数体内部是只读的</p>
<p>​			[&#x3D;, &amp;foo] - 按值捕获外部作用域中所有变量，并按照引用捕获外部变量 foo</p>
<p>​			[bar] - 按值捕获 bar 变量，同时不捕获其他变量</p>
<p>​			[&amp;bar] - 按引用捕获 bar 变量，同时不捕获其他变量</p>
<p>​			[this] - 捕获当前类中的 this 指针， 让 lambda 表达式拥有和当前类成员函数同样的访问权限，如果已经使用了 &amp; 或者 &#x3D;, 默认添加此选项。</p>
<ul>
<li><p>参数列表(params)：和普通的函数一样</p>
</li>
<li><p>opt选项（可以省略）</p>
<p>​    mutable: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）<br>​    exception: 指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw ();</p>
</li>
<li><p>返回值类型ret（一般省略）</p>
</li>
</ul>
<p>​			标识函数返回值的类型， 编译器可以自动推导，可以省略</p>
<ul>
<li>函数体：和普通函数一样</li>
</ul>
<h5 id="2-2-定义和调用"><a href="#2-2-定义和调用" class="headerlink" title="2.2 定义和调用"></a>2.2 定义和调用</h5><blockquote>
<p>因为 Lambda 表达式是一个匿名函数，因此是没有函数声明的，直接在程序中进行代码的定义即可，但是如果只定义匿名函数在程序执行过程中是不会被调用的。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名函数的定义, 程序执行时，这个匿名函数是不会被调用的</span></span><br><span class="line">[]()&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, 我是一个lambda表达式...&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数的定义+调用:</span></span><br><span class="line"><span class="type">int</span> ret = [](<span class="type">int</span> a) -&gt; <span class="type">int</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a<span class="number">+1</span>;</span><br><span class="line">&#125;(<span class="number">100</span>);  <span class="comment">// 100是传递给匿名函数的参数</span></span><br></pre></td></tr></table></figure>



<h4 id="3-比较两个对象是不是同类型"><a href="#3-比较两个对象是不是同类型" class="headerlink" title="3 比较两个对象是不是同类型"></a>3 比较两个对象是不是同类型</h4><p>可以使用如下方式来对比两个对象是不是同类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include &lt;type_traits&gt;</span><br><span class="line">cout &lt;&lt; std::<span class="built_in">is_same</span>&lt;<span class="type">int</span> , <span class="type">int</span>&gt;() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h4 id="4-std-move的使用"><a href="#4-std-move的使用" class="headerlink" title="4 std::move的使用"></a>4 std::move的使用</h4><p>左值：可以取地址的值，比如变量，数组元素，类成员等</p>
<p>右值：临时的、即将消亡的值，无法取地址。比如字面常量(5, 3.14)、临时对象等。</p>
<h5 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h5><ul>
<li><p>std::move 是什么？</p>
<ol>
<li><p>C++11 引入的一个函数，它会生成对象的右值引用，以便调用移动构造函数。</p>
</li>
<li><p>它本身不移动任何东西，只是将对象标记为可移动</p>
</li>
</ol>
</li>
<li><p>std::move()的使用场景：</p>
</li>
</ul>
<p>​	为了效率：可以避免不必要的复制，尤其针对大数据量的自定义类。</p>
<ul>
<li>注意事项<ol>
<li>如果一个对象object被std::move()以后，那么这个对象虽然可以被访问，但是访问的都是一些随机值。</li>
</ol>
</li>
</ul>
<h5 id="4-2-测试实践"><a href="#4-2-测试实践" class="headerlink" title="4.2 测试实践"></a>4.2 测试实践</h5><ol>
<li><p>使用轻量级Point2f测试</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point2f</span> &#123;</span><br><span class="line">  <span class="type">float</span> x;</span><br><span class="line">  <span class="type">float</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="built_in">Point2f</span>(<span class="type">float</span> x = <span class="number">0.0f</span>, <span class="type">float</span> y = <span class="number">0.0f</span>) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">  <span class="built_in">Point2f</span>(<span class="type">const</span> Point2f&amp; other) : <span class="built_in">x</span>(other.x), <span class="built_in">y</span>(other.y) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">  Point2f&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Point2f&amp; other) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">      x = other.x;</span><br><span class="line">      y = other.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移动构造函数</span></span><br><span class="line">  <span class="built_in">Point2f</span>(Point2f&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">x</span>(other.x), <span class="built_in">y</span>(other.y) &#123;</span><br><span class="line">    other.x = <span class="number">0.0f</span>;</span><br><span class="line">    other.y = <span class="number">0.0f</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移动赋值运算符</span></span><br><span class="line">  Point2f&amp; <span class="keyword">operator</span>=(Point2f&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">      x = other.x;</span><br><span class="line">      y = other.y;</span><br><span class="line">      other.x = <span class="number">0.0f</span>;</span><br><span class="line">      other.y = <span class="number">0.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPoint</span><span class="params">(<span class="type">const</span> Point2f&amp; p)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 测试std::move()移动语义耗时</span></span><br><span class="line">  std::vector&lt;Point2f&gt; points;</span><br><span class="line">  <span class="type">clock_t</span> start = <span class="built_in">clock</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1e4</span>; ++i) &#123;</span><br><span class="line">    <span class="function">Point2f <span class="title">p1</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>)</span></span>;</span><br><span class="line">    points.<span class="built_in">push_back</span>(p1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">clock</span>() - start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 测试std::move()移动语义耗时</span></span><br><span class="line">  std::vector&lt;Point2f&gt; points;</span><br><span class="line">  <span class="type">clock_t</span> start = <span class="built_in">clock</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1e4</span>; ++i) &#123;</span><br><span class="line">    <span class="function">Point2f <span class="title">p1</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>)</span></span>;</span><br><span class="line">    points.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(p1));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">clock</span>() - start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> t1 = <span class="number">0</span>, t2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">    t1 += <span class="built_in">test01</span>();</span><br><span class="line">    t2 += <span class="built_in">test02</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;test01()平均耗时: &quot;</span> &lt;&lt; t1 / <span class="number">100</span> &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;test02()平均耗时: &quot;</span> &lt;&lt; t2 / <span class="number">100</span> &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push_back()平均耗时: 440ms</span><br><span class="line">push_back(std::move())平均耗时: 529ms</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用重量级类测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;logger.h&quot;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;utility&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">// 定义一个包含大量资源的类，移动操作会有明显优势</span><br><span class="line">class HeavyResource &#123;</span><br><span class="line">private:</span><br><span class="line">  std::vector&lt;double&gt; data; // 大量数据</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">  // 构造函数</span><br><span class="line">  HeavyResource(size_t size = 1000000) : data(size, 1.0) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 拷贝构造函数</span><br><span class="line">  HeavyResource(const HeavyResource&amp; other) : data(other.data) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 移动构造函数</span><br><span class="line">  HeavyResource(HeavyResource&amp;&amp; other) noexcept : data(std::move(other.data)) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  // 返回数据大小</span><br><span class="line">  size_t size() const &#123; return data.size(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 使用拷贝方式</span><br><span class="line">int test01() &#123;</span><br><span class="line">  std::vector&lt;HeavyResource&gt; resources;</span><br><span class="line">  auto start = std::chrono::high_resolution_clock::now();</span><br><span class="line"></span><br><span class="line">  for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">    HeavyResource r;        // 创建临时资源</span><br><span class="line">    resources.push_back(r); // 触发拷贝构造</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  auto end = std::chrono::high_resolution_clock::now();</span><br><span class="line">  return std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start).count();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用移动语义</span><br><span class="line">int test02() &#123;</span><br><span class="line">  std::vector&lt;HeavyResource&gt; resources;</span><br><span class="line">  auto start = std::chrono::high_resolution_clock::now();</span><br><span class="line"></span><br><span class="line">  for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">    HeavyResource r;                   // 创建临时资源</span><br><span class="line">    resources.push_back(std::move(r)); // 触发移动构造</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  auto end = std::chrono::high_resolution_clock::now();</span><br><span class="line">  return std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start).count();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用右值引用</span><br><span class="line">int test03() &#123;</span><br><span class="line">  std::vector&lt;HeavyResource&gt; resources;</span><br><span class="line">  auto start = std::chrono::high_resolution_clock::now();</span><br><span class="line"></span><br><span class="line">  for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">    resources.push_back(HeavyResource()); // 编译器会优化为移动</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  auto end = std::chrono::high_resolution_clock::now();</span><br><span class="line">  return std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start).count();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用emplace_back</span><br><span class="line">int test04() &#123;</span><br><span class="line">  std::vector&lt;HeavyResource&gt; resources;</span><br><span class="line">  auto start = std::chrono::high_resolution_clock::now();</span><br><span class="line"></span><br><span class="line">  for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">    resources.emplace_back(1000000); // 直接在vector内构造</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  auto end = std::chrono::high_resolution_clock::now();</span><br><span class="line">  return std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start).count();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">  // 预热</span><br><span class="line">  HeavyResource r;</span><br><span class="line"></span><br><span class="line">  // 进行测试</span><br><span class="line">  std::cout &lt;&lt; &quot;测试开始，每种方法重复5次...&quot; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  int t1 = 0, t2 = 0, t3 = 0, t4 = 0;</span><br><span class="line">  for (int i = 0; i &lt; 5; ++i) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;\n第&quot; &lt;&lt; (i + 1) &lt;&lt; &quot;次测试：&quot; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    int copy_time = test01();</span><br><span class="line">    int move_time = test02();</span><br><span class="line">    int rvalue_time = test03();</span><br><span class="line">    int emplace_time = test04();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;拷贝方式耗时: &quot; &lt;&lt; copy_time &lt;&lt; &quot;ms&quot; &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;移动语义耗时: &quot; &lt;&lt; move_time &lt;&lt; &quot;ms&quot; &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;右值引用耗时: &quot; &lt;&lt; rvalue_time &lt;&lt; &quot;ms&quot; &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;emplace耗时: &quot; &lt;&lt; emplace_time &lt;&lt; &quot;ms&quot; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    t1 += copy_time;</span><br><span class="line">    t2 += move_time;</span><br><span class="line">    t3 += rvalue_time;</span><br><span class="line">    t4 += emplace_time;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; &quot;\n======== 测试结果 ========&quot; &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; &quot;拷贝方式平均耗时: &quot; &lt;&lt; t1 / 5 &lt;&lt; &quot;ms&quot; &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; &quot;移动语义平均耗时: &quot; &lt;&lt; t2 / 5 &lt;&lt; &quot;ms&quot; &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; &quot;右值引用平均耗时: &quot; &lt;&lt; t3 / 5 &lt;&lt; &quot;ms&quot; &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; &quot;emplace平均耗时: &quot; &lt;&lt; t4 / 5 &lt;&lt; &quot;ms&quot; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">测试开始，每种方法重复5次...</span><br><span class="line"></span><br><span class="line">第1次测试：</span><br><span class="line">拷贝方式耗时: 168ms</span><br><span class="line">移动语义耗时: 33ms</span><br><span class="line">右值引用耗时: 33ms</span><br><span class="line">emplace耗时: 29ms</span><br><span class="line"></span><br><span class="line">第2次测试：</span><br><span class="line">拷贝方式耗时: 49ms</span><br><span class="line">移动语义耗时: 31ms</span><br><span class="line">右值引用耗时: 32ms</span><br><span class="line">emplace耗时: 31ms</span><br><span class="line"></span><br><span class="line">第3次测试：</span><br><span class="line">拷贝方式耗时: 51ms</span><br><span class="line">移动语义耗时: 34ms</span><br><span class="line">右值引用耗时: 33ms</span><br><span class="line">emplace耗时: 33ms</span><br><span class="line"></span><br><span class="line">第4次测试：</span><br><span class="line">拷贝方式耗时: 51ms</span><br><span class="line">移动语义耗时: 33ms</span><br><span class="line">右值引用耗时: 33ms</span><br><span class="line">emplace耗时: 33ms</span><br><span class="line"></span><br><span class="line">第5次测试：</span><br><span class="line">拷贝方式耗时: 51ms</span><br><span class="line">移动语义耗时: 32ms</span><br><span class="line">右值引用耗时: 32ms</span><br><span class="line">emplace耗时: 31ms</span><br><span class="line"></span><br><span class="line">======== 测试结果 ========</span><br><span class="line">拷贝方式平均耗时: 74ms</span><br><span class="line">移动语义平均耗时: 32ms</span><br><span class="line">右值引用平均耗时: 32ms</span><br><span class="line">emplace平均耗时: 31ms</span><br></pre></td></tr></table></figure>

<p>参考：<br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/3413470/what-is-stdmove-and-when-should-it-be-used">https://stackoverflow.com/questions/3413470/what-is-stdmove-and-when-should-it-be-used</a></p>
</li>
</ol>
<h2 id="C-多线程并发"><a href="#C-多线程并发" class="headerlink" title="C++多线程并发"></a>C++多线程并发</h2><h4 id="0-并发的方式"><a href="#0-并发的方式" class="headerlink" title="0 并发的方式"></a>0 并发的方式</h4><h5 id="0-1-多进程并发"><a href="#0-1-多进程并发" class="headerlink" title="0.1 多进程并发"></a>0.1 多进程并发</h5><p>应用程序分为多个独立的进程同时运行，独立的进程可以通过进程间的通信渠道传递讯息(信号、套接字、文件、管道等等)。</p>
<p>优点：1. 可以在不同的机器运行不同的进程，然后使用进程间通信</p>
<p>缺点：1. 进程间的通信通常非常复杂，或是速度很慢。</p>
<p>​			2. 还有一个缺点是运行多个进程的固定开销：需要时间启动进程，操作系统需要</p>
<p>资源来管理进程等等。</p>
<h5 id="0-2-多线程并发"><a href="#0-2-多线程并发" class="headerlink" title="0.2 多线程并发"></a>0.2 多线程并发</h5><p>在单进程中运行多个线程。</p>
<p>优点：1. 进程中的所有线程都共享地址空间，并且能访问到大部分数据———全局变量仍然是全局的	</p>
<p>​            2. 开销小</p>
<p>缺点：</p>
<p>共享内存的灵活性是有代价的：如果多个线程访问数据，那么必须确保每个线程所访问到的数据一致，这就需要对线程通信做大量的工作。</p>
<blockquote>
<p>讲在前面：每个程序都是一个进程，并且至少有一个线程：执行main()函数的线程。其余线程有其各自的入口函数。线程与原始线程(以main()为入口函数的线程)同时运行。如同main()函数执行完会退出一样，当线程执行完入口函数后，线程也会退出。  </p>
</blockquote>
<h4 id="1-多线程的创建"><a href="#1-多线程的创建" class="headerlink" title="1 多线程的创建"></a>1 多线程的创建</h4><h5 id="1-1-多线程创建的4种方式"><a href="#1-1-多线程创建的4种方式" class="headerlink" title="1.1 多线程创建的4种方式"></a>1.1 多线程创建的4种方式</h5><p>使用C++线程库<code>&lt;thread&gt;</code>创建线程，可以归结为构造<code>std::thread</code>对象 。</p>
<ol>
<li>使用函数指针的方式创建多线程：定义普通函数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_some_work</span><span class="params">(<span class="type">int</span> a)</span></span>; <span class="comment">// 线程的入口函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">my_thread</span><span class="params">(do_some_work, a)</span></span>;	<span class="comment">// 以值传递的方式传递参数。如果有更多的参数，都加载a后面即可</span></span><br><span class="line">    my_thread.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用仿函数创建多线程：重载operator()运算符</li>
</ol>
<blockquote>
<p>p.s.在C++中，我们把所有能当做函数使用的对象统称为函数对象 ，函数对象有三种：普通函数，仿函数(Functor)，lambda函数</p>
</blockquote>
<p><strong>注意事项</strong>：当把函数对象（其实是个临时的匿名对象）传入到线程构造函数中时，需要避免语法歧义。<br>例如，这个写法<code>std::thread test_thread(PersonHyh())</code><br>相当于声明了一个名为test_thread的函数，返回值为std::thread的函数。而不是启动了一个线程。<br>所以，用仿函数创建一个线程时，</p>
<ol>
<li>给函数对象加上一对括号，来避免语法歧义<code>std::thread test_thread((PersonHyh()))</code></li>
<li>使用初始化语法，<code>std::thread test_thread&#123;PersonHyh()&#125;</code></li>
</ol>
<p><strong>代码示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PersonHyh</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;重载()运算符&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">test_thread</span><span class="params">((PersonHyh()))</span></span>; <span class="comment">// 使用匿名对象创建</span></span><br><span class="line">    PersonHyh hyh;</span><br><span class="line">    <span class="function">std::thread <span class="title">test_thread2</span><span class="params">(hyh)</span></span>;</span><br><span class="line">    test_thread.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用Lambda函数创建多线程</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">my_thread</span><span class="params">([]&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">  do_something();</span></span></span><br><span class="line"><span class="params"><span class="function">  do_something_else();</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用类的成员函数创建多线程</li>
</ol>
<p>4.1 普通成员函数</p>
<p>下面代码中，新线程将对象foo的成员函数do_lengthy_work()作为线程函数；</p>
<p>使用非静态成员函数创建线程时，std::thread构造函数的第一个参数是成员函数的地址，第二个参数是对象的地址，第三个参数才是成员函数的第一个参数，若成员函数还有其他参数，继续往后加就行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">do_lengthy_work</span><span class="params">(<span class="type">int</span> num)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Foo foo;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t</span><span class="params">(&amp;Foo::do_lengthy_work,&amp;foo, num)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.2 静态成员函数</p>
<p>使用静态成员函数创建多线程时，直接将静态成员函数的地址传入多线程构造函数即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static member function</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">           cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(&amp;Base::fun, <span class="number">10</span>)</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>

<h5 id="1-2-创建线程时传递参数"><a href="#1-2-创建线程时传递参数" class="headerlink" title="1.2 创建线程时传递参数"></a>1.2 创建线程时传递参数</h5><h6 id="1-值传递"><a href="#1-值传递" class="headerlink" title="1. 值传递"></a>1. 值传递</h6><p>如下面代码种方法1所示，线程入口函数thread_entry_func期望得到一个对象的引用。但是如果直接传递参数的话，std::thread的构造函数会无视入口函数的期待参数类型，直接拷贝已提供的参数变量。</p>
<h6 id="2-引用传递"><a href="#2-引用传递" class="headerlink" title="2. 引用传递"></a>2. 引用传递</h6><p>只有用std::ref()方法传递参数时，才是真正的引用传递，如方法2所示。</p>
<p>p.s.:需要注意的是，调用引用的时候，<strong>函数对象的参数列表也需要是引用类型</strong>。否则，即使线程构造函数处传递的是引用，也只是一个值传递。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PersonHyh</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PersonHyh</span>()&#123;cout &lt;&lt; <span class="string">&quot;构造函数被调用了&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    <span class="built_in">PersonHyh</span>(<span class="type">const</span> PersonHyh&amp; personHyh)&#123;cout &lt;&lt; <span class="string">&quot;复制构造函数被调用了&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_entry_func</span><span class="params">(<span class="type">const</span> PersonHyh&amp; personHyh)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;在线程函数中，personHyh的地址为： &quot;</span>&lt;&lt;  &amp;personHyh &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    PersonHyh personHyh;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;personHyh对象的原生地址为：&quot;</span> &lt;&lt; &amp;personHyh &lt;&lt; endl;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread_value_pass</span><span class="params">(thread_entry_func, personHyh)</span></span>;  <span class="comment">// 方法1</span></span><br><span class="line">    <span class="function">std::thread <span class="title">thread_reference_pass</span><span class="params">(thread_entry_func, std::ref(personHyh))</span></span>; <span class="comment">//方法2</span></span><br><span class="line">    thread_value_pass.<span class="built_in">join</span>();</span><br><span class="line">    thread_reference_pass.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-线程等待和分离"><a href="#2-线程等待和分离" class="headerlink" title="2 线程等待和分离"></a>2 线程等待和分离</h4><p><code>my_thread.join();</code>  &#x2F;&#x2F; 主线程一直阻塞等待，直到调用.join()的线程执行完毕。</p>
<p><code>my_thread.detach();</code> &#x2F;&#x2F; 主线程和分线程分离，分别执行，互不干扰</p>
<p>有以下几点：</p>
<ol>
<li><p>在对象<code>std::thread</code>销毁之前，必须要对线程调用join()或者detach()，否则 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/thread">std::thread</a> 的析构函数会调用 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/error/terminate">std::terminate</a> 终止程序。</p>
</li>
<li><p>只要创建了线程，那么线程就从入口函数处开始执行。所以不应该在创建完线程后马上join。这样会导致主线程阻塞，一直等待子线程的执行完，所以应该在晚一点的位置调用.join()。</p>
</li>
<li><p>如果想要分离线程，可以在线程启动后，直接使用detach()进行分离。</p>
</li>
</ol>
<h4 id="3-互斥量（锁）的使用"><a href="#3-互斥量（锁）的使用" class="headerlink" title="3 互斥量（锁）的使用"></a>3 互斥量（锁）的使用</h4><blockquote>
<p>c++锁相关的类，定义在<mutex>中</p>
</blockquote>
<p>互斥就是保证线程之间共享的内存资源，同一时刻只被一个进程使用；</p>
<h5 id="3-1-通过lock-和unlock-管理互斥量"><a href="#3-1-通过lock-和unlock-管理互斥量" class="headerlink" title="3.1 通过lock()和unlock()管理互斥量"></a>3.1 通过lock()和unlock()管理互斥量</h5><p>注意：1.需要在进入临界区之前对互斥量加锁，退出临界区时对互斥量解锁。当一个线程使用特定的互斥量锁住共享数据时，其他线程想要访问共享数据的话，必须等待之前那个线程对共享数据解锁后，才能访问。</p>
<p>​			2.假设程序创建了一个互斥对象m(<code>std::mutex m</code>)， 本线程在调用m.lock()时会发生如下两种情况：①如果互斥量m当前没有被上锁，那么本线程将互斥量m锁住，直到调用m.unlock()之前，本线程一直拥有该锁。②如果互斥量m已经被其他线程锁住，那么本线程被阻塞，直至m被其它线程解锁后，本线程再执行①中的内容。</p>
<p>​			3.不建议直接对m进行lock()操作，因为如果忘记unlock()。那么会导致互斥锁无法释放。使用后面介绍的lock_guard或者unique_lock可以避免忘记解锁带来的问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MutexExample</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write1</span><span class="params">(<span class="type">int</span>&amp; a)</span></span>&#123;</span><br><span class="line">        mutex_.<span class="built_in">lock</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Write1 is rewriting a&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A&#x27;s address is &quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The original a is &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Now, a is &quot;</span> &lt;&lt; ++a &lt;&lt; endl;</span><br><span class="line">        mutex_.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write2</span><span class="params">(<span class="type">int</span>&amp; a)</span></span>&#123;</span><br><span class="line">        mutex_.<span class="built_in">lock</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Write2 is rewriting a&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A&#x27;s address is &quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The original a is &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Now, a is &quot;</span> &lt;&lt; ++a &lt;&lt; endl;</span><br><span class="line">        mutex_.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex mutex_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    MutexExample example;</span><br><span class="line">    std::thread thread1&#123;&amp;MutexExample::write1, &amp;example, std::<span class="built_in">ref</span>(a)&#125;;</span><br><span class="line">    std::thread thread2&#123;&amp;MutexExample::write2, &amp;example, std::<span class="built_in">ref</span>(a)&#125;;</span><br><span class="line">    thread<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    thread<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-通过lock-guard管理互斥量"><a href="#3-2-通过lock-guard管理互斥量" class="headerlink" title="3.2 通过lock_guard管理互斥量"></a>3.2 通过lock_guard管理互斥量</h5><p>介绍：std::lock_guard()像互斥量的保姆，在创建std::lock_guard()对象时，对互斥量进行加锁。在std::lock_guard()析构时（创建std::lock_guard()作用域结束时）解锁。</p>
<p>**注意：**1.我们可以通过设定作用域，使得std::lock_guard在合适的地方被析构。也就是说，通过使用<code>&#123;&#125;</code>来调整作用域范围，使得互斥量m在合适的地方被解锁。</p>
<p>​			2.小知识：从互斥量锁定到互斥量解锁之间的代码称为<strong>临界区</strong>，也就是需要互斥访问共享资源的那段代码区域，临界区的范围应该尽量的小，也就是lock互斥量之后应该尽快的解锁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MutexExample</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write1</span><span class="params">(<span class="type">int</span>&amp; a)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 此语句代替了mutex_.lock()</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Write1 is rewriting a&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A&#x27;s address is &quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The original a is &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Now, a is &quot;</span> &lt;&lt; ++a &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="comment">// 在guard析构时，自动解锁，相当于调用mutex_.unlock()</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write2</span><span class="params">(<span class="type">int</span>&amp; a)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 通过调整作用域范围，使得mutex_在合适的地方被解锁。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Write2 is rewriting a&quot;</span> &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;A&#x27;s address is &quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;The original a is &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Now, a is &quot;</span> &lt;&lt; ++a &lt;&lt; endl;</span><br><span class="line">            mutex_.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125; <span class="comment">// guard自动解锁互斥量</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Code outside scope&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex mutex_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    MutexExample example;</span><br><span class="line">    std::thread thread1&#123;&amp;MutexExample::write1, &amp;example, std::<span class="built_in">ref</span>(a)&#125;;</span><br><span class="line">    std::thread thread2&#123;&amp;MutexExample::write2, &amp;example, std::<span class="built_in">ref</span>(a)&#125;;</span><br><span class="line">    thread<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    thread<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-通过unique-lock管理互斥量（推荐）"><a href="#3-3-通过unique-lock管理互斥量（推荐）" class="headerlink" title="3.3 通过unique_lock管理互斥量（推荐）"></a>3.3 通过unique_lock管理互斥量（推荐）</h5><p><strong>1. unique_lock的基本用法</strong></p>
<p>std::unique_lock用法和功能都类似于std::lock_gurad，两者都是用来管理互斥量m的；</p>
<p>两者都可以自动给互斥量加锁，解锁。</p>
<p>unique_lock支持lock_guard的所有功能。</p>
<p><strong>不同点在于：</strong></p>
<p>①使用lock_guard后不能手动去lock()和unlock()，但是使用unique_lock后可以手动的去lock()和unlock()。请注意：手动lock的时候，不可以用<code>m.lock()</code>去操作，因为此时互斥量已经被gurad管理了，应该使用guard去加锁，详情见下面代码。</p>
<p>②std::unique_lock的第二个参数，除了是<code>adopt_lock</code>还可以是<code>try_to_lock</code>与<code>defer_lock</code>。<code>try_to_lock</code>:尝试去锁定互斥量m，如果没有锁定成功，不会阻塞在那里，而是继续往下执行。<code>defer_lock</code>: 将互斥量移交到unique_lock管理，并且先不对互斥量加锁</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line">std::mutex m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span>&amp;a )</span></span>&#123;</span><br><span class="line">    <span class="comment">// 将互斥量移交到unique_lock管理，并且先不对互斥量加锁</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(m, std::defer_lock)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func1做一些与共享数据无关的操作&quot;</span> &lt;&lt; endl;</span><br><span class="line">    guard.<span class="built_in">lock</span>(); <span class="comment">// 手动加锁，一定要注意，不是m.lock()，而是guard.lock()，因为此时m已经被guard接管了。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func1操作共享数据&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a 原来的值 &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a 现在的值 &quot;</span> &lt;&lt; ++a &lt;&lt; endl;</span><br><span class="line">    guard.<span class="built_in">unlock</span>(); <span class="comment">// 临时解锁。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func1做一些与共享数据无关的操作 &quot;</span> &lt;&lt; endl;</span><br><span class="line">    guard.<span class="built_in">lock</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func1操作共享数据&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; <span class="comment">// 自动解锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span>&amp; a)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 尝试加锁，如果加锁不成功，将直接执行后面的代码</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(m, std::try_to_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(guard.<span class="built_in">owns_lock</span>())&#123;  <span class="comment">// 如果加锁成功</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func2操作共享数据&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-a 原来的值是&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-a 现在的值是&quot;</span> &lt;&lt; ++a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;加锁后，后面的代码&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; <span class="comment">// 自动解锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    std::thread thread1&#123;func1, std::<span class="built_in">ref</span>(a)&#125;;</span><br><span class="line">    std::thread thread2&#123;func2, std::<span class="built_in">ref</span>(a)&#125;;</span><br><span class="line">    thread<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    thread<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. unique_lock所有权的转移</strong></p>
<p><strong>几点说明：</strong></p>
<ol>
<li>std::mutex对象的所有权不需要手动转移，在创建std::unique_lock对象时，就已经直接接管了std::mutex；</li>
<li>这里说的所有权转移，指的是std::unique_lock对象之间的管理权转移。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::mutex m;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(m)</span></span>; <span class="comment">// 默认给互斥量加上lock</span></span><br><span class="line">    <span class="comment">// 转移所有权，此时由guard2来管理互斥量m</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">guard2</span><span class="params">(std::move(guard))</span></span>;</span><br><span class="line">    guard<span class="number">2.</span><span class="built_in">unlock</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-条件变量的使用"><a href="#4-条件变量的使用" class="headerlink" title="4 条件变量的使用"></a>4 条件变量的使用</h4><blockquote>
<p>c++条件变量相关的类，在头文件<condition_variable>中</p>
</blockquote>
<h5 id="4-1-条件变量的作用"><a href="#4-1-条件变量的作用" class="headerlink" title="4.1 条件变量的作用"></a>4.1 条件变量的作用</h5><p>std::condition_variable类搭配std::mutex类来使用，std::condition_variable对象(std::condition_variable cond;)的作用不是用来管理互斥量的，它的作用是用来同步线程，它的用法相当于编程中常见的flag标志（A、B两个人约定flag&#x3D;true为行动号角，默认flag为false,A不断的检查flag的值,只要B将flag修改为true，A就开始行动）。</p>
<p>类比到std::condition_variable，A、B两个人约定notify_one为行动号角，A就等着（调用wait(),阻塞）,只要B一调用notify_one，A就开始行动（不再阻塞）。</p>
<h5 id="4-2-条件变量的常用api"><a href="#4-2-条件变量的常用api" class="headerlink" title="4.2 条件变量的常用api"></a>4.2 条件变量的常用api</h5><h6 id="1-wait-locker"><a href="#1-wait-locker" class="headerlink" title="1. wait(locker) :"></a>1. wait(locker) :</h6><p>wait函数需要传入一个std::mutex（一般会传入std::unique_lock对象）,即上述的locker。wait函数会自动调用 locker.unlock() 释放锁（因为需要释放锁，所以要传入mutex）并阻塞当前线程，本线程释放锁使得其他的线程得以继续竞争锁。一旦当前线程获得notify(通常是另外某个线程调用 notify_* 唤醒了当前线程)，wait() 函数此时再自动调用 locker.lock()上锁。</p>
<h6 id="2-cond-notify-one"><a href="#2-cond-notify-one" class="headerlink" title="2. cond.notify_one():"></a>2. cond.notify_one():</h6><p> 随机唤醒一个等待的线程</p>
<h6 id="3-cond-notify-all"><a href="#3-cond-notify-all" class="headerlink" title="3. cond.notify_all():"></a>3. cond.notify_all():</h6><p>唤醒所有等待的线程</p>
<h5 id="4-3-条件变量的应用–生产者消费者模型"><a href="#4-3-条件变量的应用–生产者消费者模型" class="headerlink" title="4.3 条件变量的应用–生产者消费者模型"></a>4.3 条件变量的应用–生产者消费者模型</h5><p><strong>模型解释：</strong></p>
<p>生产者-消费者模型是经典的多线程并发协作模型。</p>
<p>生产者用于生产数据，生产一个就往共享数据区存一个，如果共享数据区已满的话，生产者就暂停生产，等待消费者的通知后再启动。</p>
<p>消费者用于消费数据，一个一个的从共享数据区取，如果共享数据区为空的话，消费者就暂停取数据，等待生产者的通知后再启动。</p>
<p>生产者与消费者不能直接交互,它们之间所共享的数据使用队列结构来实现;</p>
<h3 id="C-STL库"><a href="#C-STL库" class="headerlink" title="C++ STL库"></a>C++ STL库</h3><h4 id="1-priority-queue"><a href="#1-priority-queue" class="headerlink" title="1. priority_queue"></a>1. priority_queue</h4><p>头文件：<code>#include &lt;queue&gt;</code></p>
<p>优先级队列是一个有序的队列。</p>
<ul>
<li>只能访问头部的元素</li>
<li>头部元素的优先级最高</li>
<li>优先级可以由自己定义</li>
</ul>
<h5 id="1-1-构造函数"><a href="#1-1-构造函数" class="headerlink" title="1.1 构造函数"></a>1.1 构造函数</h5><p>priority_queue 模板有 3 个参数，第一个参数是存储对象的类型，第二个参数是存储元素的底层容器，第三个参数是函数对象，它决定<code>priority_queue</code>的优先级。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">T</span>,</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Container</span> = std::vector&lt;T&gt;,</span><br><span class="line">    <span class="keyword">class</span> Compare = std::less&lt;<span class="keyword">typename</span> Container::value_type&gt;</span><br><span class="line">&gt; <span class="keyword">class</span> priority_queue;</span><br></pre></td></tr></table></figure>

<p>后两个参数是默认参数：</p>
<ul>
<li>Container：默认对象的储存类型是<code>vector</code></li>
<li>Compare：<code>std::less</code>是一个排序函数对象，决定了容器中最大的元素会排在队列前面。补充：<code>std::greater&lt;&gt;</code>决定容器中的最小的元素排在队列前面。</li>
</ul>
<img src="images/image-20231016145947563.png" alt="image-20231016145947563" style="zoom:50%;" />

<h5 id="1-1-示例"><a href="#1-1-示例" class="headerlink" title="1.1 示例"></a>1.1 示例</h5><p>我们定义如下打印函数，用来打印<code>priority_queue</code>中的元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; name, T q)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot;: \t&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; q.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>查看默认<code>priority_queue</code>的排序</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> data = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>&gt; q1;</span><br><span class="line">    <span class="comment">// 给q1赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : data) &#123;</span><br><span class="line">        q<span class="number">1.</span><span class="built_in">push</span>(elem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;q1&quot;</span>, q1);    <span class="comment">// 打印如下: q1:     9 8 7 6 5 4 3 2 1 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>std::greater&lt;&gt;</code>指定最小元素优先</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> data = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, std::greater&lt;&gt;&gt; q1;</span><br><span class="line">    <span class="comment">// 给q1赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : data) &#123;</span><br><span class="line">        q<span class="number">1.</span><span class="built_in">push</span>(elem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;q1&quot;</span>, q1);    <span class="comment">// 打印如下: q1:     0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用函数对象指定优先级</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt;= b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> data = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, cmp&gt; q1;</span><br><span class="line">    <span class="comment">// 给q1赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;elem: data) &#123;</span><br><span class="line">        q<span class="number">1.</span><span class="built_in">push</span>(elem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;q1&quot;</span>, q1);    <span class="comment">// 打印如下: q1:     0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用lambda对象去指定优先级</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="type">int</span> a, <span class="type">int</span> b)&#123;<span class="keyword">return</span> a &gt;= b;&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> data = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">q1</span>(cmp);</span><br><span class="line">    <span class="comment">// 给q1赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;elem: data) &#123;</span><br><span class="line">        q<span class="number">1.</span><span class="built_in">push</span>(elem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;q1&quot;</span>, q1);    <span class="comment">// 打印如下: q1:     0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-unordered-map"><a href="#2-unordered-map" class="headerlink" title="2. unordered_map"></a>2. unordered_map</h4><p><code>#include &lt;unordered_map&gt;</code></p>
<ul>
<li>关联容器（Associative Containers）、无序容器</li>
<li>其他和<code>map</code>一样，以键值对<code>pair</code>储存数据。</li>
</ul>
<h5 id="2-1-构造函数"><a href="#2-1-构造函数" class="headerlink" title="2.1 构造函数"></a>2.1 构造函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">Key</span>,                        <span class="comment">//键值对中键的类型</span></span><br><span class="line">           <span class="keyword">class</span> <span class="title class_">T</span>,                          <span class="comment">//键值对中值的类型</span></span><br><span class="line">           <span class="keyword">class</span> <span class="title class_">Hash</span> = hash&lt;Key&gt;,           <span class="comment">//容器内部存储键值对所用的哈希函数</span></span><br><span class="line">           <span class="keyword">class</span> Pred = equal_to&lt;Key&gt;,       <span class="comment">//判断各个键值对键相同的规则</span></span><br><span class="line">           <span class="keyword">class</span> Alloc = allocator&lt; pair&lt;<span class="type">const</span> Key,T&gt; &gt;  <span class="comment">// 指定分配器对象的类型</span></span><br><span class="line">           &gt; <span class="keyword">class</span> unordered_map;</span><br></pre></td></tr></table></figure>

<p>以上 5 个参数中，必须显式给前 2 个参数传值，并且除特殊情况外，最多只需要使用前 4 个参数，各自的含义和功能如下表所示。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;key,T&gt;</td>
<td>前 2 个参数分别用于确定键值对中键和值的类型，也就是存储键值对的类型。</td>
</tr>
<tr>
<td>Hash &#x3D; hash<Key></td>
<td>用于指明容器在存储各个键值对时要使用的哈希函数，默认使用 STL 标准库提供的 hash<key> 哈希函数。注意，默认哈希函数只适用于基本数据类型（包括 string 类型），而不适用于自定义的结构体或者类。</td>
</tr>
<tr>
<td>Pred &#x3D; equal_to<Key></td>
<td>unordered_map 容器中key是不能相等的，而判断是否相等的规则，就由此参数指定。默认情况下，使用 STL 标准库中提供的 equal_to<key> 规则，该规则仅支持可直接用 &#x3D;&#x3D; 运算符做比较的数据类型。</td>
</tr>
</tbody></table>
<p>总之，如果<code>key</code>是自定义类型的话，就需要自己指定<code>Hash参数</code>和<code>Pred参数</code>。</p>
<h5 id="2-2-示例"><a href="#2-2-示例" class="headerlink" title="2.2 示例"></a>2.2 示例</h5><img src="images/image-20231017191334059.png" alt="image-20231017191334059" style="zoom: 50%;" />

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://longfei1995.github.io/2024/01/01/cpp/cppUseFuncs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡云浩">
      <meta itemprop="description" content="记录生活，记录工作，记录学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="胡云浩的blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/01/cpp/cppUseFuncs/" class="post-title-link" itemprop="url">C++有用的函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-01-01T00:00:00+08:00">2024-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-10 17:03:22" itemprop="dateModified" datetime="2025-04-10T17:03:22+08:00">2025-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1-C-时间函数"><a href="#1-C-时间函数" class="headerlink" title="1 C++时间函数"></a>1 C++时间函数</h4><h5 id="1-1-获取格式化时间"><a href="#1-1-获取格式化时间" class="headerlink" title="1.1 获取格式化时间"></a>1.1 获取格式化时间</h5><p>使用C++ chrono库获取毫秒级别的时间戳</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="comment">// 格式化毫秒</span></span><br><span class="line"><span class="function">std::string <span class="title">getCurrentFormatTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">// 获取当前的毫秒数</span></span><br><span class="line">    <span class="keyword">auto</span> ms = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(now.<span class="built_in">time_since_epoch</span>()) % <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">// 转换成time_t， 再转换成local_time</span></span><br><span class="line">    <span class="keyword">auto</span> timer = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line">    std::tm bt = *std::<span class="built_in">localtime</span>(&amp;timer);</span><br><span class="line">    <span class="comment">// 构建格式化时间</span></span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">put_time</span>(&amp;bt, <span class="string">&quot;%Y/%m/%d %T&quot;</span>);</span><br><span class="line">    <span class="comment">// ss &lt;&lt; std::put_time(&amp;bt, &quot;%Y/%m/%d %H:%M:%S&quot;); // windows下，上面那条不打印时分秒，用此条即可</span></span><br><span class="line">    ss &lt;&lt; <span class="string">&#x27;.&#x27;</span> &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">3</span>) &lt;&lt; ms.<span class="built_in">count</span>();</span><br><span class="line">    <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">getCurrentFormatTime</span>();	<span class="comment">// 2022/09/06 14:34:51.736</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-获取毫秒时间"><a href="#1-2-获取毫秒时间" class="headerlink" title="1.2 获取毫秒时间"></a>1.2 获取毫秒时间</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">getCurrentMsTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">return</span> std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(now.<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> start =  <span class="built_in">getCurrentMsTime</span>();</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">50</span>));</span><br><span class="line">    <span class="keyword">auto</span> end = <span class="built_in">getCurrentMsTime</span>();</span><br><span class="line">    cout &lt;&lt; end - start &lt;&lt; endl;  <span class="comment">// 结果为50</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-3-从idx-txt中读取一个数"><a href="#1-3-从idx-txt中读取一个数" class="headerlink" title="1.3 从idx.txt中读取一个数"></a>1.3 从idx.txt中读取一个数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指定读取文件的路径+文件名</span></span><br><span class="line">    <span class="type">char</span> txt_name[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(txt_name, <span class="string">&quot;idx.txt&quot;</span>);</span><br><span class="line">    std::ifstream inf;</span><br><span class="line">    inf.<span class="built_in">open</span>(txt_name, std::ios::in);</span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="comment">// 文件存在时读取里面的数，并且将其加1</span></span><br><span class="line">    <span class="keyword">if</span> (inf.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        inf &gt;&gt; idx;</span><br><span class="line">        inf.<span class="built_in">close</span>();</span><br><span class="line">        <span class="function">std::ofstream <span class="title">ofs</span><span class="params">(txt_name)</span></span>;</span><br><span class="line">        ofs &lt;&lt; (idx + <span class="number">1</span>);</span><br><span class="line">        ofs.<span class="built_in">close</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 文件不存在时将里面的数字写成2，将当前索引赋值为1</span></span><br><span class="line">        idx = <span class="number">1</span>;</span><br><span class="line">        <span class="function">std::ofstream <span class="title">ofs</span><span class="params">(txt_name)</span></span>;</span><br><span class="line">        ofs &lt;&lt; <span class="string">&quot;2&quot;</span>;</span><br><span class="line">        ofs.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; idx &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-STL库的操作"><a href="#2-STL库的操作" class="headerlink" title="2 STL库的操作"></a>2 STL库的操作</h4><h5 id="2-1-将二维的普通C数组转成二维std-array"><a href="#2-1-将二维的普通C数组转成二维std-array" class="headerlink" title="2.1 将二维的普通C数组转成二维std::array"></a>2.1 将二维的普通C数组转成二维std::array</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建二维c数组和二维std::array</span></span><br><span class="line">    <span class="type">int</span> c_array[<span class="number">3</span>][<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    std::array&lt;std::array&lt;<span class="type">int</span>, 2&gt;, 3&gt; array1&#123;&#125;;</span><br><span class="line">    <span class="comment">// c数组转std::array</span></span><br><span class="line">    	<span class="comment">// 方法1:std::copy</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>; i&lt;array<span class="number">1.</span><span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        std::<span class="built_in">copy</span>(c_array[i], c_array[i]+array<span class="number">1.</span><span class="built_in">at</span>(i).<span class="built_in">size</span>(), array<span class="number">1.</span><span class="built_in">at</span>(i).<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    	<span class="comment">// 方法2:memcpy</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;array1, c_array, <span class="built_in">sizeof</span>(c_array));</span><br><span class="line">    <span class="comment">// 打印std::array</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item : array1)&#123;</span><br><span class="line">        cout &lt;&lt; item.<span class="built_in">at</span>(<span class="number">0</span>) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.<span class="built_in">at</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>

<h4 id="3-Eigen库函数"><a href="#3-Eigen库函数" class="headerlink" title="3 Eigen库函数"></a>3 Eigen库函数</h4><h6 id="3-1-多项式函数"><a href="#3-1-多项式函数" class="headerlink" title="3.1 多项式函数"></a>3.1 多项式函数</h6><p>以下是<code>poly_utils.h</code>的内容</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief: 一些多项式相关的函数</span></span><br><span class="line"><span class="comment"> *  @author: Hu Yunhao</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TEST0606_POLY_UTILS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEST0606_POLY_UTILS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Eigen/Dense&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unsupported/Eigen/Polynomials&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;math_utils.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> utils&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point3f</span>&#123;</span><br><span class="line">    <span class="type">float</span> x;</span><br><span class="line">    <span class="type">float</span> y;</span><br><span class="line">    <span class="type">float</span> theta;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point4f</span>&#123;</span><br><span class="line">    <span class="type">float</span> x;</span><br><span class="line">    <span class="type">float</span> y;</span><br><span class="line">    <span class="type">float</span> theta;</span><br><span class="line">    <span class="type">float</span> kappa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 计算多项式在x点处的值</span></span><br><span class="line"><span class="comment"> * @param[in] coeffs 多项式的系数</span></span><br><span class="line"><span class="comment"> * @param[in] x x坐标</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">polyValue</span><span class="params">(<span class="type">const</span> std::vector&lt;T&gt;&amp; coeffs, <span class="type">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">    T result = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; coeffs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        result += coeffs[i] * <span class="built_in">pow</span>(x, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 对离散点进行多项式拟合</span></span><br><span class="line"><span class="comment"> * @param[in] x 离散点的x坐标</span></span><br><span class="line"><span class="comment"> * @param[in] y 离散点的y坐标</span></span><br><span class="line"><span class="comment"> * @param[in] order 多项式拟合的阶数</span></span><br><span class="line"><span class="comment"> * @return 多项式的系数</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">std::vector&lt;T&gt; <span class="title">polyFit</span><span class="params">(std::vector&lt;T&gt;&amp; x, std::vector&lt;T&gt;&amp; y, <span class="type">int</span> order=<span class="number">3</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// std::vector转成Eigen</span></span><br><span class="line">    Eigen::Map&lt;Eigen::Matrix&lt;T, Eigen::Dynamic, <span class="number">1</span>&gt;&gt; <span class="built_in">x_values</span>(x.<span class="built_in">data</span>(), x.<span class="built_in">size</span>());</span><br><span class="line">    Eigen::Map&lt;Eigen::Matrix&lt;T, Eigen::Dynamic, <span class="number">1</span>&gt;&gt; <span class="built_in">y_values</span>(y.<span class="built_in">data</span>(), y.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 检查输入</span></span><br><span class="line">    <span class="built_in">assert</span>(x_values.<span class="built_in">size</span>() == y_values.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">assert</span>(order &gt;= <span class="number">1</span> &amp;&amp; order &lt;= x_values.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 构建Eigen矩阵，并且求解多项式系数</span></span><br><span class="line">    <span class="function">Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; <span class="title">A</span><span class="params">(x_values.size(), order + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; x_values.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">A</span>(i, <span class="number">0</span>) = <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; x_values.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; order; i++) &#123;</span><br><span class="line">            <span class="built_in">A</span>(j, i + <span class="number">1</span>) = <span class="built_in">A</span>(j, i) * <span class="built_in">x_values</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> Q = A.<span class="built_in">householderQr</span>();</span><br><span class="line">    Eigen::Matrix&lt;T, Eigen::Dynamic, <span class="number">1</span>&gt; result = Q.<span class="built_in">solve</span>(y_values);</span><br><span class="line">    <span class="comment">// Eigen转成std::vector</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">vector</span>&lt;T&gt;(result.<span class="built_in">data</span>(), result.<span class="built_in">data</span>() + result.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 求解多项式的实数根</span></span><br><span class="line"><span class="comment"> * @param[in] coefficients 多项式的系数向量，按[c0, c1, ... cn]排列</span></span><br><span class="line"><span class="comment"> * @param[out] roots 多项式的根</span></span><br><span class="line"><span class="comment"> * @return 如果多项式没有实数根，返回false</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">polySolve</span><span class="params">(<span class="type">const</span> std::vector&lt;T&gt;&amp; coefficients, std::vector&lt;T&gt;&amp; roots)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 对多项式最高次幂为0的情况进行处理</span></span><br><span class="line">    std::vector&lt;T&gt; temp = coefficients;</span><br><span class="line">    <span class="keyword">while</span> (temp.<span class="built_in">back</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">        temp.<span class="built_in">assign</span>(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(temp.<span class="built_in">size</span>() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    roots.<span class="built_in">clear</span>();</span><br><span class="line">    Eigen::PolynomialSolver&lt;T, Eigen::Dynamic&gt; solver;</span><br><span class="line">    Eigen::Map&lt;Eigen::Matrix&lt;T, Eigen::Dynamic, <span class="number">1</span>&gt;&gt; <span class="built_in">coeffs</span>(temp.<span class="built_in">data</span>(), temp.<span class="built_in">size</span>());</span><br><span class="line">    solver.<span class="built_in">compute</span>(coeffs);</span><br><span class="line">    solver.<span class="built_in">realRoots</span>(roots);</span><br><span class="line">    <span class="keyword">return</span> !roots.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取任意点在三次多项式表示的曲线上的投影点</span></span><br><span class="line"><span class="comment"> * @param[in] coefficients 三次多项式的系数[c0,c1,c2,c3]</span></span><br><span class="line"><span class="comment"> * @param[in] src_point 被投影点的坐标</span></span><br><span class="line"><span class="comment"> * @param[out] match_point 投影点的坐标</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getMatchPoint</span><span class="params">(<span class="type">const</span> std::vector&lt;T&gt;&amp; coefficients, <span class="type">const</span> Point3f&amp; src_point, Point3f&amp; match_point)</span></span>&#123;</span><br><span class="line">    T x0 = src_point.x;</span><br><span class="line">    T y0 = src_point.y;</span><br><span class="line">    T c0 = coefficients[<span class="number">0</span>], c1 = coefficients[<span class="number">1</span>], c2 = coefficients[<span class="number">2</span>], c3 = coefficients[<span class="number">3</span>];</span><br><span class="line">    <span class="comment">// 联立投影点垂线和车道线方程，得到联立多项式方程</span></span><br><span class="line">    <span class="comment">// 3*c3^2*x^5 + 5*c2*c3*x^4 + (2*c2^2 + 4*c1*c3)*x^3 + (3*c1*c2 + 3*c3*(c0 - y0))*x^2 +</span></span><br><span class="line">    <span class="comment">// (c1^2 + 2*c2*(c0 - y0) + 1)*x + c1*(c0 - y0) - x0</span></span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; roots;   <span class="comment">// 待求解的方程的根</span></span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; coeffs;  <span class="comment">// 方程的系数</span></span><br><span class="line">    coeffs.<span class="built_in">push_back</span>(c1*(c0 - y0) - x0);</span><br><span class="line">    coeffs.<span class="built_in">push_back</span>(<span class="built_in">powf</span>(c1,<span class="number">2</span>) + <span class="number">2</span>*c2*(c0 - y0) + <span class="number">1</span>);</span><br><span class="line">    coeffs.<span class="built_in">push_back</span>(<span class="number">3</span>*c1*c2 + <span class="number">3</span>*c3*(c0 - y0));</span><br><span class="line">    coeffs.<span class="built_in">push_back</span>(<span class="number">2</span>*<span class="built_in">powf</span>(c2,<span class="number">2</span>) + <span class="number">4</span>*c1*c3);</span><br><span class="line">    coeffs.<span class="built_in">push_back</span>(<span class="number">5</span>*c2*c3);</span><br><span class="line">    coeffs.<span class="built_in">push_back</span>(<span class="number">3</span>*<span class="built_in">powf</span>(c3,<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">polySolve</span>(coefficients, roots)) &#123;     <span class="comment">// 方程有实数根</span></span><br><span class="line">        <span class="keyword">auto</span> x = *(std::<span class="built_in">min_element</span>(roots.<span class="built_in">begin</span>(), roots.<span class="built_in">end</span>()));</span><br><span class="line">        <span class="keyword">auto</span> y = <span class="built_in">polyValue</span>(coefficients, x);</span><br><span class="line">        match_point.x = x;</span><br><span class="line">        match_point.y = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        match_point.x = src_point.x;</span><br><span class="line">        match_point.y = <span class="built_in">polyValue</span>(coefficients, match_point.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将1/4圆弧等分为离散点</span></span><br><span class="line"><span class="comment"> * @param[in] radius 圆弧的半径</span></span><br><span class="line"><span class="comment"> * @param[out] path 等分后的离散点的坐标</span></span><br><span class="line"><span class="comment"> * @param[in] is_turn_left 车辆左转为true，右转为false</span></span><br><span class="line"><span class="comment"> * @param[in] ds 相邻离散点之间的弧长</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">discreteCircle</span><span class="params">(<span class="type">float</span> radius, std::vector&lt;utils::Point4f&gt;&amp; path, <span class="type">bool</span> is_turn_left= <span class="literal">true</span>, <span class="type">float</span> ds=<span class="number">1</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;   <span class="comment">// namespace utils</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//TEST0606_POLY_UTILS_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以下是<code>poly_utils.cpp</code>中的内容</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;poly_utils.h&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> utils&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">discreteCircle</span><span class="params">(<span class="type">float</span> radius, std::vector&lt;utils::Point4f&gt;&amp; path, <span class="type">bool</span> is_turn_left, <span class="type">float</span> ds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    path.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="type">size_t</span> loop_num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> delta_angle = <span class="number">0</span>;      <span class="comment">// 相邻离散点之间的角度[rad]</span></span><br><span class="line">    <span class="comment">// 确保1/4个圆弧内有100个离散点</span></span><br><span class="line">    <span class="keyword">while</span> (loop_num &lt; <span class="number">100</span>)&#123;</span><br><span class="line">        delta_angle = ds / radius;</span><br><span class="line">        loop_num = <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(utils::pi/(<span class="number">2</span> * delta_angle));</span><br><span class="line">        ds = ds / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">float</span> x, y, theta, kappa = <span class="number">1</span>/radius;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; loop_num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x = radius * <span class="built_in">sin</span>(i * delta_angle);</span><br><span class="line">        y = radius - radius * <span class="built_in">cos</span>(i * delta_angle);</span><br><span class="line">        theta = i * delta_angle;</span><br><span class="line">        path.<span class="built_in">push_back</span>(&#123;x, y, theta, kappa&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;	<span class="comment">// namespace utils</span></span><br></pre></td></tr></table></figure>

<h4 id="4-spdlog封装的类"><a href="#4-spdlog封装的类" class="headerlink" title="4 spdlog封装的类"></a>4 spdlog封装的类</h4><p>将spdlog封装成一个类，便于使用</p>
<p><code>logger_utils.h</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> A02_LOGGER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A02_LOGGER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;third_party/spdlog/spdlog.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;third_party/spdlog/sinks/stdout_color_sinks.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;third_party/spdlog/sinks/rotating_file_sink.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">APALogger</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">APALogger</span>()&#123;</span><br><span class="line">        <span class="comment">// 创建sinks和logger</span></span><br><span class="line">        sinks.<span class="built_in">push_back</span>(std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::stdout_color_sink_mt&gt;());</span><br><span class="line">        sinks.<span class="built_in">push_back</span>(std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::rotating_file_sink_mt&gt;(<span class="string">&quot;Logs/ApaPlanningLog.txt&quot;</span>, <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">5</span>,<span class="number">5</span>));</span><br><span class="line">        logger = std::<span class="built_in">make_shared</span>&lt;spdlog::logger&gt;(<span class="string">&quot;ApaPlanning&quot;</span>, sinks.<span class="built_in">begin</span>(), sinks.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 设置sink的输出等级</span></span><br><span class="line">        sinks.<span class="built_in">at</span>(<span class="number">0</span>)-&gt;<span class="built_in">set_pattern</span>(<span class="string">&quot;[%Y-%m-%d %H:%M:%S.%e][%l] %v&quot;</span>);</span><br><span class="line">        sinks.<span class="built_in">at</span>(<span class="number">0</span>)-&gt;<span class="built_in">set_level</span>(spdlog::level::info);</span><br><span class="line">        sinks.<span class="built_in">at</span>(<span class="number">1</span>)-&gt;<span class="built_in">set_pattern</span>(<span class="string">&quot;[%Y-%m-%d %H:%M:%S.%e][%l] %v&quot;</span>);</span><br><span class="line">        sinks.<span class="built_in">at</span>(<span class="number">1</span>)-&gt;<span class="built_in">set_level</span>(spdlog::level::info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;spdlog::sink_ptr&gt; sinks;</span><br><span class="line">    std::shared_ptr&lt;spdlog::logger&gt; logger;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//A02_LOGGER_H</span></span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://longfei1995.github.io/2024/01/01/gac/use_funcs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡云浩">
      <meta itemprop="description" content="记录生活，记录工作，记录学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="胡云浩的blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/01/gac/use_funcs/" class="post-title-link" itemprop="url">GAC使用函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-01-01T00:00:00+08:00">2024-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-10 17:04:08" itemprop="dateModified" datetime="2025-04-10T17:04:08+08:00">2025-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GAC/" itemprop="url" rel="index"><span itemprop="name">GAC</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="用于调试的函数"><a href="#用于调试的函数" class="headerlink" title="用于调试的函数"></a>用于调试的函数</h5><h6 id="1-记录更改的real-grid-map"><a href="#1-记录更改的real-grid-map" class="headerlink" title="1. 记录更改的real_grid_map"></a>1. 记录更改的real_grid_map</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test code </span></span><br><span class="line">Noter noter;</span><br><span class="line">ParkData tmp_park_data = park_data;</span><br><span class="line"><span class="built_in">memcpy</span>(tmp_park_data.grid_map, park_data.real_grid_map, <span class="built_in">sizeof</span>(park_data.real_grid_map));</span><br><span class="line">tmp_park_data.low_obs_segs.<span class="built_in">clear</span>();</span><br><span class="line">tmp_park_data.low_obs_segs = park_data.real_low_obs_segs;</span><br><span class="line">tmp_park_data.high_obs_segs.<span class="built_in">clear</span>();</span><br><span class="line">tmp_park_data.high_obs_segs = park_data.real_high_obs_segs;</span><br><span class="line">noter.<span class="built_in">writeInputToYaml</span>(<span class="string">&quot;./data/test.yaml&quot;</span>, tmp_park_data);</span><br></pre></td></tr></table></figure>

<h6 id="2-保存park-data-plan-path为path-csv"><a href="#2-保存park-data-plan-path为path-csv" class="headerlink" title="2. 保存park_data.plan_path为path.csv"></a>2. 保存park_data.plan_path为path.csv</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">savePlanPathToCSV</span><span class="params">(<span class="type">const</span> std::vector&lt;std::vector&lt;PlanPoint&gt;&gt;&amp; plan_path, <span class="type">const</span> std::string&amp; file_name)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::ofstream <span class="title">file</span><span class="params">(file_name)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Could not open the file &quot;</span> &lt;&lt; file_name &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Write the CSV headers</span></span><br><span class="line">  file &lt;&lt; <span class="string">&quot;idx,x,y,yaw,curv,spd,dir\n&quot;</span>;</span><br><span class="line">  <span class="comment">// Save the data</span></span><br><span class="line">  <span class="type">int</span> idx = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; path : plan_path) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; point : path) &#123;</span><br><span class="line">      file &lt;&lt; idx++ &lt;&lt; <span class="string">&#x27;,&#x27;</span></span><br><span class="line">           &lt;&lt; point.x &lt;&lt; <span class="string">&#x27;,&#x27;</span></span><br><span class="line">           &lt;&lt; point.y &lt;&lt; <span class="string">&#x27;,&#x27;</span></span><br><span class="line">           &lt;&lt; point.yaw &lt;&lt; <span class="string">&#x27;,&#x27;</span></span><br><span class="line">           &lt;&lt; point.curv &lt;&lt; <span class="string">&#x27;,&#x27;</span></span><br><span class="line">           &lt;&lt; point.spd &lt;&lt; <span class="string">&#x27;,&#x27;</span></span><br><span class="line">           &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(point.dir) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  file.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>绘图的python脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取CSV文件内容</span></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;path.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一张图：idx vs x</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">plt.scatter(data[<span class="string">&#x27;idx&#x27;</span>], data[<span class="string">&#x27;x&#x27;</span>], s=<span class="number">1</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;idx vs x&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;idx&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二张图：idx vs y</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">plt.scatter(data[<span class="string">&#x27;idx&#x27;</span>], data[<span class="string">&#x27;y&#x27;</span>], s=<span class="number">1</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;idx vs y&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;idx&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三张图：idx vs yaw</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">plt.scatter(data[<span class="string">&#x27;idx&#x27;</span>], data[<span class="string">&#x27;yaw&#x27;</span>], s=<span class="number">1</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;idx vs yaw&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;idx&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;yaw&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第四张图：idx vs curv</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">plt.scatter(data[<span class="string">&#x27;idx&#x27;</span>], data[<span class="string">&#x27;curv&#x27;</span>], s=<span class="number">1</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;idx vs curv&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;idx&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;curv&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第五张图：idx vs spd</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">plt.scatter(data[<span class="string">&#x27;idx&#x27;</span>], data[<span class="string">&#x27;spd&#x27;</span>], s=<span class="number">1</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;idx vs spd&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;idx&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;spd&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第六张图：idx vs dir</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">plt.scatter(data[<span class="string">&#x27;idx&#x27;</span>], data[<span class="string">&#x27;dir&#x27;</span>], s=<span class="number">1</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;idx vs dir&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;idx&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;dir&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第七张图：x vs y</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">plt.scatter(data[<span class="string">&#x27;x&#x27;</span>], data[<span class="string">&#x27;y&#x27;</span>], s=<span class="number">1</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;x vs y&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://longfei1995.github.io/2024/01/01/cpp/cppThirdPartyLibs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡云浩">
      <meta itemprop="description" content="记录生活，记录工作，记录学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="胡云浩的blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/01/cpp/cppThirdPartyLibs/" class="post-title-link" itemprop="url">C++第三方库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-01-01T00:00:00+08:00">2024-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-10 17:02:53" itemprop="dateModified" datetime="2025-04-10T17:02:53+08:00">2025-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Eigen库"><a href="#Eigen库" class="headerlink" title="Eigen库"></a>Eigen库</h1><h4 id="1-Eigen的安装"><a href="#1-Eigen的安装" class="headerlink" title="1. Eigen的安装"></a>1. Eigen的安装</h4><p>对于ubuntu，只需要输入如下命令即可</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install libeigen3-dev</span><br><span class="line"><span class="comment"># 创建软连接，这样在cpp文件中就可以直接#include&lt;Eigen/Dense&gt;而不需要#include&lt;eigen3/Eigen/Dense&gt;</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /usr/include/eigen3/Eigen /usr/include/Eigen</span><br></pre></td></tr></table></figure>

<p>对于msys2来说，输入如下命令即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 使用命令pacman -Ss &lt;库名&gt; 来搜索包名</span><br><span class="line">pacman -Ss eigen3</span><br><span class="line"># 出现如下结果</span><br><span class="line">mingw32/mingw-w64-i686-eigen3 3.4.0-1</span><br><span class="line">    Lightweight C++ template library for vector and matrix math (mingw-w64)</span><br><span class="line">mingw64/mingw-w64-x86_64-eigen3 3.4.0-1</span><br><span class="line">    Lightweight C++ template library for vector and matrix math (mingw-w64)</span><br><span class="line">ucrt64/mingw-w64-ucrt-x86_64-eigen3 3.4.0-1</span><br><span class="line">    Lightweight C++ template library for vector and matrix math (mingw-w64)</span><br><span class="line">clang64/mingw-w64-clang-x86_64-eigen3 3.4.0-1</span><br><span class="line">    Lightweight C++ template library for vector and matrix math (mingw-w64)</span><br><span class="line"># 然后安装mingw64的eigen3即可</span><br><span class="line">pacman -S mingw-w64-x86_64-eigen3</span><br></pre></td></tr></table></figure>

<p>如果想直接#include&lt;Eigen&#x2F;Dense&gt;而不是#include&lt;eigen3&#x2F;Eigen&#x2F;Dense&gt;的话，在cmakelist中加入如下语句即可</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 寻找Eigen库</span></span><br><span class="line"><span class="keyword">find_package</span>(Eigen3 REQUIRED)</span><br><span class="line"><span class="comment"># 将Eigen库include进来</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PRIVATE <span class="variable">$&#123;EIGEN3_INCLUDE_DIR&#125;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-矩阵和向量的基本操作"><a href="#2-矩阵和向量的基本操作" class="headerlink" title="2. 矩阵和向量的基本操作"></a>2. 矩阵和向量的基本操作</h4><h5 id="2-1-创建方法"><a href="#2-1-创建方法" class="headerlink" title="2.1 创建方法"></a>2.1 创建方法</h5><p>方法1：通过Matrix&lt;&gt;类模板创建</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//--------------------创建固定矩阵（fixed matrix)-------------------------------</span></span><br><span class="line">Matrix&lt;<span class="keyword">typename</span> Scalar, <span class="type">int</span> RowsAtCompileTime, <span class="type">int</span> ColsAtCompileTime&gt;</span><br><span class="line"><span class="comment">// 第一个参数指定矩阵的数据类型：double、float、int…，第二和第三个参数分别表示矩阵的行数与列数。</span></span><br><span class="line"><span class="comment">// 因此一个简单的矩阵可以声明为：</span></span><br><span class="line">Matrix&lt;<span class="type">double</span>, <span class="number">5</span>, <span class="number">3</span>&gt; mat1;</span><br><span class="line"><span class="comment">//---------------------创建动态矩阵---------------------------------//</span></span><br><span class="line">Matrix&lt;<span class="type">double</span>, Dynamic,Dynamic&gt; mat2;  <span class="comment">//Dynamic是动态创建关键字</span></span><br><span class="line">mat<span class="number">2.</span><span class="built_in">resize</span>(a, b);</span><br><span class="line"><span class="comment">//但需要注意的是resize()这个函数是”毁灭性”(destructive)的，改变大小以后矩阵元素</span></span><br><span class="line"><span class="comment">//会改变。所以它一般只用来对动态矩阵做初始化。而我们认为的改变大小的功能</span></span><br><span class="line"><span class="comment">//对应conservativeResize()函数。顺带一提，如果矩阵变大了，多余的元素为0。</span></span><br><span class="line">mat<span class="number">2.</span><span class="built_in">conservativeResize</span>(a, b);</span><br><span class="line"><span class="comment">//ps:而对于向量，其创建方式与矩阵完全一样(包括预定义的常用大小向量)，不同的就是</span></span><br><span class="line"><span class="comment">//把Matrix换成Vector，这样新建的默认都是列向量，如果需要新建行向量，关键词</span></span><br><span class="line"><span class="comment">//换成RowVector即可。</span></span><br></pre></td></tr></table></figure>

<p>方法2：使用预定义类创建</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1，X代表大小不确定，d表示数据类型是double</span></span><br><span class="line"><span class="function">MatrixXd <span class="title">mat</span><span class="params">(<span class="number">5</span>, <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">//方法2，使用预定义类型</span></span></span><br><span class="line"><span class="function">Matrix3d mat2</span>;</span><br><span class="line">Matrix2i mat3;</span><br><span class="line">Vector2i vec1;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-初始化方法"><a href="#2-2-初始化方法" class="headerlink" title="2.2 初始化方法"></a>2.2 初始化方法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Eigen中可以方便的使用逗号初始化语法(comma-initializer syntax)，如下。</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Matrix3d m;</span><br><span class="line">    m &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">            <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">            <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>;</span><br><span class="line">    cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要注意：</span></span><br><span class="line"><span class="comment">//1.按顺序读取初始值，依次填充矩阵，直到把第一行填满了再填下一行</span></span><br><span class="line"><span class="comment">//2.初始值的个数必须严格对应矩阵大小，如上面3x3的矩阵共有9个元素就必须要</span></span><br><span class="line"><span class="comment">//有9个初始值，一个萝卜一个坑，多了少了都会报赋值失败的错误。</span></span><br></pre></td></tr></table></figure>

<h5 id="2-3-获取元素-大小"><a href="#2-3-获取元素-大小" class="headerlink" title="2.3 获取元素 &amp;&amp; 大小"></a>2.3 获取元素 &amp;&amp; 大小</h5><p><strong>元素获取</strong>：在Eigen中用()获取矩阵或向量中的元素，如m(4,7)就表示获取4行7列的元素。</p>
<p><strong>元素的修改</strong>：获取到元素后直接赋值即可。</p>
<p>此外，矩阵分别有.rows()、.cols()、.size()函数来分别获取矩阵的行数、列数以及元素个数。</p>
<p>.data()函数用于返回一个指向矩阵或向量的首地址的指针。</p>
<h5 id="2-4-创建特定的矩阵"><a href="#2-4-创建特定的矩阵" class="headerlink" title="2.4 创建特定的矩阵"></a>2.4 创建特定的矩阵</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以上是一些常规“操作”，下面介绍一些方便使用的函数。在创建矩阵时，</span></span><br><span class="line"><span class="comment">//还有一些非常方便的函数，这里简单介绍一下。</span></span><br><span class="line">MatrixXd::<span class="built_in">Random</span>(m,n);					<span class="comment">// 创建m×n维double类型的随机数矩阵</span></span><br><span class="line">MatrixXd::<span class="built_in">Constant</span>(m,n,p);				<span class="comment">// 创建m×n维double类型元素全为p的矩阵</span></span><br><span class="line">MatrixXd::<span class="built_in">Zero</span>(m,n);					<span class="comment">// 创建m×n维元素全为0的矩阵</span></span><br><span class="line">MatrixXd::<span class="built_in">Ones</span>(m,n);					<span class="comment">// 创建m×n维元素全为1的矩阵</span></span><br><span class="line">MatrixXd::<span class="built_in">Identity</span>(m,n);				<span class="comment">// 创建m×n维的单位阵</span></span><br><span class="line">VectorXd::<span class="built_in">LinSpaced</span>(size,low,high);		<span class="comment">// 创建一个size长度的从low到high的向量或一维矩阵</span></span><br></pre></td></tr></table></figure>

<h5 id="2-5-矩阵的切片操作"><a href="#2-5-矩阵的切片操作" class="headerlink" title="2.5 矩阵的切片操作"></a>2.5 矩阵的切片操作</h5><p>说到矩阵的块操作，熟悉Python的同学应该都非常熟悉Numpy中非常好用的切片功能，这就是用来进行块操作的。Eigen作为矩阵运算库同样也具备块操作的能力。 在Eigen中有两种方式进行块操作：<br>一种是动态尺寸块(dynamic-size block)：mat.block(i,j,p,q)<br>另一种是固定尺寸块(fixed-size block)：mat.block&lt;p,q&gt;(i,j)<br>它们在语义上等价，都表示从矩阵的i行j列开始取大小为p行q列的块，注意p行q列是从第i行j列开始算的。唯一的区别就是如果你的矩阵比较小(固定大小矩阵)，固定尺寸块会有更高的效率。在获得了矩阵块之后即可对其进行修改等一系列操作。<br>特别的：<br>mat.row(n)：用于单独取出第n行<br>mat.col(n)：用于单独取出第n列<br>示例代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Eigen::MatrixXd mat1 = Eigen::MatrixXd::<span class="built_in">Random</span>(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">    cout&lt;&lt;mat1&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;-------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;mat<span class="number">1.</span><span class="built_in">block</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;-------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;mat<span class="number">1.</span><span class="built_in">block</span>&lt;<span class="number">2</span>,<span class="number">2</span>&gt;(<span class="number">0</span>,<span class="number">0</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------result-------------------------</span></span><br><span class="line"> <span class="number">-0.997497</span>   <span class="number">0.617481</span>  <span class="number">-0.299417</span></span><br><span class="line">  <span class="number">0.127171</span>   <span class="number">0.170019</span>   <span class="number">0.791925</span></span><br><span class="line"> <span class="number">-0.613392</span> <span class="number">-0.0402539</span>    <span class="number">0.64568</span></span><br><span class="line">-------------------</span><br><span class="line">  <span class="number">0.170019</span>   <span class="number">0.791925</span></span><br><span class="line"><span class="number">-0.0402539</span>    <span class="number">0.64568</span></span><br><span class="line">-------------------</span><br><span class="line"><span class="number">-0.997497</span>  <span class="number">0.617481</span></span><br><span class="line"> <span class="number">0.127171</span>  <span class="number">0.170019</span></span><br></pre></td></tr></table></figure>

<h4 id="3-矩阵和向量的运算"><a href="#3-矩阵和向量的运算" class="headerlink" title="3. 矩阵和向量的运算"></a>3. 矩阵和向量的运算</h4><h5 id="3-1-四则运算"><a href="#3-1-四则运算" class="headerlink" title="3.1 四则运算"></a>3.1 四则运算</h5><p>Eigen重载了基本的+、-、×运算符，因此可以比较方便地进行运算。需要注意的一点是Eigen对数据类型敏感，并且不会自动类型转换，如自动将float转成double等。因此一个Matrix3d和一个Matrix3f相乘是会报错的。</p>
<ul>
<li>加法+：只能用于相同大小矩阵</li>
<li>减法-：只能用于相同大小矩阵</li>
<li>乘法*：矩阵与标量、矩阵与矩阵</li>
<li>除法&#x2F;：只能用于矩阵与标量</li>
</ul>
<p>代码示例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Eigen::MatrixXd <span class="title">mat1</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    mat1 &lt;&lt; <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>;</span><br><span class="line">    <span class="function">Eigen::MatrixXd <span class="title">mat2</span><span class="params">(mat<span class="number">1.</span>rows(), mat<span class="number">1.</span>cols())</span></span>;     <span class="comment">// 构造同型矩阵</span></span><br><span class="line">    mat2 &lt;&lt; <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; mat1 + mat2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; mat1 - mat2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; mat1 * mat2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; mat1 / <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-向量的数量积，点积，叉乘"><a href="#3-2-向量的数量积，点积，叉乘" class="headerlink" title="3.2 向量的数量积，点积，叉乘"></a>3.2 向量的数量积，点积，叉乘</h5><p><strong>标量积</strong>：向量*标量，结果还是一个向量，对应向量的缩放。</p>
<p><strong>点积</strong>： 结果是个标量。从几何角度看，点积则是两个向量的长度与它们夹角余弦的积，几何意义：一个向量向另一个向量的投影。</p>
<p><strong>叉积</strong>：结果是个向量。axb &#x3D; ||a||*||b||<em>sinθ</em>n，几何意义：如果以向量a,b为边构成一个平行四边形，那么这两个向量叉积的模长与这个平行四边形的正面积相等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector3i <span class="title">v1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">Vector3i <span class="title">v2</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="comment">//点积</span></span><br><span class="line">v<span class="number">1.</span><span class="built_in">dot</span>(v2);</span><br><span class="line"><span class="comment">//叉积</span></span><br><span class="line">v<span class="number">1.</span><span class="built_in">cross</span>(v2);</span><br></pre></td></tr></table></figure>

<h5 id="3-3-矩阵本身运算"><a href="#3-3-矩阵本身运算" class="headerlink" title="3.3 矩阵本身运算"></a><strong>3.3 矩阵本身运算</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mat.<span class="built_in">transpose</span>();		<span class="comment">// 转置矩阵。对于矩阵转置，注意不要写成a = a.transpose()，这会导致错误结果(Aliasing Issue)，如果一定需要对原矩阵进行修改，使用a.transposeInPlace()函数，或者a = a.transpose.eval()。</span></span><br><span class="line">mat.<span class="built_in">inverse</span>();			<span class="comment">// 逆矩阵</span></span><br><span class="line">mat.<span class="built_in">conjugate</span>();		<span class="comment">// 共轭矩阵</span></span><br><span class="line">mat.<span class="built_in">adjoint</span>();			<span class="comment">// 伴随矩阵</span></span><br><span class="line">mat.<span class="built_in">trace</span>();			<span class="comment">// 矩阵的迹</span></span><br><span class="line">mat.<span class="built_in">eigenvalues</span>();		<span class="comment">// 矩阵的特征值</span></span><br><span class="line">mat.<span class="built_in">determinant</span>();		<span class="comment">// 矩阵求行列式的值</span></span><br><span class="line">mat.<span class="built_in">diagonal</span>();			<span class="comment">// 矩阵对角线元素</span></span><br><span class="line">mat.<span class="built_in">sum</span>();				<span class="comment">// 矩阵所有元素求和</span></span><br><span class="line">mat.<span class="built_in">prod</span>();				<span class="comment">// 矩阵所有元素求积</span></span><br><span class="line">mat.<span class="built_in">mean</span>();				<span class="comment">// 矩阵所有元素求平均</span></span><br><span class="line">mat.<span class="built_in">cwiseAbs</span>();			<span class="comment">// 矩阵所有元素求绝对值</span></span><br><span class="line">mat.<span class="built_in">minCoeff</span>();			<span class="comment">// 矩阵所有元素最小值</span></span><br><span class="line">mat.<span class="built_in">minCoeff</span>(&amp;i,&amp;j);    <span class="comment">// 矩阵所有元素最小值的位置，i、j为int类型或为Eigen的Index类型。</span></span><br><span class="line">mat.<span class="built_in">maxCoeff</span>();			<span class="comment">// 矩阵所有元素最大值</span></span><br><span class="line">mat.<span class="built_in">maxCoeff</span>(&amp;i,&amp;j);    <span class="comment">// 矩阵所有元素最大值的位置</span></span><br><span class="line">mat.<span class="built_in">nonZeros</span>();			<span class="comment">// 矩阵中非零元素个数</span></span><br><span class="line">mat.<span class="built_in">squaredNorm</span>();		<span class="comment">// 矩阵(向量)的平方范数，对向量而言等价于其与自身做点积，数值上等于各分量的平方和。</span></span><br><span class="line">mat.<span class="built_in">norm</span>();				<span class="comment">// 矩阵(向量)的平方范数开根号(对于向量即求模长)</span></span><br><span class="line">mat.<span class="built_in">lpNorm</span>&lt;<span class="number">1</span>&gt;();		<span class="comment">// 矩阵(向量)的L1范数</span></span><br><span class="line">mat.<span class="built_in">lpNorm</span>&lt;<span class="number">2</span>&gt;();		<span class="comment">// 矩阵(向量)的L2范数</span></span><br><span class="line">mat.<span class="built_in">lpNorm</span>&lt;Infinity&gt;();	<span class="comment">// 矩阵(向量)的L无穷范数</span></span><br><span class="line">mat.<span class="built_in">lpNorm</span>&lt;p&gt;();		<span class="comment">// 矩阵(向量)的Lp范数</span></span><br><span class="line">mat.<span class="built_in">normalize</span>();		<span class="comment">// 矩阵(向量)的正则化(归一化)，使所有元素的平方和等于1。</span></span><br><span class="line">(mat&gt;<span class="number">0</span>).<span class="built_in">all</span>();			<span class="comment">// 矩阵元素条件判断，mat中所有元素是否都大于0，是返回1，否则返回0。</span></span><br><span class="line">(mat&gt;<span class="number">0</span>).<span class="built_in">any</span>();			<span class="comment">// 矩阵元素条件判断，mat中所有元素是否有大于0的，有返回1，否则返回0。</span></span><br><span class="line">(mat&gt;<span class="number">0</span>).<span class="built_in">count</span>();		<span class="comment">// 矩阵符合条件的元素计数，返回mat中大于0元素的个数。</span></span><br><span class="line">mat.<span class="built_in">colwise</span>();			<span class="comment">// 返回矩阵每列的值</span></span><br><span class="line">mat.<span class="built_in">rowwise</span>();			<span class="comment">// 返回矩阵每行的值</span></span><br></pre></td></tr></table></figure>

<h4 id="4-Array"><a href="#4-Array" class="headerlink" title="4. Array"></a>4. Array</h4><p>相比于Matrix面向线性代数而设计，Array是Eigen中一个特别的类型，其设计的初衷是面向“元素级”运算(coefficient-wise operation)，具有更一般的用途。例如两个相同大小矩阵间元素级的乘法(相同位置元素相乘并放在对应位置)。其创建、初始化等操作均与Matrix相同，不同的是关键词换成Array，Eigen也提供了预定义好的类型。但与Matrix稍有不同的是，形如ArrayXd表示的并不是X×X的矩阵，而是长度为X的1维数组；对于2维Array表示为ArrayXXd。</p>
<h5 id="4-1-Array的四则运算"><a href="#4-1-Array的四则运算" class="headerlink" title="4.1 Array的四则运算"></a>4.1 Array的四则运算</h5><p>同样的，Array也重载了四则运算符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Eigen::ArrayXd <span class="title">arr1</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">Eigen::ArrayXd <span class="title">arr2</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    arr1 &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>;</span><br><span class="line">    arr2 &lt;&lt; <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 数组与元素</span></span><br><span class="line">    cout &lt;&lt; (arr1) + <span class="number">2</span> &lt;&lt; endl;   <span class="comment">// result = [3, 4, 5]</span></span><br><span class="line">    cout &lt;&lt; (arr1) - <span class="number">2</span> &lt;&lt; endl;   <span class="comment">// result = [-1, 0, 1]</span></span><br><span class="line">    cout &lt;&lt; (arr1) * <span class="number">2</span> &lt;&lt; endl;   <span class="comment">// result = [2, 4, 6]</span></span><br><span class="line">    cout &lt;&lt; (arr1) / <span class="number">2</span> &lt;&lt; endl;   <span class="comment">// result = [0.5, 1, 1.5]</span></span><br><span class="line">    <span class="comment">// 数组与数组</span></span><br><span class="line">    cout &lt;&lt; arr1 + arr2 &lt;&lt; endl;  <span class="comment">// result = [3, 6, 9]</span></span><br><span class="line">    cout &lt;&lt; arr1 - arr2 &lt;&lt; endl;  <span class="comment">// result = [-1, -2, -3]</span></span><br><span class="line">    cout &lt;&lt; arr1 * arr2 &lt;&lt; endl;  <span class="comment">// result = [2, 8, 18]</span></span><br><span class="line">    cout &lt;&lt; arr1 / arr2 &lt;&lt; endl;  <span class="comment">// result = [0.5, 0.5, 0.5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-其他操作"><a href="#4-2-其他操作" class="headerlink" title="4.2 其他操作"></a>4.2 其他操作</h5><ul>
<li><p>arr.abs()：逐元素取绝对值 </p>
</li>
<li><p>arr.sqrt()：逐元素开根号 </p>
</li>
<li><p>arr.pow(n)：逐元素n次方 </p>
</li>
<li><p>arr1.min(arr2)：将两个Array中相应位置的最小值组成一个新Array </p>
</li>
<li><p>arr1.max(arr2)：将两个Array中相应位置的最大值组成一个新Array</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Eigen::ArrayXd <span class="title">arr1</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">Eigen::ArrayXd <span class="title">arr2</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    arr1 &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>;</span><br><span class="line">    arr2 &lt;&lt; <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>;</span><br><span class="line">    cout &lt;&lt; arr<span class="number">1.</span><span class="built_in">pow</span>(<span class="number">2</span>) &lt;&lt; endl;  		<span class="comment">// result = [1, 4, 9]</span></span><br><span class="line">    cout &lt;&lt; arr<span class="number">1.</span><span class="built_in">min</span>(arr2) &lt;&lt; endl;     <span class="comment">// result = [1, 1, 3]</span></span><br><span class="line">    cout &lt;&lt; arr<span class="number">1.</span><span class="built_in">max</span>(arr2) &lt;&lt; endl;     <span class="comment">// result = [2, 2, 4]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-3-Array和Matrix之间的转换"><a href="#4-3-Array和Matrix之间的转换" class="headerlink" title="4.3 Array和Matrix之间的转换"></a>4.3 Array和Matrix之间的转换</h5><p>可以看到Array在元素级运算上有着强大的优势，其本身也可以与Matrix相互转换，也十分简单。</p>
<ul>
<li>将Matrix转换为Array函数为mat.array()</li>
<li>将Array转换为Matrix函数为arr.matrix()</li>
</ul>
<p>这样的转换不用担心会有运行时性能的损耗。但需要注意的是Eigen是不允许Matrix和Array混合运算的。</p>
<p>事实上，由于元素级运算在矩阵中很常见，所以Eigen对于Matrix其实内置了一些函数，均以cwise开头，如mat.cwiseProduct()对应元素相乘、mat.cwiseAbs()元素取绝对值、mat.cwiseSqrt()逐元素开根号、mat.cwiseMin()将两个矩阵中相应位置的最小值组成一个新矩阵等等，更多函数可以查看官方文档。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 想要将想要将向量中的每个元素都减去5,但直接vec1-5是错误的，因为向量减法只支持同形向量</span></span><br><span class="line">    <span class="function">Eigen::VectorXd <span class="title">vec</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    vec &lt;&lt; <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>;</span><br><span class="line">    vec = (vec.<span class="built_in">array</span>() - <span class="number">5</span>).<span class="built_in">matrix</span>();     <span class="comment">// 先转换成array做元素的减法，然后转回vector</span></span><br><span class="line">    cout &lt;&lt; vec &lt;&lt; endl;                  <span class="comment">// result = [1, 2, 3, 4, 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-STL容器与Eigen的转换"><a href="#5-STL容器与Eigen的转换" class="headerlink" title="5. STL容器与Eigen的转换"></a>5. STL容器与Eigen的转换</h4><p>Map类主要是用来处理C++中原生的数组的，这样就可以将其转化为Eigen中的矩阵或向量进行操作了。它也可以用于修改矩阵大小、切片等操作中。新建Map对象的模板参数如下：</p>
<blockquote>
<p>Map<MatrixXd> mat1(STL数组的地址，行数，列数)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将STL数组转换成Eigen中的Matrix或Vecotor</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Eigen::Map&lt;Eigen::MatrixXd&gt; <span class="title">mat1</span><span class="params">(v<span class="number">1.</span>data(), <span class="number">2</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">Eigen::Map&lt;Eigen::VectorXd&gt; <span class="title">mat2</span><span class="params">(v<span class="number">1.</span>data(), <span class="number">4</span>)</span></span>;</span><br><span class="line">	Eigen::Map&lt;Eigen::Matrix&lt;<span class="type">float</span>, Eigen::Dynamic, <span class="number">1</span>&gt;&gt; <span class="built_in">vec1</span>(v<span class="number">1.</span><span class="built_in">data</span>(), v<span class="number">1.</span><span class="built_in">size</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mat1:&quot;</span> &lt;&lt; endl &lt;&lt; mat1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mat2:&quot;</span> &lt;&lt; endl &lt;&lt; mat2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将Eigen中的Matrix或Vector转成STL数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Eigen::MatrixXd <span class="title">mat1</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    mat1 &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">double</span>&gt; <span class="title">v1</span><span class="params">(mat<span class="number">1.</span>data(), mat<span class="number">1.</span>data()+mat<span class="number">1.</span>size())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        cout &lt;&lt; v1[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h1><h4 id="1-clion-Qt-IDE配置"><a href="#1-clion-Qt-IDE配置" class="headerlink" title="1. clion + Qt IDE配置"></a>1. clion + Qt IDE配置</h4><p><strong>Term1: 指定Qt的安装位置，以便使用find_package找到qt相关的库</strong></p>
<p>方法1：在CMakeList.txt中添加如下语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_PREFIX_PATH &quot;D:\\Qt\\Qt5.12.12\\5.12.12\\mingw73_64\\&quot;)</span><br></pre></td></tr></table></figure>

<p>方法2：在clion的设置-&gt;构建、执行、部署-&gt;CMake-&gt;CMake选项，添加如下语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-DCMAKE_PREFIX_PATH=D:\Qt\Qt5.12.12\5.12.12\mingw73_64\ </span><br></pre></td></tr></table></figure>

<p><strong>Term2: 指定外部配置工具(Clion-&gt;tools-&gt;External tools)</strong></p>
<p><strong>Qt Designer</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Name : Qt Designer</span><br><span class="line">Program : D:\Qt\Qt5.12.12\5.12.12\mingw73_64\bin\designer.exe</span><br><span class="line">Arguments : $FilePath$</span><br><span class="line">Working directory : $ProjectFileDir$</span><br></pre></td></tr></table></figure>

<p><strong>UIC</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Name : uic</span><br><span class="line">Program : D:\Qt\Qt5.12.12\5.12.12\mingw73_64\bin\uic.exe</span><br><span class="line">Arguments : $FileName$ -o ui_$FileNameWithoutExtension$.h</span><br><span class="line">Working directory : $FileDir$</span><br></pre></td></tr></table></figure>

<p><strong>QRC</strong></p>
<p>.qrc文件的创建可以在File-&gt;settings-&gt;Editor-&gt;File and Code Templates点击+，创建一个Qt Resource模板，后缀为qrc</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RCC</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">qresource</span> <span class="attr">prefix</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>xxx.png<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">qresource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RCC</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>类似这样，然后把xxx.png放在.qrc的同一目录即可</p>
<p>然后在代码中即可使用.qrc资源<code>setWindowIcon(QIcon(&quot;:/star.png&quot;));</code></p>
<p><strong>Term3: 指定程序运行时的环境变量</strong></p>
<p><code>PATH=D:\Qt\Qt5.12.12\5.12.12\mingw73_64\bin</code></p>
<img src="images/image-20230407153020794.png" alt="image-20230407153020794" style="zoom: 67%;" />

<h4 id="2-安装常见问题"><a href="#2-安装常见问题" class="headerlink" title="2. 安装常见问题"></a>2. 安装常见问题</h4><p><strong>Term1: 命令行找不到qmake</strong></p>
<blockquote>
<p>问题描述：在命令行输入qmake –version，报错如下：could not exec ‘&#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;qt4&#x2F;bin&#x2F;qmake’: No such file or directory</p>
<p>原因分析：因为qtchooser默认选择路径中，没有指向你安装的qmake路径所在的路径</p>
</blockquote>
<p>解决办法：</p>
<p>1.确认qmake的安装路径，比如<code>/home/hyh/Qt5.9.9/5.9.9/gcc_64/bin</code></p>
<p>2.打开qtchooser配置文件，将次安装路径放到第一行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> gedit /usr/lib/x86_64-linux-gnu/qt-default/qtchooser/default.conf </span><br></pre></td></tr></table></figure>

<h4 id="3-Qt的一些语法"><a href="#3-Qt的一些语法" class="headerlink" title="3. Qt的一些语法"></a>3. Qt的一些语法</h4><h5 id="2-1-信号与槽"><a href="#2-1-信号与槽" class="headerlink" title="2.1 信号与槽"></a>2.1 信号与槽</h5><h6 id="2-1-1-针对重载函数的connect"><a href="#2-1-1-针对重载函数的connect" class="headerlink" title="2.1.1 针对重载函数的connect"></a>2.1.1 针对重载函数的connect</h6><p>我们来定义一个简单的包含重载信号和重载槽函数的类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Me</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hungry</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hungry</span><span class="params">(std::string somthing)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(std::string somthing)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以使用QOverload来连接信号与槽</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QObject::<span class="built_in">connect</span>(<span class="keyword">this</span>, QOverload&lt;std::string&gt;::<span class="built_in">of</span>(&amp;Me::hungry), <span class="keyword">this</span>, QOverload&lt;std::string&gt;::<span class="built_in">of</span>(&amp;Me::eat))</span><br></pre></td></tr></table></figure>

<p>QOverload 的作用是返回重载函数的指针，模板参数为函数类型列表</p>
<h4 id="4-Qt程序的打包"><a href="#4-Qt程序的打包" class="headerlink" title="4. Qt程序的打包"></a>4. Qt程序的打包</h4><h5 id="4-1-windows下的打包"><a href="#4-1-windows下的打包" class="headerlink" title="4.1 windows下的打包"></a>4.1 windows下的打包</h5><ul>
<li><p>首先将需要打包的程序生成<code>release</code>版本</p>
</li>
<li><p>在可执行程序目录，按下<code>shift </code>+<code>鼠标右键</code>， 找到<code>在此处打开powershell</code></p>
</li>
<li><p>添加一下系统的环境变量</p>
</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$Env:PATH</span>=<span class="string">&quot;C:\msys64\mingw64\bin;D:\Qt\Qt5.12.12\5.12.12\mingw73_64\bin;<span class="variable">$Env:PATH</span>&quot;</span> </span><br></pre></td></tr></table></figure>

<ul>
<li>然后执行qt自带的程序</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="string">&quot;D:\Qt\Qt5.12.12\5.12.12\mingw73_64\bin\windeployqt.exe&quot;</span> QPlan.exe <span class="literal">--release</span></span><br></pre></td></tr></table></figure>

<p>如果程序编译时的<code>CMAKE_BUILD_TYPE</code>为<code>Debug</code>的话，那么执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;&quot;D:\Qt\Qt5.12.12\5.12.12\mingw73_64\bin\windeployqt.exe&quot; QPlan.exe --debug</span><br></pre></td></tr></table></figure>

<h1 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h1><h4 id="1-protobuf的安装"><a href="#1-protobuf的安装" class="headerlink" title="1. protobuf的安装"></a>1. protobuf的安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载 protoBuf：</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/protocolbuffers/protobuf.git</span><br><span class="line"><span class="comment"># 安装依赖库</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install autoconf  automake  libtool curl make  g++  unzip libffi-dev -y</span><br><span class="line"><span class="comment"># 进入目录</span></span><br><span class="line"><span class="built_in">cd</span> protobuf/ &amp;&amp; <span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build/</span><br><span class="line"><span class="comment"># 生成makefile</span></span><br><span class="line">cmake -Dprotobuf_BUILD_TESTS=OFF ..</span><br><span class="line"><span class="comment"># 编译源码，注意cmake --build和make有同样的功效，而且跨平台效果更好</span></span><br><span class="line">cmake --build . --parallel 10</span><br><span class="line"><span class="comment"># 安装，同样的，和make install有同样的功效</span></span><br><span class="line"><span class="built_in">sudo</span> cmake --install .</span><br><span class="line"><span class="comment"># 刷新共享库 （很重要的一步啊）</span></span><br><span class="line"><span class="built_in">sudo</span> ldconfig </span><br><span class="line"><span class="comment"># 安装成功，即可显示版本</span></span><br><span class="line">$ protoc --version</span><br></pre></td></tr></table></figure>

<h4 id="2-protobuf的使用"><a href="#2-protobuf的使用" class="headerlink" title="2. protobuf的使用"></a>2. protobuf的使用</h4><p>将.proto生成.h和.cpp <code>protoc xxx.proto --cpp_out=./</code></p>
<h1 id="Ipopt-CppAD"><a href="#Ipopt-CppAD" class="headerlink" title="Ipopt&#x2F;CppAD"></a>Ipopt&#x2F;CppAD</h1><h4 id="1-ipopt安装"><a href="#1-ipopt安装" class="headerlink" title="1. ipopt安装"></a>1. ipopt安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.安装其他依赖库</span></span><br><span class="line"><span class="built_in">sudo</span> apt install gfortran unzip</span><br><span class="line"><span class="comment"># 2.在/tmp/目录下（使用/tmp目录只是示例，随便哪个目录都行)，使用wget下载ipopt的包，并且解压</span></span><br><span class="line"><span class="built_in">cd</span> /tmp/</span><br><span class="line">wget https://www.coin-or.org/download/source/Ipopt/Ipopt-3.12.7.zip &amp;&amp; unzip Ipopt-3.12.7.zip &amp;&amp; <span class="built_in">rm</span> Ipopt-3.12.7.zip</span><br><span class="line"><span class="comment"># 3.使用脚本安装ipopt，p.s.脚本放在在本文档同级目录下的scripts文件夹下</span></span><br><span class="line"><span class="built_in">sudo</span> ./install_ipopt.sh Ipopt-3.12.7</span><br></pre></td></tr></table></figure>

<h1 id="Abseil"><a href="#Abseil" class="headerlink" title="Abseil"></a>Abseil</h1><h4 id="1-abseil安装"><a href="#1-abseil安装" class="headerlink" title="1. abseil安装"></a>1. abseil安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.进入tmp目录</span></span><br><span class="line"><span class="built_in">cd</span> /tmp/</span><br><span class="line"><span class="comment"># 2.从github拉取abseil源码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/abseil/abseil-cpp.git</span><br><span class="line"><span class="comment"># 3.建立build文件夹</span></span><br><span class="line"><span class="built_in">cd</span> abseil-cpp &amp;&amp; <span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line"><span class="comment"># 4.生成makefile，指定C++14(abseil最低要求)</span></span><br><span class="line">cmake -DABSL_BUILD_TESTING=ON -DABSL_USE_GOOGLETEST_HEAD=ON -DCMAKE_CXX_STANDARD=14 ..</span><br><span class="line"><span class="comment"># 5.build</span></span><br><span class="line">cmake --build . --target all</span><br><span class="line"><span class="comment"># 6.install</span></span><br><span class="line"><span class="built_in">sudo</span> cmake --install .</span><br><span class="line"><span class="comment"># 7.刷新共享库</span></span><br><span class="line"><span class="built_in">sudo</span> ldconfig</span><br></pre></td></tr></table></figure>

<p>CMakeList.txt模板，注意Abseil库最低要求C++14（支持C++17 C++20）</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.8</span>.<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(my_project)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Abseil requires C++14</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Import Abseil&#x27;s CMake targets</span></span><br><span class="line"><span class="keyword">find_package</span>(absl REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(hello_world hello_world.cc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Declare dependency on the absl::strings library</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(hello_world absl::strings)</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/abseil/abseil-cpp/blob/master/CMake/README.md">可以链接的Abseil公共库</a>，如下图所示：</p>
<img src="images/image-20220815154240357.png" alt="image-20220815154240357" style="zoom: 50%;" />

<h1 id="spdlog"><a href="#spdlog" class="headerlink" title="spdlog"></a>spdlog</h1><h4 id="1-spdlog安装"><a href="#1-spdlog安装" class="headerlink" title="1. spdlog安装"></a>1. spdlog安装</h4><p>仓库地址：<a target="_blank" rel="noopener" href="https://github.com/gabime/spdlog">https://github.com/gabime/spdlog</a></p>
<p>安装方法：spdlog是一个head-only的库，只需要将git仓库中的include文件夹复制到自己的项目即可。</p>
<p>安装方法2: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/gabime/spdlog.git</span><br><span class="line"><span class="built_in">cd</span> spdlog &amp;&amp; <span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake .. &amp;&amp; make -j8</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure>

<h4 id="2-2-使用方法"><a href="#2-2-使用方法" class="headerlink" title="2.2 使用方法"></a>2.2 使用方法</h4><p>spdlog用什么类，就包含哪个头文件</p>
<blockquote>
<p>spdlog takes the “include what you need” approach - your code should include the features that actually needed.</p>
<p>For example, if you only need rotating logger, you need to include “<strong>spdlog&#x2F;sinks&#x2F;rotating_file_sink.h</strong>“.</p>
</blockquote>
<h5 id="2-1-spdlog库基本架构"><a href="#2-1-spdlog库基本架构" class="headerlink" title="2.1 spdlog库基本架构"></a>2.1 spdlog库基本架构</h5><ul>
<li>sink: 进行底层操作（比如格式化内容、输出内容到控制台&#x2F;文件）的类。spdlog自带的几种sinks已经能满足日常需求，也可以派生其基类设计新的sink以满足特殊的需求。sink类主要使用的函数包括：</li>
</ul>
<p>​				<code>set_pattern(const std::string&amp;)</code> ：设置日志输出的内容格式。</p>
<p>​				<code>set_level(level_enum)</code> ： 设置日志输出的最低等级。</p>
<p>​				<code>log(log_msg)</code> ：由logger自动调用，外部不会主动调用。</p>
<ul>
<li>logger: 与程序员交互，用以输出日志的类。一个logger对象中可以有多个sink，当logger调用日志输出函数时，logger会调用自身存储的所有sink对象的log(log_msg) 函数进行输出。spdlog也自带了几种logger。logger类主要使用的函数包括：</li>
</ul>
<p>​				<code>set_pattern(const std::string&amp;)</code> ：设置logger中包含的所有sink的日志输出内容格式。</p>
<p>​				<code>set_level(level_enum)</code> ：设置logger日志输出最低等级，如果logger包含的sink没有设置日志等级的话，则会为其设置日志等级。</p>
<p>​				<code>log(level_enum level,log_msg content)</code> ：按照level等级进行输出content，如果level&gt;logger等级且大于某个sink的等级，则该sink会输出。</p>
<ul>
<li>st&#x2F;mt： 对象版本，spdlog中的logger对象和sink对象都有两种版本，一种是以st结尾的单线程版本，以及以mt结尾的多线程版本。</li>
</ul>
<p>​				st：单线程版本，不用加锁，效率更高。<br>​				mt：多线程版本，用于多线程程序是线程安全的。</p>
<h5 id="2-2-spdlog的日志等级"><a href="#2-2-spdlog的日志等级" class="headerlink" title="2.2 spdlog的日志等级"></a>2.2 spdlog的日志等级</h5><p><code>spdlog</code>的日志等级如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">trace = SPDLOG_LEVEL_TRACE <span class="comment">// 最低级（用来记录代码执行轨迹）</span></span><br><span class="line">debug = SPDLOG_LEVEL_DEBUG <span class="comment">//      （用来记录debug信息）</span></span><br><span class="line">info = SPDLOG_LEVEL_INFO   <span class="comment">// 在上面的测试例子中用过</span></span><br><span class="line">warn = SPDLOG_LEVEL_WARN</span><br><span class="line">err = SPDLOG_LEVEL_ERROR</span><br><span class="line">critical = SPDLOG_LEVEL_CRITICAL</span><br><span class="line">off = SPDLOG_LEVEL_OFF     <span class="comment">// 最高级</span></span><br></pre></td></tr></table></figure>

<p><code>spdlog</code>默认的是<code>info</code>等级，可以通过<code>set_level</code>函数设置<code>sink</code>或者<code>logger</code>的等级。设置等级的作用在于，可以在程序运行前确定输出的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spdlog::set_level(spdlog::level::info); // 只显示info及比info高级的信息，logger.trace() 和 logger.debug() 不显示</span><br></pre></td></tr></table></figure>

<h5 id="2-3-spdlog的pattern设置"><a href="#2-3-spdlog的pattern设置" class="headerlink" title="2.3 spdlog的pattern设置"></a>2.3 spdlog的pattern设置</h5><p>日志内容的前面的title是可以通过pattern设置的，可设置的参数如下图所示。</p>
<table>
<thead>
<tr>
<th>flag</th>
<th>meaning</th>
<th>example</th>
</tr>
</thead>
<tbody><tr>
<td><code>%v</code></td>
<td>The actual text to log</td>
<td>“some user text”</td>
</tr>
<tr>
<td><code>%t</code></td>
<td>Thread id</td>
<td>“1232”</td>
</tr>
<tr>
<td><code>%P</code></td>
<td>Process id</td>
<td>“3456”</td>
</tr>
<tr>
<td><code>%n</code></td>
<td>Logger’s name</td>
<td>“some logger name”</td>
</tr>
<tr>
<td><code>%l</code></td>
<td>The log level of the message</td>
<td>“debug”, “info”, etc</td>
</tr>
<tr>
<td><code>%L</code></td>
<td>Short log level of the message</td>
<td>“D”, “I”, etc</td>
</tr>
<tr>
<td><code>%a</code></td>
<td>Abbreviated weekday name</td>
<td>“Thu”</td>
</tr>
<tr>
<td><code>%A</code></td>
<td>Full weekday name</td>
<td>“Thursday”</td>
</tr>
<tr>
<td><code>%b</code></td>
<td>Abbreviated month name</td>
<td>“Aug”</td>
</tr>
<tr>
<td><code>%B</code></td>
<td>Full month name</td>
<td>“August”</td>
</tr>
<tr>
<td><code>%c</code></td>
<td>Date and time representation</td>
<td>“Thu Aug 23 15:35:46 2014”</td>
</tr>
<tr>
<td><code>%C</code></td>
<td>Year in 2 digits</td>
<td>“14”</td>
</tr>
<tr>
<td><code>%Y</code></td>
<td>Year in 4 digits</td>
<td>“2014”</td>
</tr>
<tr>
<td><code>%D</code> or <code>%x</code></td>
<td>Short MM&#x2F;DD&#x2F;YY date</td>
<td>“08&#x2F;23&#x2F;14”</td>
</tr>
<tr>
<td><code>%m</code></td>
<td>Month 01-12</td>
<td>“11”</td>
</tr>
<tr>
<td><code>%d</code></td>
<td>Day of month 01-31</td>
<td>“29”</td>
</tr>
<tr>
<td><code>%H</code></td>
<td>Hours in 24 format 00-23</td>
<td>“23”</td>
</tr>
<tr>
<td><code>%I</code></td>
<td>Hours in 12 format 01-12</td>
<td>“11”</td>
</tr>
<tr>
<td><code>%M</code></td>
<td>Minutes 00-59</td>
<td>“59”</td>
</tr>
<tr>
<td><code>%S</code></td>
<td>Seconds 00-59</td>
<td>“58”</td>
</tr>
<tr>
<td><code>%e</code></td>
<td>Millisecond part of the current second 000-999</td>
<td>“678”</td>
</tr>
<tr>
<td><code>%f</code></td>
<td>Microsecond part of the current second 000000-999999</td>
<td>“056789”</td>
</tr>
<tr>
<td><code>%F</code></td>
<td>Nanosecond part of the current second 000000000-999999999</td>
<td>“256789123”</td>
</tr>
<tr>
<td><code>%p</code></td>
<td>AM&#x2F;PM</td>
<td>“AM”</td>
</tr>
<tr>
<td><code>%r</code></td>
<td>12 hour clock</td>
<td>“02:55:02 PM”</td>
</tr>
<tr>
<td><code>%R</code></td>
<td>24-hour HH:MM time, equivalent to %H:%M</td>
<td>“23:55”</td>
</tr>
<tr>
<td><code>%T</code> or <code>%X</code></td>
<td>ISO 8601 time format (HH:MM:SS), equivalent to %H:%M:%S</td>
<td>“23:55:59”</td>
</tr>
<tr>
<td><code>%z</code></td>
<td>ISO 8601 offset from UTC in timezone ([+&#x2F;-]HH:MM)</td>
<td>“+02:00”</td>
</tr>
<tr>
<td><code>%E</code></td>
<td>Seconds since the epoch</td>
<td>“1528834770”</td>
</tr>
<tr>
<td><code>%%</code></td>
<td>The % sign</td>
<td>“%”</td>
</tr>
<tr>
<td><code>%+</code></td>
<td>spdlog’s default format</td>
<td>“[2014-10-31 23:46:59.678] [mylogger] [info] Some message”</td>
</tr>
<tr>
<td><code>%^</code></td>
<td>start color range (can be used only once)</td>
<td>“[mylogger] [info(green)] Some message”</td>
</tr>
<tr>
<td><code>%$</code></td>
<td>end color range (for example %^[+++]%$ %v) (can be used only once)</td>
<td>[+++] Some message</td>
</tr>
<tr>
<td><code>%@</code></td>
<td>Source file and line (use SPDLOG_TRACE(..), SPDLOG_INFO(…) etc. instead of spdlog::trace(…)) Same as %g:%#</td>
<td>&#x2F;some&#x2F;dir&#x2F;my_file.cpp:123</td>
</tr>
<tr>
<td><code>%s</code></td>
<td>Basename of the source file (use SPDLOG_TRACE(..), SPDLOG_INFO(…) etc.)</td>
<td>my_file.cpp</td>
</tr>
<tr>
<td><code>%g</code></td>
<td>Full or relative path of the source file as appears in the <code>__FILE__</code> macro (use SPDLOG_TRACE(..), SPDLOG_INFO(…) etc.)</td>
<td>&#x2F;some&#x2F;dir&#x2F;my_file.cpp</td>
</tr>
<tr>
<td><code>%#</code></td>
<td>Source line (use SPDLOG_TRACE(..), SPDLOG_INFO(…) etc.)</td>
<td>123</td>
</tr>
<tr>
<td><code>%!</code></td>
<td>Source function (use SPDLOG_TRACE(..), SPDLOG_INFO(…) etc. see tweakme for pretty-print)</td>
<td>my_func</td>
</tr>
<tr>
<td><code>%o</code></td>
<td>Elapsed time in milliseconds since previous message</td>
<td>456</td>
</tr>
<tr>
<td><code>%i</code></td>
<td>Elapsed time in microseconds since previous message</td>
<td>456</td>
</tr>
<tr>
<td><code>%u</code></td>
<td>Elapsed time in nanoseconds since previous message</td>
<td>11456</td>
</tr>
<tr>
<td><code>%O</code></td>
<td>Elapsed time in seconds since previous message</td>
<td>4</td>
</tr>
</tbody></table>
<p>实例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPDLOG_ACTIVE_LEVEL SPDLOG_LEVEL_TRACE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spdlog/spdlog.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spdlog/sinks/stdout_color_sinks.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spdlog/sinks/rotating_file_sink.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spdlog_test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建logger</span></span><br><span class="line">    <span class="keyword">auto</span> console_log = spdlog::<span class="built_in">stdout_color_mt</span>(<span class="string">&quot;DRScreen&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> file_log   = spdlog::<span class="built_in">rotating_logger_mt</span>(<span class="string">&quot;DRFile&quot;</span>, <span class="string">&quot;Logs/DR.txt&quot;</span>, <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 设置logger等级</span></span><br><span class="line">    console_log-&gt;<span class="built_in">set_level</span>(spdlog::level::debug);</span><br><span class="line">    file_log-&gt;<span class="built_in">set_level</span>(spdlog::level::debug);</span><br><span class="line">    <span class="comment">// 设置logger title</span></span><br><span class="line">    console_log-&gt;<span class="built_in">set_pattern</span>(<span class="string">&quot;[%Y/%m/%d %H:%M:%S.%e][%l][%s:%#] %v&quot;</span>);</span><br><span class="line">    file_log-&gt;<span class="built_in">set_pattern</span>(<span class="string">&quot;%v&quot;</span>);</span><br><span class="line">    <span class="comment">// 记录log</span></span><br><span class="line">    <span class="comment">// 打印到屏幕</span></span><br><span class="line">    <span class="built_in">SPDLOG_LOGGER_INFO</span>(console_log, <span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">    console_log-&gt;<span class="built_in">info</span>(<span class="string">&quot;hello, world&quot;</span>); <span class="comment">// 使用这种方式记录，不会打印行号等自定义信息</span></span><br><span class="line">    <span class="comment">// 输出到文件</span></span><br><span class="line">    file_log-&gt;<span class="built_in">info</span>(<span class="string">&quot;Time X Y Yaw&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">spdlog_test</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[2022/10/26 14:46:31.251][info][main.cpp:21] hello, world</span><br><span class="line">[2022/10/26 14:46:31.251][info][:] hello, world</span><br><span class="line">同时，在可执行文件同级目录下有,Logs/DR.txt文件，文件中的内容是：</span><br><span class="line">Time X Y Yaw</span><br></pre></td></tr></table></figure>

<h1 id="yaml-cpp"><a href="#yaml-cpp" class="headerlink" title="yaml-cpp"></a>yaml-cpp</h1><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h4><p>方法1：源码编译</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/jbeder/yaml-cpp.git</span><br><span class="line"><span class="built_in">cd</span> yaml-cpp</span><br><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake .. &amp;&amp; make -j8</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure>

<p>方法2：msys2安装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S mingw-w64-x86_64-yaml-cpp</span><br></pre></td></tr></table></figure>

<p>cmakelist.txt如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(yaml-cpp REQUIRED)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;YAML_CPP_INCLUDE_DIR&#125;</span>)</span><br><span class="line"><span class="comment"># 或者用此方法include</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PRIVATE <span class="variable">$&#123;YAML_CPP_INCLUDE_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(node_name yaml-cpp)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://longfei1995.github.io/2024/01/01/gac/veh_test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡云浩">
      <meta itemprop="description" content="记录生活，记录工作，记录学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="胡云浩的blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/01/gac/veh_test/" class="post-title-link" itemprop="url">车辆测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-01-01T00:00:00+08:00">2024-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-10 17:04:16" itemprop="dateModified" datetime="2025-04-10T17:04:16+08:00">2025-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%A6%E8%BE%86%E6%B5%8B%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">车辆测试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="A09通过车机连接热点"><a href="#A09通过车机连接热点" class="headerlink" title="A09通过车机连接热点"></a>A09通过车机连接热点</h5><ol>
<li>安装platform的工具</li>
<li>使用<code>cmd</code>进入platform文件夹的目录下，并且使用查看无线网的默认网关地址</li>
<li>执行如下命令</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb connect &lt;默认网关&gt;</span><br><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">ndc nat enable wlan1 eth0 <span class="literal">-help</span></span><br></pre></td></tr></table></figure>

<p>如果出现报错”more than one device &#x2F; emulator”。再修改成以下指令连接ADC</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="literal">-s</span> &lt;默认网关&gt;:<span class="number">5555</span> shell</span><br><span class="line">su</span><br><span class="line">ndc nat enable wlan1 eth0 <span class="literal">-help</span></span><br></pre></td></tr></table></figure>

<h5 id="T68-密码"><a href="#T68-密码" class="headerlink" title="T68 密码"></a>T68 密码</h5><p>Gac@1234##</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://longfei1995.github.io/2024/01/01/matlab_python/simulinkNote/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡云浩">
      <meta itemprop="description" content="记录生活，记录工作，记录学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="胡云浩的blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/01/matlab_python/simulinkNote/" class="post-title-link" itemprop="url">Carsim/Simulink</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-01-01T00:00:00+08:00">2024-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-10 17:04:49" itemprop="dateModified" datetime="2025-04-10T17:04:49+08:00">2025-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Carsim-Simulink/" itemprop="url" rel="index"><span itemprop="name">Carsim/Simulink</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Carsim-Simulink"><a href="#Carsim-Simulink" class="headerlink" title="Carsim&#x2F;Simulink"></a>Carsim&#x2F;Simulink</h3><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装</h4><ul>
<li>如果carsim里找不到matlab</li>
</ul>
<p>在注册表中添加如下图片的内容</p>
<p><img src="/images/carsimFindMatlab.PNG"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://longfei1995.github.io/2024/01/01/matlab_python/PythonNote/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡云浩">
      <meta itemprop="description" content="记录生活，记录工作，记录学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="胡云浩的blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/01/matlab_python/PythonNote/" class="post-title-link" itemprop="url">Python笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-01-01T00:00:00+08:00">2024-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-10 17:04:43" itemprop="dateModified" datetime="2025-04-10T17:04:43+08:00">2025-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="conda使用"><a href="#conda使用" class="headerlink" title="conda使用"></a>conda使用</h4><ul>
<li><p>创建指定的版本 <code>conda create --name [环境名] python=[指定版本] </code>例：<code>conda create --name py38 python=3.8</code></p>
</li>
<li><p>删除版本<code>conda remove --name 环境名称 --all</code></p>
</li>
<li><p>将conda从win64切换成win32 <code>conda config --env --set subdir win-32</code></p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://longfei1995.github.io/2024/01/01/other_tools/ROSNote/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡云浩">
      <meta itemprop="description" content="记录生活，记录工作，记录学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="胡云浩的blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/01/other_tools/ROSNote/" class="post-title-link" itemprop="url">ROS笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-01-01T00:00:00+08:00">2024-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-10 17:05:12" itemprop="dateModified" datetime="2025-04-10T17:05:12+08:00">2025-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ROS/" itemprop="url" rel="index"><span itemprop="name">ROS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="ROS1"><a href="#ROS1" class="headerlink" title="ROS1"></a>ROS1</h3><h4 id="1-ROS安装中的常见问题"><a href="#1-ROS安装中的常见问题" class="headerlink" title="1 ROS安装中的常见问题"></a>1 ROS安装中的常见问题</h4><h5 id="1-1-sudo-rosdep-init出现错误"><a href="#1-1-sudo-rosdep-init出现错误" class="headerlink" title="1.1 sudo rosdep init出现错误"></a>1.1 sudo rosdep init出现错误</h5><blockquote>
<p>sudo rosdep init时出现“sudo: rosdep:command not found”</p>
</blockquote>
<p>1.执行命令<code>sudo apt install rospack-tools</code></p>
<p>2.然后重新运行<code>sudo rosdep init</code>即可</p>
<h5 id="1-2-rosdep-update报错"><a href="#1-2-rosdep-update报错" class="headerlink" title="1.2 rosdep update报错"></a>1.2 rosdep update报错</h5><p><strong>报错信息</strong>：</p>
<blockquote>
<p>sudo rosdep init时出现“ERROR: cannot download default sources list from:<br><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/sources.list.d/20-default.list">https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/sources.list.d/20-default.list</a><br>Website may be down.</p>
</blockquote>
<p><strong>报错原因</strong>：</p>
<p>境外资源被屏蔽</p>
<p><strong>解决方法1</strong>：修改hosts文件</p>
<p>1.首先进入&#x2F;etc，更改hosts文件的权限</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> gedit /etc/hosts</span><br></pre></td></tr></table></figure>

<p>2.打开hosts文件后，在文件末尾添加以下内容，并保存退出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">151.101.84.133  raw.githubusercontent.com</span><br></pre></td></tr></table></figure>

<p>3.如果执行第二步后还是不行，如果还不行，在IPAddress网站中（<a target="_blank" rel="noopener" href="https://www.ipaddress.com),输入raw.githubusercontent.com查询到网址真实的ip地址,替换步骤2中提到的ip/">https://www.ipaddress.com）,输入raw.githubusercontent.com查询到网址真实的IP地址，替换步骤2中提到的IP</a></p>
<p><strong>解决方法2：用国内的rosdep镜像源</strong></p>
<p>参考：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/VGs8oWdhHH6XsHcx21lN4Q">https://mp.weixin.qq.com/s/VGs8oWdhHH6XsHcx21lN4Q</a></p>
<p>1.安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pip install rosdepc 或者 <span class="built_in">sudo</span> pip3 install rosdepc</span><br><span class="line"><span class="comment"># 如果提示没有pip或者pip3</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install python3-pip </span><br><span class="line"><span class="built_in">sudo</span> pip install rosdepc</span><br></pre></td></tr></table></figure>

<p>2.使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> rosdepc init</span><br><span class="line">rosdepc update</span><br></pre></td></tr></table></figure>

<h4 id="2-ROS1的使用"><a href="#2-ROS1的使用" class="headerlink" title="2 ROS1的使用"></a>2 ROS1的使用</h4><h5 id="2-1-创建并初始化catkin工作空间"><a href="#2-1-创建并初始化catkin工作空间" class="headerlink" title="2.1 创建并初始化catkin工作空间"></a>2.1 创建并初始化catkin工作空间</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ./catkin_ws/src	<span class="comment"># 在当前文件夹下创建二层文件夹 catkin_ws/src</span></span><br><span class="line">							<span class="comment"># src文件夹是放置ros源码包的地方</span></span><br><span class="line"><span class="built_in">cd</span> catkin_ws/			    <span class="comment"># 进入catkin_ws</span></span><br><span class="line">catkin_make 				<span class="comment"># 初始化工作空间,注意该命令必须在catkin工作空间目录下执行</span></span><br><span class="line">							<span class="comment"># 原先的初始化命令catkin_init_workspace命令仍然保留</span></span><br></pre></td></tr></table></figure>

<p>catkin_ws文件夹下现在有三个文件夹，编译时的工作流程如下图所示</p>
<p><img src="/images/tool_1.png"></p>
<ul>
<li>src&#x2F; 用来放置源代码的地方</li>
<li>build&#x2F; catkin(CMAKE)编译器放置缓存信息和中间文件的地方</li>
<li>devel&#x2F; 生成的目标文件（包括头文件，动态链接库，静态链接库，可执行文件，环境变量等）</li>
</ul>
<p>catkin编译器在编译时，会递归的查找src&#x2F;下的每一个源代码包，因此也可以将几个源代码包放在同一文件夹下，如下图所示</p>
<p><img src="/images/useful2.PNG" alt="2"></p>
<h5 id="2-2-创建ROS-package"><a href="#2-2-创建ROS-package" class="headerlink" title="2.2 创建ROS package"></a>2.2 创建ROS package</h5><p>任何ROS的代码无论是C++还是Python都要放到package中，这样才能正常的编译和运行。一个ROS package中一般常见的文件有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── CMakeLists.txt    #	package的编译规则(必须)</span><br><span class="line">├── package.xml       #	描述package的包名、版本号、作者、依赖等信息（必须）</span><br><span class="line">├── src/              #	源代码文件，包括C++源码(.cpp)以及Python的module(.py)</span><br><span class="line">├── include/          #	C++头文件</span><br><span class="line">├── scripts/          # 例如shell脚本(.sh)、Python脚本(.py)</span><br><span class="line">├── msg/              #	存放自定义格式的ROS消息(.msg)</span><br><span class="line">├── srv/              #	存放自定义格式的ROS服务(.srv)</span><br><span class="line">├── models/           #	存放机器人或仿真场景的3D模型(.sda, .stl, .dae等)</span><br><span class="line">├── urdf/             #	存放机器人的模型描述(.urdf或.xacro)</span><br><span class="line">├── launch/           #	存放launch文件(.launch或.xml)</span><br></pre></td></tr></table></figure>

<p><strong>第一步：创建package目录</strong></p>
<p>创建一个package需要用到<code>catkin_create_pkg package depends</code>其中package是包名，depends是依赖的包名，可以依赖多个软件包。例如想要创建一个名为<code>ros_stanley</code>的包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd catkin_ws/src</span><br><span class="line">catkin_create_pkg ros_stanley roscpp rospy std_msgs</span><br></pre></td></tr></table></figure>

<p><strong>第二步：修改package中的cmakelist.txt</strong></p>
<p><code>CMakeLists.txt</code>的基本语法都还是按照CMake，而Catkin在其中加入了少量的宏，总体的结构如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>() <span class="comment">#CMake的版本号 </span></span><br><span class="line"><span class="keyword">project</span>()                <span class="comment">#项目名称 </span></span><br><span class="line"><span class="keyword">find_package</span>()           <span class="comment">#找到编译需要的其他CMake/Catkin package</span></span><br><span class="line">catkin_python_setup()    <span class="comment">#catkin新加宏，打开catkin的Python Module的支持</span></span><br><span class="line">add_message_files()      <span class="comment">#catkin新加宏，添加自定义Message/Service/Action文件</span></span><br><span class="line">add_service_files()</span><br><span class="line">add_action_files()</span><br><span class="line">generate_message()       <span class="comment">#catkin新加宏，生成不同语言版本的msg/srv/action接口</span></span><br><span class="line">catkin_package()         <span class="comment">#catkin新加宏，生成当前package的cmake配置，供依赖本包的其他软件包调用</span></span><br><span class="line"><span class="keyword">add_library</span>()            <span class="comment">#生成库</span></span><br><span class="line"><span class="keyword">add_executable</span>()         <span class="comment">#生成可执行二进制文件</span></span><br><span class="line"><span class="keyword">add_dependencies</span>()       <span class="comment">#定义目标文件依赖于其他目标文件，确保其他目标已被构建</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>()  <span class="comment">#链接</span></span><br><span class="line">catkin_add_gtest()       <span class="comment">#catkin新加宏，生成测试</span></span><br><span class="line"><span class="keyword">install</span>()                <span class="comment">#安装至本机</span></span><br></pre></td></tr></table></figure>

<p>(1)Cmakelist.txt的例子</p>
<p>以ros_stanley为例，一般创建两个软件包，一个<code>custom_msgs</code>只用来存放ros msg。一个<code>ros_stanley</code>用来存放stanley的代码。</p>
<p>①custom_msgs软件包的Cmakelist.txt</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">2</span>)	<span class="comment">#cmake至少为3.0.2版</span></span><br><span class="line"><span class="keyword">project</span>(custom_msgs)  <span class="comment"># 项目的名称为custom_msgs，在后续的文件中可以使用变量$&#123;PROJECT_NAME&#125;代替项目名称custom_msgs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># find_package是cmake宏命令，指定依赖的其他pacakge，实际是生成了一些环境变量，如&lt;NAME&gt;_FOUND, &lt;NAME&gt;_INCLUDE_DIRS, &lt;NAME&gt;_LIBRARYIS</span></span><br><span class="line"><span class="comment"># 此处catkin是必备依赖 其余的roscpp...为组件</span></span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS roscpp rospy message_generation std_msgs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定.msg文件</span></span><br><span class="line">add_message_files(FILES path_track.msg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成msg的头文件和.py，生成的文件位于devel/include中</span></span><br><span class="line">generate_messages(DEPENDENCIES std_msgs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># catkin_package是catkin宏命令，用于配置ROS的package配置文件和CMake文件</span></span><br><span class="line"><span class="comment"># 这个命令必须在add_library()或者add_executable()之前调用，该函数有5个可选参数：</span></span><br><span class="line"><span class="comment"># (1) INCLUDE_DIRS 		- 导出包的include路径</span></span><br><span class="line"><span class="comment"># (2) LIBRARIES 		- 导出项目中的库</span></span><br><span class="line"><span class="comment"># (3) CATKIN_DEPENDS 	- 该项目依赖的其他catkin项目</span></span><br><span class="line"><span class="comment"># (4) DEPENDS 			- 该项目所依赖的非catkin CMake项目。</span></span><br><span class="line">catkin_package(</span><br><span class="line"><span class="comment">#  INCLUDE_DIRS include</span></span><br><span class="line"><span class="comment">#  LIBRARIES custom_msgs</span></span><br><span class="line">   CATKIN_DEPENDS message_runtime</span><br><span class="line"><span class="comment">#  DEPENDS system_lib</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>②ros_stanley中的cmakelist.txt</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">2</span>)</span><br><span class="line"><span class="keyword">project</span>(ros_stanley)        </span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="comment">## 构建此软件包所需要依赖的软件包</span></span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS roscpp rospy std_msgs message_generation custom_msgs)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 执行时依赖</span></span><br><span class="line">catkin_package(CATKIN_DEPENDS roscpp rospy std_msgs message_runtime)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 指定C++的头文件路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="keyword">include</span> <span class="variable">$&#123;catkin_INCLUDE_DIRS&#125;</span></span><br><span class="line"><span class="keyword">include_directories</span>(../../../devel/<span class="keyword">include</span>) <span class="comment">##include msg header</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>/eigen)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 生成可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(n_stanley_controller src/n_stanley_controller.cpp</span><br><span class="line">                                    src/stanley_controller.cpp)</span><br><span class="line"><span class="comment"># 添加可执行文件的依赖</span></span><br><span class="line"><span class="keyword">add_dependencies</span>(n_stanley_controller custom_msgs_gencpp)   <span class="comment">#让custom_msgs包先编译</span></span><br><span class="line"><span class="keyword">add_dependencies</span>(n_stanley_controller <span class="variable">$&#123;$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125; <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可执行文件链接相关的库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(n_stanley_controller <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>第三步：修改package中的package.xml</strong></p>
<p>(1)package.xml的作用</p>
<p><code>pacakge.xml</code>包含了package的名称、版本号、内容描述、维护人员、软件许可、编译构建工具、编译依赖、运行依赖等信息。<br>实际上<code>rospack find</code>、<code>rosdep</code>等命令之所以能快速定位和分析出package的依赖项信息，就是直接读取了每一个pacakge中的<code>package.xml</code>文件。它为用户提供了快速了解一个pacakge的渠道。</p>
<p>(2)package.xml的例子</p>
<p><code>package.xml</code>现在有两种格式并存（format1和format2），两者区别不大，下面用ros_stanley中的package.xml来说明（format2）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">format</span>=<span class="string">&quot;2&quot;</span>&gt;</span>		<span class="comment">&lt;!--在声明package时指定format2格式--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>ros_stanley<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>The ros_stanley package<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maintainer</span> <span class="attr">email</span>=<span class="string">&quot;hyh@todo.todo&quot;</span>&gt;</span>hyh<span class="tag">&lt;/<span class="name">maintainer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">license</span>&gt;</span>TODO<span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!--编译工具为catkin--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">buildtool_depend</span>&gt;</span>catkin<span class="tag">&lt;/<span class="name">buildtool_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--编译依赖项--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>roscpp<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>rospy<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>std_msgs<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>custom_msgs<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--导出依赖项--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_export_depend</span>&gt;</span>roscpp<span class="tag">&lt;/<span class="name">build_export_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_export_depend</span>&gt;</span>rospy<span class="tag">&lt;/<span class="name">build_export_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_export_depend</span>&gt;</span>std_msgs<span class="tag">&lt;/<span class="name">build_export_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_export_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_export_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_export_depend</span>&gt;</span>custom_msgs<span class="tag">&lt;/<span class="name">build_export_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--运行依赖项--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>roscpp<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>rospy<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>std_msgs<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>custom_msgs<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- The export tag contains other, unspecified, tags --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">export</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Other tools can request additional information be placed here --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">export</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="ROS2"><a href="#ROS2" class="headerlink" title="ROS2"></a>ROS2</h3><h4 id="1-ROS2的安装-卸载"><a href="#1-ROS2的安装-卸载" class="headerlink" title="1 ROS2的安装&#x2F;卸载"></a>1 ROS2的安装&#x2F;卸载</h4><ul>
<li>使用脚本一键安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://fishros.com/install -O fishros &amp;&amp; bash fishros</span><br></pre></td></tr></table></figure>

<ul>
<li><p>手动安装</p>
</li>
<li><p>卸载</p>
</li>
</ul>
<p> 针对ros2 foxy版本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt remove ros-foxy-* &amp;&amp; <span class="built_in">sudo</span> apt autoremove</span><br></pre></td></tr></table></figure>

<h4 id="2-ROS2基础"><a href="#2-ROS2基础" class="headerlink" title="2 ROS2基础"></a>2 ROS2基础</h4><h5 id="2-1-工作空间和功能包"><a href="#2-1-工作空间和功能包" class="headerlink" title="2.1 工作空间和功能包"></a>2.1 工作空间和功能包</h5><blockquote>
<p>注意：一个工作空间下可以有多个功能包，一个功能包可以有多个节点存在</p>
</blockquote>
<h6 id="2-1-1-工作空间"><a href="#2-1-1-工作空间" class="headerlink" title="2.1.1 工作空间"></a>2.1.1 工作空间</h6><p>工作空间的定义：工作空间是包含若干个功能包的目录，一开始大家把工作空间理解成一个文件夹就行了。这个文件夹包含下有<code>src</code>等文件夹</p>
<p><strong>1.如何创建一个工作空间？</strong></p>
<p>使用 <code>mkdir</code>创建一个目录，或者使用<code>mkdir -p</code>直接递归的创建<code>src</code>文件夹</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ros2_ws/src</span><br><span class="line"><span class="built_in">cd</span> ros2_ws/src</span><br></pre></td></tr></table></figure>

<h6 id="2-1-2-功能包"><a href="#2-1-2-功能包" class="headerlink" title="2.1.2 功能包"></a>2.1.2 功能包</h6><p>功能包可以理解为存放节点的地方，ROS2中功能包根据编译方式的不同分为三种类型。</p>
<ul>
<li>ament_python，适用于python程序</li>
<li>cmake，适用于C++</li>
<li>ament_cmake，适用于C++程序,是cmake的增强版</li>
</ul>
<p><strong>1.如何获取一个功能包？</strong></p>
<ul>
<li>安装外部的功能包(功能包会自动放在ros的目录下，不用手动去source)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install ros-&lt;version&gt;-package_name</span><br></pre></td></tr></table></figure>

<ul>
<li>手动编译功能包，手动编译之后，需要手动的source工作空间中的Install目录</li>
</ul>
<h4 id="3-ROS2相关命令"><a href="#3-ROS2相关命令" class="headerlink" title="3 ROS2相关命令"></a>3 ROS2相关命令</h4><ul>
<li><strong>功能包相关命令</strong></li>
</ul>
<blockquote>
<p>1.每个包都有一个标配的manifest.xml文件，用于记录这个包的名字，构建工具，编译信息，拥有者，干啥用的等信息。通过这个文件，就可以自动为该功能包安装依赖，构建时确定编译顺序等</p>
</blockquote>
<p>创建功能包 <code>ros2 pkg create &lt;package-name&gt;  --build-type  &#123;cmake/ament_cmake/ament_python&#125;  --dependencies &lt;依赖名字&gt;</code></p>
<p>列出所有的包名 <code>ros2 pkg list</code></p>
<p>列出某个包所在路径的前缀 <code>ros2 pkg prefix &lt;package_name&gt;</code></p>
<p>列出某个包的xml文件 <code>ros2 pkg xml &lt;package_name&gt; </code></p>
<p>列出所有可执行文件 <code>ros2 pkg executables</code></p>
<p>仅仅列出某个功能包内的可执行文件 <code>ros2 pkg executables &lt;package_name&gt;</code></p>
<ul>
<li><strong>节点相关命令</strong></li>
</ul>
<p>source包的相关资源 <code>source install/setup.bash</code></p>
<p>运行一个节点（常用）<code>ros2 run &lt;package_name&gt; &lt;executable_name&gt;</code></p>
<p>查看节点列表 <code>ros2 node list</code></p>
<p>查看节点列表信息 <code>ros2 node info &lt;node_name&gt;</code></p>
<p>重映射节点名称 <code>ros2 run turtlesim turtlesim_node --ros-args --remap __node:=my_turtle</code></p>
<h4 id="4-ROS2的构建工具-colcon"><a href="#4-ROS2的构建工具-colcon" class="headerlink" title="4 ROS2的构建工具-colcon"></a>4 ROS2的构建工具-colcon</h4><ul>
<li><strong>colcon是什么?</strong></li>
</ul>
<p>colcon其实是一个功能包构建工具，相当于ros1中的catkin工具。</p>
<p>简单点说colcon就是用来编译代码的，在上一节中进行ROS2工作空间的创建后，但没有说如何进行编译，其实就是用colcon。</p>
<p>ROS2默认是没有安装colcon的，需要自己手动安装。</p>
<ul>
<li><strong>安装colcon</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install python3-colcon-common-extensions</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用colcon</strong></li>
</ul>
<p><strong>前述知识</strong></p>
<blockquote>
<p>ros2工作空间中的文件夹结构和ros1不同。有build install log src四个文件夹，install对应ros1中的devel文件夹，多了一个log文件夹</p>
</blockquote>
<p>进入<code>ros2工作空间目录</code>，编译整个工作空间 <code>colcon build</code></p>
<p>编译单独的包 <code>colcon build --packages-select &lt;package_name&gt; </code></p>
<h4 id="4-ROS2-通信机制"><a href="#4-ROS2-通信机制" class="headerlink" title="4 ROS2 通信机制"></a>4 ROS2 通信机制</h4><h5 id="4-1-ROS2通信简介"><a href="#4-1-ROS2通信简介" class="headerlink" title="4.1 ROS2通信简介"></a>4.1 ROS2通信简介</h5><p>ROS2提供了四种通信方式：</p>
<ul>
<li>话题-Topics</li>
<li>服务-Services</li>
<li>动作-Action</li>
<li>参数-Parameters</li>
</ul>
<p>除了参数之外，话题、服务和动作都支持自定义接口，每一种通信方式所适用的场景各不相同，所定义的接口也被分为话题接口、服务接口、动作接口三种。</p>
<p><strong>这三种接口定义起来有什么不一样的地方呢？</strong></p>
<p>话题接口格式：<code>xxx.msg</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int64 num</span><br></pre></td></tr></table></figure>

<p>服务接口格式：<code>xxx.srv</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int64 a</span><br><span class="line">int64 b</span><br><span class="line">---</span><br><span class="line">int64 sum</span><br></pre></td></tr></table></figure>

<p>动作接口格式：<code>xxx.action</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int32 order</span><br><span class="line">---</span><br><span class="line">int32[] sequence</span><br><span class="line">---</span><br><span class="line">int32[] partial_sequence</span><br></pre></td></tr></table></figure>

<p><strong>我们只是简单的写了一下接口的类型，那么怎么在Python或者C++中调用这些接口呢？</strong></p>
<p>ROS2的<code>IDL</code>转换器会自动帮我们完成代码的生成</p>
<p><img src="/images/image-20220614142556029.png" alt="image-20220614142556029"></p>
<p><strong>通信接口的常用命令</strong></p>
<p>查看所有接口的列表<code>ros2 interface list</code></p>
<p>查看接口所包含的包<code>ros2 interface packages</code></p>
<p>查看某一个包下的所有接口<code>ros2 interface package &lt;包名&gt;</code>，例：<code>ros2 interface package std_msgs</code></p>
<p>查看某一个接口的详细内容<code>ros2 interface show &lt;接口名&gt;</code>,例：<code>ros2 interface show std_msgs/msg/String</code></p>
<h5 id="4-2-自定义通信接口"><a href="#4-2-自定义通信接口" class="headerlink" title="4.2 自定义通信接口"></a>4.2 自定义通信接口</h5><h6 id="4-2-1-自定义-msg"><a href="#4-2-1-自定义-msg" class="headerlink" title="4.2.1 自定义.msg"></a>4.2.1 自定义.msg</h6><p>.msg是topic通信的通信接口定义文件，在实际的工程中，为了减少功能包之间的依赖，通常将.msg定义在一个独立的功能包中，方便其他各个功能包去调用。在本节中，我们定义一个名为<code>custom_interface</code>的功能包。步骤如下：</p>
<p><strong>0.建立工作空间</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ros2_ws/src</span><br></pre></td></tr></table></figure>

<p><strong>1.新建msg功能包</strong></p>
<p>在工作空间的src文件夹下，新建一个名为<code>custom_interface</code>的功能包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg create custom_interface --build-type ament_cmake</span><br></pre></td></tr></table></figure>

<p>功能包的目录如下</p>
<p><img src="/images/image-20220616083221186.png" alt="image-20220616083221186"></p>
<p><strong>2.编写.msg的内容</strong></p>
<p>我们在功能包根目录下<code>custom_interface/</code>新建一个<code>msg</code>文件夹，用来存<code>*.msg</code>文件。注意：ros2要求.msg文件的第一个字母一定要大写</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> msg</span><br><span class="line"><span class="built_in">cd</span> msg/</span><br><span class="line"><span class="built_in">touch</span> Test.msg</span><br></pre></td></tr></table></figure>

<p>Test.msg文件的内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float32 a       </span><br><span class="line">float32 b       </span><br><span class="line">float64 c       </span><br><span class="line">float64 d     	</span><br></pre></td></tr></table></figure>

<p><strong>3.修改功能包的CMakelist.txt</strong></p>
<p>在完成了<code>.msg</code>文件的编写后，我们还需要在cmakelist.txt中添加以下内容，告诉编译器，需要将<code>.msg</code>编译成对应的Python库文件和C++头文件</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用于查找.msg预编译器的位置</span></span><br><span class="line"><span class="keyword">find_package</span>(rosidl_default_generators REQUIRED)</span><br><span class="line"><span class="comment"># 声明.msg所属的工程名字、文件位置以及依赖</span></span><br><span class="line">rosidl_generate_interfaces(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="string">&quot;msg/Test.msg&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>添加完成后的<code>cmakelist.txt</code>如下图所示。注意：必须完成<code>package.xml</code>文件的修改后，才可以rerun cmakelist，不然会报错。</p>
<p><strong>4.修改package.xml</strong></p>
<p>我们还需要修改<code>custom_interface</code>功能包下的<code>package.xml</code>文件，为工程添加所需的依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>rosidl_default_generators<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>rosidl_default_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">member_of_group</span>&gt;</span>rosidl_interface_packages<span class="tag">&lt;/<span class="name">member_of_group</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加的位置如下图所示</p>
<img src="images/image-20220614154634790.png" alt="image-20220614154634790" style="zoom:67%;" />

<p><strong>5.编译</strong></p>
<p>至此，已经完成了<code>custom_interface</code>功能包的编写，我们重新编译一下该功能包即可。回到<strong>工作空间根目录</strong>下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colcon build --packages-select custom_interface</span><br></pre></td></tr></table></figure>

<p><strong>6.补充：如何确定自定义msg已经创建</strong></p>
<p>进入<strong>工作空间</strong>根目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> install/setup.bash</span><br><span class="line">ros2 interface show custom_interface/msg/Test </span><br></pre></td></tr></table></figure>

<p>显示如下内容，即成功创建了msg</p>
<img src="images/image-20220616091047952.png" alt="image-20220616091047952" style="zoom:67%;" />

<h5 id="3-3-ROS2话题"><a href="#3-3-ROS2话题" class="headerlink" title="3.3 ROS2话题"></a>3.3 ROS2话题</h5><h6 id="3-3-1-话题topic简介"><a href="#3-3-1-话题topic简介" class="headerlink" title="3.3.1 话题topic简介"></a>3.3.1 话题topic简介</h6><p>ros2话题是一个发布者、订阅者模型，可以是一个发布者，一个订阅者。还可以是1对n、n对1、n对n。</p>
<p>我们可以在命令行中直接输入<code>rqt_graph</code>来查看ros2各个节点订阅和发布的话题。</p>
<h6 id="3-3-2-topic的相关命令"><a href="#3-3-2-topic的相关命令" class="headerlink" title="3.3.2 topic的相关命令"></a>3.3.2 topic的相关命令</h6><p>0.帮助：<code>ros2 topic -h</code></p>
<p>1.打印当前的所有话题：<code>ros2 topic list</code></p>
<p>2.打印所有的话题，并且增加话题的消息类型：<code>ros2 topic list -t</code></p>
<h6 id="3-3-3-topic通信代码实现（C"><a href="#3-3-3-topic通信代码实现（C" class="headerlink" title="3.3.3 topic通信代码实现（C++)"></a>3.3.3 topic通信代码实现（C++)</h6><p><strong>目标</strong>：创建一个另外的功能包<code>ros_cm</code>，使用自定义的<code>.msg</code>实现如图所示的通信结构</p>
<img src="images/image-20220617103456728.png" alt="image-20220617103456728" style="zoom:67%;" />

<p><strong>代码实现步骤如下：</strong></p>
<p>0 进入<strong>工作空间&#x2F;src</strong>，创建功能包<code>ros_cm</code>，并且创建相应的.h和.cpp文件，如下图所示</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg create ros_cm --build-type ament_cmake --dependencies rclcpp</span><br></pre></td></tr></table></figure>

<img src="images/image-20220616093353442.png" alt="image-20220616093353442" style="zoom:67%;" />

<p>1 想要在<code>ros_cm</code>中调用上节创建的<code>custom_interface</code>功能包，需要修改<code>cmakelist.txt</code>,添加如下内容</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(custom_interface REQUIRED)</span><br><span class="line">ament_target_dependencies(&lt;可执行文件名字&gt; rclcpp custom_interface)</span><br></pre></td></tr></table></figure>

<p>完整的<code>CMakelist.txt</code>如下所示</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"><span class="keyword">project</span>(ros_cm)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Default to C99</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> CMAKE_C_STANDARD)</span><br><span class="line">  <span class="keyword">set</span>(CMAKE_C_STANDARD <span class="number">99</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Default to C++14</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> CMAKE_CXX_STANDARD)</span><br><span class="line">  <span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(CMAKE_COMPILER_IS_GNUCXX <span class="keyword">OR</span> CMAKE_CXX_COMPILER_ID <span class="keyword">MATCHES</span> <span class="string">&quot;Clang&quot;</span>)</span><br><span class="line">  <span class="keyword">add_compile_options</span>(-Wall -Wextra -Wpedantic)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># find dependencies</span></span><br><span class="line"><span class="keyword">if</span>(BUILD_TESTING)</span><br><span class="line">  <span class="keyword">find_package</span>(ament_lint_auto REQUIRED)</span><br><span class="line">  ament_lint_auto_find_test_dependencies()</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">find_package</span>(ament_cmake REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(rclcpp REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(custom_interface REQUIRED)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(node_1 src/node_1.cpp)</span><br><span class="line"><span class="keyword">target_include_directories</span>(node_1 PRIVATE <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line">ament_target_dependencies(node_1 rclcpp custom_interface)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(node_2 src/node_2.cpp)</span><br><span class="line"><span class="keyword">target_include_directories</span>(node_2 PRIVATE <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line">ament_target_dependencies(node_2 rclcpp custom_interface)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将编译好的文件安装到install/&#123;package_name&#125;/lib/&#123;PROJECT_NAME&#125;目录下</span></span><br><span class="line"><span class="keyword">install</span>(TARGETS</span><br><span class="line">        node_1</span><br><span class="line">        node_2</span><br><span class="line">        DESTINATION lib/<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">ament_package()</span><br></pre></td></tr></table></figure>

<p>2 然后在<code>package.xml</code>中添加<code>rclcpp</code>和<code>custom_interface</code>的依赖项</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">depend</span>&gt;</span>rclcpp<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">depend</span>&gt;</span>custom_interface<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>完整的<code>package.xml</code>如下所示</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-model href=<span class="string">&quot;http://download.ros.org/schema/package_format3.xsd&quot;</span> schematypens=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">format</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>ros_cm<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>TODO: Package description<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maintainer</span> <span class="attr">email</span>=<span class="string">&quot;hnu_huyunhao1995@163.com&quot;</span>&gt;</span>hyh<span class="tag">&lt;/<span class="name">maintainer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">license</span>&gt;</span>TODO: License declaration<span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">buildtool_depend</span>&gt;</span>ament_cmake<span class="tag">&lt;/<span class="name">buildtool_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">depend</span>&gt;</span>rclcpp<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">depend</span>&gt;</span>custom_interface<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">test_depend</span>&gt;</span>ament_lint_auto<span class="tag">&lt;/<span class="name">test_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">test_depend</span>&gt;</span>ament_lint_common<span class="tag">&lt;/<span class="name">test_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">export</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build_type</span>&gt;</span>ament_cmake<span class="tag">&lt;/<span class="name">build_type</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">export</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3 编译<code>ros_cm</code>包，先cd到工作空间下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colcon build --packages-select ros_cm</span><br></pre></td></tr></table></figure>

<p>4 代码编写</p>
<p><strong>node_1.h</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;custom_interface/msg/test.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;       <span class="comment">// 为了使用ms, s, min等单位</span></span><br><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node1</span> : <span class="keyword">public</span> rclcpp::Node &#123;</span><br><span class="line">    <span class="keyword">using</span> MsgType = custom_interface::msg::Test;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Node1</span>() : <span class="built_in">Node</span>(<span class="string">&quot;node1&quot;</span>) &#123;</span><br><span class="line">        publisher_ = <span class="built_in">create_publisher</span>&lt;MsgType&gt;(<span class="string">&quot;node1_pub&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        timer_ = <span class="built_in">create_wall_timer</span>(<span class="number">500</span>ms, std::<span class="built_in">bind</span>(&amp;Node1::pubCallBack, <span class="keyword">this</span>));</span><br><span class="line">        subscription_ = <span class="built_in">create_subscription</span>&lt;MsgType&gt;(<span class="string">&quot;node2_pub&quot;</span>, <span class="number">10</span>, std::<span class="built_in">bind</span>(&amp;Node1::subCallBack, <span class="keyword">this</span>, _1));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 发布消息时候的回调函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pubCallBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> msg = <span class="built_in">MsgType</span>();</span><br><span class="line">        msg.a = <span class="number">66.66</span>;</span><br><span class="line">        msg.b = <span class="number">77.77</span>;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;I publish: [a, b] = [%f, %f]&quot;</span>, msg.a, msg.b);</span><br><span class="line">        publisher_-&gt;<span class="built_in">publish</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">subCallBack</span><span class="params">(<span class="type">const</span> MsgType::SharedPtr msg)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;I receive: [c, d] = [%f, %f]&quot;</span>, msg-&gt;c, msg-&gt;d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    rclcpp::TimerBase::SharedPtr timer_;</span><br><span class="line">    rclcpp::Publisher&lt;MsgType&gt;::SharedPtr publisher_;</span><br><span class="line">    rclcpp::Subscription&lt;MsgType&gt;::SharedPtr subscription_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>node_1.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros_cm/node_1.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(std::<span class="built_in">make_shared</span>&lt;Node1&gt;());</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>node_2.h</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;custom_interface/msg/test.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;   <span class="comment">// 使用ms, s, min</span></span><br><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node2</span>:<span class="keyword">public</span> rclcpp::Node&#123;</span><br><span class="line">    <span class="keyword">using</span> MsgType = custom_interface::msg::Test;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Node2</span>():<span class="built_in">Node</span>(<span class="string">&quot;node2&quot;</span>)&#123;</span><br><span class="line">        subscription_ = <span class="built_in">create_subscription</span>&lt;MsgType&gt;(</span><br><span class="line">                <span class="string">&quot;node1_pub&quot;</span>, <span class="number">10</span>, std::<span class="built_in">bind</span>(&amp;Node2::subCallBack, <span class="keyword">this</span>, _1));</span><br><span class="line">        publisher_ = <span class="built_in">create_publisher</span>&lt;MsgType&gt;(<span class="string">&quot;node2_pub&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        timer_ = <span class="built_in">create_wall_timer</span>(<span class="number">500</span>ms, std::<span class="built_in">bind</span>(&amp;Node2::pubCallBack, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">subCallBack</span><span class="params">(<span class="type">const</span> MsgType::SharedPtr msg)</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;I receive [a, b] = [%f, %f]&quot;</span>, msg-&gt;a, msg-&gt;b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pubCallBack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> msg = <span class="built_in">MsgType</span>();</span><br><span class="line">        msg.c = <span class="number">88.88</span>;</span><br><span class="line">        msg.d = <span class="number">99.99</span>;</span><br><span class="line">        publisher_-&gt;<span class="built_in">publish</span>(msg);</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="built_in">get_logger</span>(), <span class="string">&quot;I publish [c, d] = [%f, %f]&quot;</span>, msg.c, msg.d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    rclcpp::TimerBase::SharedPtr timer_;</span><br><span class="line">    rclcpp::Subscription&lt;MsgType&gt;::SharedPtr subscription_;</span><br><span class="line">    rclcpp::Publisher&lt;MsgType&gt;::SharedPtr publisher_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>node_2.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros_cm/node_2.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(std::<span class="built_in">make_shared</span>&lt;Node2&gt;());</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://longfei1995.github.io/2024/01/01/other_tools/gdbNote/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡云浩">
      <meta itemprop="description" content="记录生活，记录工作，记录学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="胡云浩的blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/01/other_tools/gdbNote/" class="post-title-link" itemprop="url">gdb笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-01-01T00:00:00+08:00">2024-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-10 17:04:59" itemprop="dateModified" datetime="2025-04-10T17:04:59+08:00">2025-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/gdb/" itemprop="url" rel="index"><span itemprop="name">gdb</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1-基础操作"><a href="#1-基础操作" class="headerlink" title="1. 基础操作"></a>1. 基础操作</h4><h5 id="1-1-使用gdb调试可执行文件"><a href="#1-1-使用gdb调试可执行文件" class="headerlink" title="1.1 使用gdb调试可执行文件"></a>1.1 使用gdb调试可执行文件</h5><ol>
<li>确定可执行文件是否可以被gdb调试，使用<code>gdb &lt;可执行文件名&gt;</code></li>
</ol>
<p>如果不可以被gdb调试，会有类似以下的信息:Reading symbols from test0606…(No debugging symbols found in test0606)</p>
<p>如果想要可执行程序被gdb调试，在cmakelist.txt中加上<code>set(CMAKE_BUILD_TYPE Debug)</code>或者cmake编译时加上<code>-DCMAKE_BUILD_TYPE=Debug</code>选项</p>
<ol start="2">
<li>gdb .&#x2F;&lt;可执行文件&gt; 即可调试程序</li>
</ol>
<h5 id="1-2-使用gdb调试core-dump文件"><a href="#1-2-使用gdb调试core-dump文件" class="headerlink" title="1.2 使用gdb调试core dump文件"></a>1.2 使用gdb调试core dump文件</h5><ol>
<li><p>开启core文件生成</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 使用ulimit -c 或者 ulimit -a 来看生成文件是否开启，若返回core file size为0，则没有打开</span></span><br><span class="line"><span class="comment"># 2. 打开core文件生成，且不限制文件大小</span></span><br><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改core文件的生成目录和文件名</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 临时修改到当前目录下, 其中%e代表程序的名字</span></span><br><span class="line"><span class="built_in">echo</span> core-%e &gt; /proc/sys/kernel/core_pattern</span><br><span class="line"><span class="comment"># 如果提示没有权限的话，可以使用sudo bash -c &#x27;命令&#x27;， sudo bash -c &#x27;echo core-%e &gt; /proc/sys/kernel/core_pattern&#x27;</span></span><br><span class="line"><span class="comment"># 2. 永久修改到某个目录</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用gdb调试core文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gdb [exec file] [ core file]， 如</span></span><br><span class="line">gdb test0606 core-test0606</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">命令               简写形式         说明</span><br><span class="line">backtrace          bt、where       显示backtrace</span><br><span class="line">break              b               设置断点</span><br><span class="line">continue           c、cont         继续执行</span><br><span class="line">delete             d               删除断点</span><br><span class="line">finish                             运行到函数结束</span><br><span class="line">info breakpoints                   显示断点信息</span><br><span class="line">next               n               执行下一行</span><br><span class="line">print              p               显示表达式</span><br><span class="line">run                r               运行程序</span><br><span class="line">step               s               一次执行一行，包括函数内部</span><br><span class="line">x                                  显示内存内容</span><br><span class="line">until              u               执行到指定行</span><br><span class="line"></span><br><span class="line">其他命令</span><br><span class="line">directory          dir             插入目录</span><br><span class="line">disable            dis             禁用断点</span><br><span class="line">down               do              在当前调用的栈帧中选择要显示的栈帧</span><br><span class="line">edit               e               编辑文件或者函数</span><br><span class="line">frame              f               选择要显示的栈帧</span><br><span class="line">forward-search     fo              向前搜索</span><br><span class="line">generate-core-file gcore           生成内核转存储</span><br><span class="line">help                h              显示帮助一览</span><br><span class="line">info                i              显示信息</span><br><span class="line">list                l              显示函数或行</span><br><span class="line">nexti               ni             执行下一行(以汇编代码为单位)</span><br><span class="line">print-object        po             显示目标信息</span><br><span class="line">sharelibrary        share          加载共享的符号</span><br><span class="line">stepi               si             执行下一行</span><br></pre></td></tr></table></figure>

<h4 id="3-实践"><a href="#3-实践" class="headerlink" title="3. 实践"></a>3. 实践</h4><h5 id="3-1-gdb调试std-vector"><a href="#3-1-gdb调试std-vector" class="headerlink" title="3.1 gdb调试std::vector"></a>3.1 gdb调试std::vector</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0x000000000043b1c4 <span class="keyword">in</span> CollisionDetection::lineInterpolate (this=0xffffbc139f38, start_point=..., end_point=...,</span></span><br><span class="line">    line_after_interpolate=...) at /mnt/cpp/gac_gerrit/AppAPAPlaning/QPlan/qt/plan/collision_detection.cpp:554</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x000000000043acf4 <span class="keyword">in</span> CollisionDetection::obsLineInterpolate (this=0xffffbc139f38, park_data=...)</span></span><br><span class="line">    at /mnt/cpp/gac_gerrit/AppAPAPlaning/QPlan/qt/plan/collision_detection.cpp:506</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x000000000043a078 <span class="keyword">in</span> CollisionDetection::updateMaps (this=0xffffbc139f38, park_data=...)</span></span><br><span class="line">    at /mnt/cpp/gac_gerrit/AppAPAPlaning/QPlan/qt/plan/collision_detection.cpp:331</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  0x000000000046cd60 <span class="keyword">in</span> RealTimePlan::plan (this=0xffffbc139010, park_data=...)</span></span><br><span class="line">    at /mnt/cpp/gac_gerrit/AppAPAPlaning/QPlan/qt/plan/real_time_plan.cpp:20</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4  0x000000000051f7b0 <span class="keyword">in</span> main () at /mnt/cpp/gac_gerrit/AppAPAPlaning/QPlan/x9u_a02/communication_frame/apa_plan/main.cpp:80</span></span><br><span class="line">(gdb) frame 2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x000000000043a078 <span class="keyword">in</span> CollisionDetection::updateMaps (this=0xffffbc139f38, park_data=...)</span></span><br><span class="line">    at /mnt/cpp/gac_gerrit/AppAPAPlaning/QPlan/qt/plan/collision_detection.cpp:331</span><br><span class="line">331     in /mnt/cpp/gac_gerrit/AppAPAPlaning/QPlan/qt/plan/collision_detection.cpp</span><br><span class="line">(gdb) info args</span><br><span class="line">this = 0xffffbc139f38</span><br><span class="line">park_data = &lt;error reading variable&gt;</span><br><span class="line">(gdb) print park_data.low_obs_segs</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = &#123;&lt;std::_Vector_base&lt;std::vector&lt;Point2f, std::allocator&lt;Point2f&gt; &gt;, std::allocator&lt;std::vector&lt;Point2f, std::allocator&lt;Point2f&gt; &gt; &gt; &gt;&gt; = &#123;</span></span><br><span class="line">    _M_impl = &#123;&lt;std::allocator&lt;std::vector&lt;Point2f, std::allocator&lt;Point2f&gt; &gt; &gt;&gt; = &#123;&lt;__gnu_cxx::new_allocator&lt;std::vector&lt;Point2f, std::allocator&lt;Point2f&gt; &gt; &gt;&gt; = &#123;&lt;No data fields&gt;&#125;, &lt;No data fields&gt;&#125;, _M_start = 0x39eceaf0, _M_finish = 0x39eceb08,</span><br><span class="line">      _M_end_of_storage = 0x39eceb08&#125;&#125;, &lt;No data fields&gt;&#125;</span><br><span class="line">(gdb) print park_data.low_obs_segs._M_impl._M_start</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = (std::_Vector_base&lt;std::vector&lt;Point2f, std::allocator&lt;Point2f&gt; &gt;, std::allocator&lt;std::vector&lt;Point2f, std::allocator&lt;Point2f&gt; &gt; &gt; &gt;::pointer) 0x39eceaf0</span></span><br><span class="line">(gdb) print park_data.low_obs_segs._M_impl._M_start@2</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = &#123;0x39eceaf0, 0x39eceb08&#125;</span></span><br><span class="line">(gdb) print park_data.low_obs_segs[0]</span><br><span class="line">You can&#x27;t do that without a process to debug.</span><br><span class="line">(gdb) print *(park_data.low_obs_segs._M_impl._M_start)._M_impl._M_start</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">4 = &#123;x = 1.18648558e-08, y = 0&#125;</span></span><br><span class="line">(gdb) print *(park_data.low_obs_segs._M_impl._M_start)._M_impl._M_start@2</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">5 = &#123;&#123;x = 1.18648558e-08, y = 0&#125;, &#123;x = 5.35350003e+22, y = 1.09787143e-05&#125;&#125;</span></span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li><code>frame 2</code>用于切换调试器的当前堆栈帧（stack frame）到栈的第二个帧</li>
<li><code>info args</code>显示当前堆栈帧（stack frame）中的函数参数信息</li>
<li><code>print *(myVector._M_impl._M_start)@myVector.size()</code></li>
</ul>
<p>用于打印整个std::vector&lt;&gt;的内容，如果后面改成@number，那么意味着打印数组的前<code>number</code>个元素。</p>
<ul>
<li><code>info locals</code>用于显示当前堆栈帧（stack frame）中的局部变量的值</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">胡云浩</p>
  <div class="site-description" itemprop="description">记录生活，记录工作，记录学习</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">52</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">胡云浩</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
